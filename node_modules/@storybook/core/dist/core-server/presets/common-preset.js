import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
import { dirname as ESM_COMPAT_dirname } from 'node:path';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const __dirname = ESM_COMPAT_dirname(__filename);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var Ky = Object.create;
var $r = Object.defineProperty;
var Xy = Object.getOwnPropertyDescriptor;
var zy = Object.getOwnPropertyNames;
var Jy = Object.getPrototypeOf, Qy = Object.prototype.hasOwnProperty;
var s = (t, e) => $r(t, "name", { value: e, configurable: !0 }), A = /* @__PURE__ */ ((t) => typeof require < "u" ? require : typeof Proxy <
"u" ? new Proxy(t, {
  get: (e, r) => (typeof require < "u" ? require : e)[r]
}) : t)(function(t) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + t + '" is not supported');
});
var Ye = (t, e) => () => (t && (e = t(t = 0)), e);
var d = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Wa = (t, e) => {
  for (var r in e)
    $r(t, r, { get: e[r], enumerable: !0 });
}, Zy = (t, e, r, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of zy(e))
      !Qy.call(t, n) && n !== r && $r(t, n, { get: () => e[n], enumerable: !(i = Xy(e, n)) || i.enumerable });
  return t;
};
var Oe = (t, e, r) => (r = t != null ? Ky(Jy(t)) : {}, Zy(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !t || !t.__esModule ? $r(r, "default", { value: t, enumerable: !0 }) : r,
  t
));

// ../node_modules/universalify/index.js
var ne = d((zi) => {
  "use strict";
  zi.fromCallback = function(t) {
    return Object.defineProperty(function(...e) {
      if (typeof e[e.length - 1] == "function") t.apply(this, e);
      else
        return new Promise((r, i) => {
          t.call(
            this,
            ...e,
            (n, o) => n != null ? i(n) : r(o)
          );
        });
    }, "name", { value: t.name });
  };
  zi.fromPromise = function(t) {
    return Object.defineProperty(function(...e) {
      let r = e[e.length - 1];
      if (typeof r != "function") return t.apply(this, e);
      t.apply(this, e.slice(0, -1)).then((i) => r(null, i), r);
    }, "name", { value: t.name });
  };
});

// ../node_modules/graceful-fs/polyfills.js
var Ua = d((M0, Ga) => {
  var at = A("constants"), eS = process.cwd, Fr = null, tS = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return Fr || (Fr = eS.call(process)), Fr;
  };
  try {
    process.cwd();
  } catch {
  }
  typeof process.chdir == "function" && (Ji = process.chdir, process.chdir = function(t) {
    Fr = null, Ji.call(process, t);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, Ji));
  var Ji;
  Ga.exports = rS;
  function rS(t) {
    at.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && e(t), t.lutimes || r(t), t.chown = o(t.chown), t.fchown =
    o(t.fchown), t.lchown = o(t.lchown), t.chmod = i(t.chmod), t.fchmod = i(t.fchmod), t.lchmod = i(t.lchmod), t.chownSync = a(t.chownSync),
    t.fchownSync = a(t.fchownSync), t.lchownSync = a(t.lchownSync), t.chmodSync = n(t.chmodSync), t.fchmodSync = n(t.fchmodSync), t.lchmodSync =
    n(t.lchmodSync), t.stat = u(t.stat), t.fstat = u(t.fstat), t.lstat = u(t.lstat), t.statSync = c(t.statSync), t.fstatSync = c(t.fstatSync),
    t.lstatSync = c(t.lstatSync), t.chmod && !t.lchmod && (t.lchmod = function(l, p, f) {
      f && process.nextTick(f);
    }, t.lchmodSync = function() {
    }), t.chown && !t.lchown && (t.lchown = function(l, p, f, b) {
      b && process.nextTick(b);
    }, t.lchownSync = function() {
    }), tS === "win32" && (t.rename = typeof t.rename != "function" ? t.rename : function(l) {
      function p(f, b, m) {
        var w = Date.now(), _ = 0;
        l(f, b, /* @__PURE__ */ s(function P(q) {
          if (q && (q.code === "EACCES" || q.code === "EPERM" || q.code === "EBUSY") && Date.now() - w < 6e4) {
            setTimeout(function() {
              t.stat(b, function(R, te) {
                R && R.code === "ENOENT" ? l(f, b, P) : m(q);
              });
            }, _), _ < 100 && (_ += 10);
            return;
          }
          m && m(q);
        }, "CB"));
      }
      return s(p, "rename"), Object.setPrototypeOf && Object.setPrototypeOf(p, l), p;
    }(t.rename)), t.read = typeof t.read != "function" ? t.read : function(l) {
      function p(f, b, m, w, _, P) {
        var q;
        if (P && typeof P == "function") {
          var R = 0;
          q = /* @__PURE__ */ s(function(te, I, H) {
            if (te && te.code === "EAGAIN" && R < 10)
              return R++, l.call(t, f, b, m, w, _, q);
            P.apply(this, arguments);
          }, "callback");
        }
        return l.call(t, f, b, m, w, _, q);
      }
      return s(p, "read"), Object.setPrototypeOf && Object.setPrototypeOf(p, l), p;
    }(t.read), t.readSync = typeof t.readSync != "function" ? t.readSync : /* @__PURE__ */ function(l) {
      return function(p, f, b, m, w) {
        for (var _ = 0; ; )
          try {
            return l.call(t, p, f, b, m, w);
          } catch (P) {
            if (P.code === "EAGAIN" && _ < 10) {
              _++;
              continue;
            }
            throw P;
          }
      };
    }(t.readSync);
    function e(l) {
      l.lchmod = function(p, f, b) {
        l.open(
          p,
          at.O_WRONLY | at.O_SYMLINK,
          f,
          function(m, w) {
            if (m) {
              b && b(m);
              return;
            }
            l.fchmod(w, f, function(_) {
              l.close(w, function(P) {
                b && b(_ || P);
              });
            });
          }
        );
      }, l.lchmodSync = function(p, f) {
        var b = l.openSync(p, at.O_WRONLY | at.O_SYMLINK, f), m = !0, w;
        try {
          w = l.fchmodSync(b, f), m = !1;
        } finally {
          if (m)
            try {
              l.closeSync(b);
            } catch {
            }
          else
            l.closeSync(b);
        }
        return w;
      };
    }
    s(e, "patchLchmod");
    function r(l) {
      at.hasOwnProperty("O_SYMLINK") && l.futimes ? (l.lutimes = function(p, f, b, m) {
        l.open(p, at.O_SYMLINK, function(w, _) {
          if (w) {
            m && m(w);
            return;
          }
          l.futimes(_, f, b, function(P) {
            l.close(_, function(q) {
              m && m(P || q);
            });
          });
        });
      }, l.lutimesSync = function(p, f, b) {
        var m = l.openSync(p, at.O_SYMLINK), w, _ = !0;
        try {
          w = l.futimesSync(m, f, b), _ = !1;
        } finally {
          if (_)
            try {
              l.closeSync(m);
            } catch {
            }
          else
            l.closeSync(m);
        }
        return w;
      }) : l.futimes && (l.lutimes = function(p, f, b, m) {
        m && process.nextTick(m);
      }, l.lutimesSync = function() {
      });
    }
    s(r, "patchLutimes");
    function i(l) {
      return l && function(p, f, b) {
        return l.call(t, p, f, function(m) {
          h(m) && (m = null), b && b.apply(this, arguments);
        });
      };
    }
    s(i, "chmodFix");
    function n(l) {
      return l && function(p, f) {
        try {
          return l.call(t, p, f);
        } catch (b) {
          if (!h(b)) throw b;
        }
      };
    }
    s(n, "chmodFixSync");
    function o(l) {
      return l && function(p, f, b, m) {
        return l.call(t, p, f, b, function(w) {
          h(w) && (w = null), m && m.apply(this, arguments);
        });
      };
    }
    s(o, "chownFix");
    function a(l) {
      return l && function(p, f, b) {
        try {
          return l.call(t, p, f, b);
        } catch (m) {
          if (!h(m)) throw m;
        }
      };
    }
    s(a, "chownFixSync");
    function u(l) {
      return l && function(p, f, b) {
        typeof f == "function" && (b = f, f = null);
        function m(w, _) {
          _ && (_.uid < 0 && (_.uid += 4294967296), _.gid < 0 && (_.gid += 4294967296)), b && b.apply(this, arguments);
        }
        return s(m, "callback"), f ? l.call(t, p, f, m) : l.call(t, p, m);
      };
    }
    s(u, "statFix");
    function c(l) {
      return l && function(p, f) {
        var b = f ? l.call(t, p, f) : l.call(t, p);
        return b && (b.uid < 0 && (b.uid += 4294967296), b.gid < 0 && (b.gid += 4294967296)), b;
      };
    }
    s(c, "statFixSync");
    function h(l) {
      if (!l || l.code === "ENOSYS")
        return !0;
      var p = !process.getuid || process.getuid() !== 0;
      return !!(p && (l.code === "EINVAL" || l.code === "EPERM"));
    }
    s(h, "chownErOk");
  }
  s(rS, "patch");
});

// ../node_modules/graceful-fs/legacy-streams.js
var Ka = d((j0, Ya) => {
  var Va = A("stream").Stream;
  Ya.exports = iS;
  function iS(t) {
    return {
      ReadStream: e,
      WriteStream: r
    };
    function e(i, n) {
      if (!(this instanceof e)) return new e(i, n);
      Va.call(this);
      var o = this;
      this.path = i, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, n =
      n || {};
      for (var a = Object.keys(n), u = 0, c = a.length; u < c; u++) {
        var h = a[u];
        this[h] = n[h];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          o._read();
        });
        return;
      }
      t.open(this.path, this.flags, this.mode, function(l, p) {
        if (l) {
          o.emit("error", l), o.readable = !1;
          return;
        }
        o.fd = p, o.emit("open", p), o._read();
      });
    }
    function r(i, n) {
      if (!(this instanceof r)) return new r(i, n);
      Va.call(this), this.path = i, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten =
      0, n = n || {};
      for (var o = Object.keys(n), a = 0, u = o.length; a < u; a++) {
        var c = o[a];
        this[c] = n[c];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = t.open, this._queue.push([this._open, this.path, this.flags, this.
      mode, void 0]), this.flush());
    }
  }
  s(iS, "legacy");
});

// ../node_modules/graceful-fs/clone.js
var za = d((B0, Xa) => {
  "use strict";
  Xa.exports = nS;
  var sS = Object.getPrototypeOf || function(t) {
    return t.__proto__;
  };
  function nS(t) {
    if (t === null || typeof t != "object")
      return t;
    if (t instanceof Object)
      var e = { __proto__: sS(t) };
    else
      var e = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(t).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    }), e;
  }
  s(nS, "clone");
});

// ../node_modules/graceful-fs/graceful-fs.js
var It = d((G0, es) => {
  var X = A("fs"), oS = Ua(), aS = Ka(), uS = za(), Nr = A("util"), ae, Lr;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (ae = Symbol.for("graceful-fs.queue"), Lr = Symbol.for("graceful-fs.previ\
ous")) : (ae = "___graceful-fs.queue", Lr = "___graceful-fs.previous");
  function cS() {
  }
  s(cS, "noop");
  function Za(t, e) {
    Object.defineProperty(t, ae, {
      get: /* @__PURE__ */ s(function() {
        return e;
      }, "get")
    });
  }
  s(Za, "publishQueue");
  var _t = cS;
  Nr.debuglog ? _t = Nr.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (_t = /* @__PURE__ */ s(function() {
    var t = Nr.format.apply(Nr, arguments);
    t = "GFS4: " + t.split(/\n/).join(`
GFS4: `), console.error(t);
  }, "debug"));
  X[ae] || (Ja = global[ae] || [], Za(X, Ja), X.close = function(t) {
    function e(r, i) {
      return t.call(X, r, function(n) {
        n || Qa(), typeof i == "function" && i.apply(this, arguments);
      });
    }
    return s(e, "close"), Object.defineProperty(e, Lr, {
      value: t
    }), e;
  }(X.close), X.closeSync = function(t) {
    function e(r) {
      t.apply(X, arguments), Qa();
    }
    return s(e, "closeSync"), Object.defineProperty(e, Lr, {
      value: t
    }), e;
  }(X.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    _t(X[ae]), A("assert").equal(X[ae].length, 0);
  }));
  var Ja;
  global[ae] || Za(global, X[ae]);
  es.exports = Qi(uS(X));
  process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !X.__patched && (es.exports = Qi(X), X.__patched = !0);
  function Qi(t) {
    oS(t), t.gracefulify = Qi, t.createReadStream = I, t.createWriteStream = H;
    var e = t.readFile;
    t.readFile = r;
    function r(x, T, S) {
      return typeof T == "function" && (S = T, T = null), F(x, T, S);
      function F(D, W, g, y) {
        return e(D, W, function(N) {
          N && (N.code === "EMFILE" || N.code === "ENFILE") ? kt([F, [D, W, g], N, y || Date.now(), Date.now()]) : typeof g == "function" &&
          g.apply(this, arguments);
        });
      }
      s(F, "go$readFile");
    }
    s(r, "readFile");
    var i = t.writeFile;
    t.writeFile = n;
    function n(x, T, S, F) {
      return typeof S == "function" && (F = S, S = null), D(x, T, S, F);
      function D(W, g, y, N, O) {
        return i(W, g, y, function(j) {
          j && (j.code === "EMFILE" || j.code === "ENFILE") ? kt([D, [W, g, y, N], j, O || Date.now(), Date.now()]) : typeof N == "function" &&
          N.apply(this, arguments);
        });
      }
      s(D, "go$writeFile");
    }
    s(n, "writeFile");
    var o = t.appendFile;
    o && (t.appendFile = a);
    function a(x, T, S, F) {
      return typeof S == "function" && (F = S, S = null), D(x, T, S, F);
      function D(W, g, y, N, O) {
        return o(W, g, y, function(j) {
          j && (j.code === "EMFILE" || j.code === "ENFILE") ? kt([D, [W, g, y, N], j, O || Date.now(), Date.now()]) : typeof N == "function" &&
          N.apply(this, arguments);
        });
      }
      s(D, "go$appendFile");
    }
    s(a, "appendFile");
    var u = t.copyFile;
    u && (t.copyFile = c);
    function c(x, T, S, F) {
      return typeof S == "function" && (F = S, S = 0), D(x, T, S, F);
      function D(W, g, y, N, O) {
        return u(W, g, y, function(j) {
          j && (j.code === "EMFILE" || j.code === "ENFILE") ? kt([D, [W, g, y, N], j, O || Date.now(), Date.now()]) : typeof N == "function" &&
          N.apply(this, arguments);
        });
      }
      s(D, "go$copyFile");
    }
    s(c, "copyFile");
    var h = t.readdir;
    t.readdir = p;
    var l = /^v[0-5]\./;
    function p(x, T, S) {
      typeof T == "function" && (S = T, T = null);
      var F = l.test(process.version) ? /* @__PURE__ */ s(function(g, y, N, O) {
        return h(g, D(
          g,
          y,
          N,
          O
        ));
      }, "go$readdir") : /* @__PURE__ */ s(function(g, y, N, O) {
        return h(g, y, D(
          g,
          y,
          N,
          O
        ));
      }, "go$readdir");
      return F(x, T, S);
      function D(W, g, y, N) {
        return function(O, j) {
          O && (O.code === "EMFILE" || O.code === "ENFILE") ? kt([
            F,
            [W, g, y],
            O,
            N || Date.now(),
            Date.now()
          ]) : (j && j.sort && j.sort(), typeof y == "function" && y.call(this, O, j));
        };
      }
    }
    if (s(p, "readdir"), process.version.substr(0, 4) === "v0.8") {
      var f = aS(t);
      P = f.ReadStream, R = f.WriteStream;
    }
    var b = t.ReadStream;
    b && (P.prototype = Object.create(b.prototype), P.prototype.open = q);
    var m = t.WriteStream;
    m && (R.prototype = Object.create(m.prototype), R.prototype.open = te), Object.defineProperty(t, "ReadStream", {
      get: /* @__PURE__ */ s(function() {
        return P;
      }, "get"),
      set: /* @__PURE__ */ s(function(x) {
        P = x;
      }, "set"),
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(t, "WriteStream", {
      get: /* @__PURE__ */ s(function() {
        return R;
      }, "get"),
      set: /* @__PURE__ */ s(function(x) {
        R = x;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var w = P;
    Object.defineProperty(t, "FileReadStream", {
      get: /* @__PURE__ */ s(function() {
        return w;
      }, "get"),
      set: /* @__PURE__ */ s(function(x) {
        w = x;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var _ = R;
    Object.defineProperty(t, "FileWriteStream", {
      get: /* @__PURE__ */ s(function() {
        return _;
      }, "get"),
      set: /* @__PURE__ */ s(function(x) {
        _ = x;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    function P(x, T) {
      return this instanceof P ? (b.apply(this, arguments), this) : P.apply(Object.create(P.prototype), arguments);
    }
    s(P, "ReadStream");
    function q() {
      var x = this;
      C(x.path, x.flags, x.mode, function(T, S) {
        T ? (x.autoClose && x.destroy(), x.emit("error", T)) : (x.fd = S, x.emit("open", S), x.read());
      });
    }
    s(q, "ReadStream$open");
    function R(x, T) {
      return this instanceof R ? (m.apply(this, arguments), this) : R.apply(Object.create(R.prototype), arguments);
    }
    s(R, "WriteStream");
    function te() {
      var x = this;
      C(x.path, x.flags, x.mode, function(T, S) {
        T ? (x.destroy(), x.emit("error", T)) : (x.fd = S, x.emit("open", S));
      });
    }
    s(te, "WriteStream$open");
    function I(x, T) {
      return new t.ReadStream(x, T);
    }
    s(I, "createReadStream");
    function H(x, T) {
      return new t.WriteStream(x, T);
    }
    s(H, "createWriteStream");
    var $ = t.open;
    t.open = C;
    function C(x, T, S, F) {
      return typeof S == "function" && (F = S, S = null), D(x, T, S, F);
      function D(W, g, y, N, O) {
        return $(W, g, y, function(j, Ae) {
          j && (j.code === "EMFILE" || j.code === "ENFILE") ? kt([D, [W, g, y, N], j, O || Date.now(), Date.now()]) : typeof N == "function" &&
          N.apply(this, arguments);
        });
      }
      s(D, "go$open");
    }
    return s(C, "open"), t;
  }
  s(Qi, "patch");
  function kt(t) {
    _t("ENQUEUE", t[0].name, t[1]), X[ae].push(t), Zi();
  }
  s(kt, "enqueue");
  var Mr;
  function Qa() {
    for (var t = Date.now(), e = 0; e < X[ae].length; ++e)
      X[ae][e].length > 2 && (X[ae][e][3] = t, X[ae][e][4] = t);
    Zi();
  }
  s(Qa, "resetQueue");
  function Zi() {
    if (clearTimeout(Mr), Mr = void 0, X[ae].length !== 0) {
      var t = X[ae].shift(), e = t[0], r = t[1], i = t[2], n = t[3], o = t[4];
      if (n === void 0)
        _t("RETRY", e.name, r), e.apply(null, r);
      else if (Date.now() - n >= 6e4) {
        _t("TIMEOUT", e.name, r);
        var a = r.pop();
        typeof a == "function" && a.call(null, i);
      } else {
        var u = Date.now() - o, c = Math.max(o - n, 1), h = Math.min(c * 1.2, 100);
        u >= h ? (_t("RETRY", e.name, r), e.apply(null, r.concat([n]))) : X[ae].push(t);
      }
      Mr === void 0 && (Mr = setTimeout(Zi, 0));
    }
  }
  s(Zi, "retry");
});

// ../node_modules/fs-extra/lib/fs/index.js
var de = d((Ke) => {
  "use strict";
  var eu = ne().fromCallback, fe = It(), lS = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((t) => typeof fe[t] == "function");
  Object.assign(Ke, fe);
  lS.forEach((t) => {
    Ke[t] = eu(fe[t]);
  });
  Ke.exists = function(t, e) {
    return typeof e == "function" ? fe.exists(t, e) : new Promise((r) => fe.exists(t, r));
  };
  Ke.read = function(t, e, r, i, n, o) {
    return typeof o == "function" ? fe.read(t, e, r, i, n, o) : new Promise((a, u) => {
      fe.read(t, e, r, i, n, (c, h, l) => {
        if (c) return u(c);
        a({ bytesRead: h, buffer: l });
      });
    });
  };
  Ke.write = function(t, e, ...r) {
    return typeof r[r.length - 1] == "function" ? fe.write(t, e, ...r) : new Promise((i, n) => {
      fe.write(t, e, ...r, (o, a, u) => {
        if (o) return n(o);
        i({ bytesWritten: a, buffer: u });
      });
    });
  };
  Ke.readv = function(t, e, ...r) {
    return typeof r[r.length - 1] == "function" ? fe.readv(t, e, ...r) : new Promise((i, n) => {
      fe.readv(t, e, ...r, (o, a, u) => {
        if (o) return n(o);
        i({ bytesRead: a, buffers: u });
      });
    });
  };
  Ke.writev = function(t, e, ...r) {
    return typeof r[r.length - 1] == "function" ? fe.writev(t, e, ...r) : new Promise((i, n) => {
      fe.writev(t, e, ...r, (o, a, u) => {
        if (o) return n(o);
        i({ bytesWritten: a, buffers: u });
      });
    });
  };
  typeof fe.realpath.native == "function" ? Ke.realpath.native = eu(fe.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
});

// ../node_modules/fs-extra/lib/mkdirs/utils.js
var ru = d((Y0, tu) => {
  "use strict";
  var hS = A("path");
  tu.exports.checkPath = /* @__PURE__ */ s(function(e) {
    if (process.platform === "win32" && /[<>:"|?*]/.test(e.replace(hS.parse(e).root, ""))) {
      let i = new Error(`Path contains invalid characters: ${e}`);
      throw i.code = "EINVAL", i;
    }
  }, "checkPath");
});

// ../node_modules/fs-extra/lib/mkdirs/make-dir.js
var ou = d((X0, ts) => {
  "use strict";
  var iu = de(), { checkPath: su } = ru(), nu = /* @__PURE__ */ s((t) => {
    let e = { mode: 511 };
    return typeof t == "number" ? t : { ...e, ...t }.mode;
  }, "getMode");
  ts.exports.makeDir = async (t, e) => (su(t), iu.mkdir(t, {
    mode: nu(e),
    recursive: !0
  }));
  ts.exports.makeDirSync = (t, e) => (su(t), iu.mkdirSync(t, {
    mode: nu(e),
    recursive: !0
  }));
});

// ../node_modules/fs-extra/lib/mkdirs/index.js
var Ce = d((J0, au) => {
  "use strict";
  var fS = ne().fromPromise, { makeDir: dS, makeDirSync: rs } = ou(), is = fS(dS);
  au.exports = {
    mkdirs: is,
    mkdirsSync: rs,
    // alias
    mkdirp: is,
    mkdirpSync: rs,
    ensureDir: is,
    ensureDirSync: rs
  };
});

// ../node_modules/fs-extra/lib/path-exists/index.js
var ut = d((Q0, cu) => {
  "use strict";
  var pS = ne().fromPromise, uu = de();
  function mS(t) {
    return uu.access(t).then(() => !0).catch(() => !1);
  }
  s(mS, "pathExists");
  cu.exports = {
    pathExists: pS(mS),
    pathExistsSync: uu.existsSync
  };
});

// ../node_modules/fs-extra/lib/util/utimes.js
var ss = d((eC, lu) => {
  "use strict";
  var Dt = de(), gS = ne().fromPromise;
  async function yS(t, e, r) {
    let i = await Dt.open(t, "r+"), n = null;
    try {
      await Dt.futimes(i, e, r);
    } finally {
      try {
        await Dt.close(i);
      } catch (o) {
        n = o;
      }
    }
    if (n)
      throw n;
  }
  s(yS, "utimesMillis");
  function SS(t, e, r) {
    let i = Dt.openSync(t, "r+");
    return Dt.futimesSync(i, e, r), Dt.closeSync(i);
  }
  s(SS, "utimesMillisSync");
  lu.exports = {
    utimesMillis: gS(yS),
    utimesMillisSync: SS
  };
});

// ../node_modules/fs-extra/lib/util/stat.js
var xt = d((rC, pu) => {
  "use strict";
  var qt = de(), oe = A("path"), hu = ne().fromPromise;
  function bS(t, e, r) {
    let i = r.dereference ? (n) => qt.stat(n, { bigint: !0 }) : (n) => qt.lstat(n, { bigint: !0 });
    return Promise.all([
      i(t),
      i(e).catch((n) => {
        if (n.code === "ENOENT") return null;
        throw n;
      })
    ]).then(([n, o]) => ({ srcStat: n, destStat: o }));
  }
  s(bS, "getStats");
  function wS(t, e, r) {
    let i, n = r.dereference ? (a) => qt.statSync(a, { bigint: !0 }) : (a) => qt.lstatSync(a, { bigint: !0 }), o = n(t);
    try {
      i = n(e);
    } catch (a) {
      if (a.code === "ENOENT") return { srcStat: o, destStat: null };
      throw a;
    }
    return { srcStat: o, destStat: i };
  }
  s(wS, "getStatsSync");
  async function vS(t, e, r, i) {
    let { srcStat: n, destStat: o } = await bS(t, e, i);
    if (o) {
      if (er(n, o)) {
        let a = oe.basename(t), u = oe.basename(e);
        if (r === "move" && a !== u && a.toLowerCase() === u.toLowerCase())
          return { srcStat: n, destStat: o, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (n.isDirectory() && !o.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`);
      if (!n.isDirectory() && o.isDirectory())
        throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`);
    }
    if (n.isDirectory() && ns(t, e))
      throw new Error(jr(t, e, r));
    return { srcStat: n, destStat: o };
  }
  s(vS, "checkPaths");
  function _S(t, e, r, i) {
    let { srcStat: n, destStat: o } = wS(t, e, i);
    if (o) {
      if (er(n, o)) {
        let a = oe.basename(t), u = oe.basename(e);
        if (r === "move" && a !== u && a.toLowerCase() === u.toLowerCase())
          return { srcStat: n, destStat: o, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (n.isDirectory() && !o.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${e}' with directory '${t}'.`);
      if (!n.isDirectory() && o.isDirectory())
        throw new Error(`Cannot overwrite directory '${e}' with non-directory '${t}'.`);
    }
    if (n.isDirectory() && ns(t, e))
      throw new Error(jr(t, e, r));
    return { srcStat: n, destStat: o };
  }
  s(_S, "checkPathsSync");
  async function fu(t, e, r, i) {
    let n = oe.resolve(oe.dirname(t)), o = oe.resolve(oe.dirname(r));
    if (o === n || o === oe.parse(o).root) return;
    let a;
    try {
      a = await qt.stat(o, { bigint: !0 });
    } catch (u) {
      if (u.code === "ENOENT") return;
      throw u;
    }
    if (er(e, a))
      throw new Error(jr(t, r, i));
    return fu(t, e, o, i);
  }
  s(fu, "checkParentPaths");
  function du(t, e, r, i) {
    let n = oe.resolve(oe.dirname(t)), o = oe.resolve(oe.dirname(r));
    if (o === n || o === oe.parse(o).root) return;
    let a;
    try {
      a = qt.statSync(o, { bigint: !0 });
    } catch (u) {
      if (u.code === "ENOENT") return;
      throw u;
    }
    if (er(e, a))
      throw new Error(jr(t, r, i));
    return du(t, e, o, i);
  }
  s(du, "checkParentPathsSync");
  function er(t, e) {
    return e.ino && e.dev && e.ino === t.ino && e.dev === t.dev;
  }
  s(er, "areIdentical");
  function ns(t, e) {
    let r = oe.resolve(t).split(oe.sep).filter((n) => n), i = oe.resolve(e).split(oe.sep).filter((n) => n);
    return r.every((n, o) => i[o] === n);
  }
  s(ns, "isSrcSubdir");
  function jr(t, e, r) {
    return `Cannot ${r} '${t}' to a subdirectory of itself, '${e}'.`;
  }
  s(jr, "errMsg");
  pu.exports = {
    // checkPaths
    checkPaths: hu(vS),
    checkPathsSync: _S,
    // checkParent
    checkParentPaths: hu(fu),
    checkParentPathsSync: du,
    // Misc
    isSrcSubdir: ns,
    areIdentical: er
  };
});

// ../node_modules/fs-extra/lib/copy/copy.js
var bu = d((sC, Su) => {
  "use strict";
  var ue = de(), tr = A("path"), { mkdirs: xS } = Ce(), { pathExists: ES } = ut(), { utimesMillis: PS } = ss(), rr = xt();
  async function RS(t, e, r = {}) {
    typeof r == "function" && (r = { filter: r }), r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite :
    r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0001"
    );
    let { srcStat: i, destStat: n } = await rr.checkPaths(t, e, "copy", r);
    if (await rr.checkParentPaths(t, i, e, "copy"), !await gu(t, e, r)) return;
    let a = tr.dirname(e);
    await ES(a) || await xS(a), await yu(n, t, e, r);
  }
  s(RS, "copy");
  async function gu(t, e, r) {
    return r.filter ? r.filter(t, e) : !0;
  }
  s(gu, "runFilter");
  async function yu(t, e, r, i) {
    let o = await (i.dereference ? ue.stat : ue.lstat)(e);
    if (o.isDirectory()) return TS(o, t, e, r, i);
    if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice()) return AS(o, t, e, r, i);
    if (o.isSymbolicLink()) return kS(t, e, r, i);
    throw o.isSocket() ? new Error(`Cannot copy a socket file: ${e}`) : o.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${e}`) : new Error(
    `Unknown file: ${e}`);
  }
  s(yu, "getStatsAndPerformCopy");
  async function AS(t, e, r, i, n) {
    if (!e) return mu(t, r, i, n);
    if (n.overwrite)
      return await ue.unlink(i), mu(t, r, i, n);
    if (n.errorOnExist)
      throw new Error(`'${i}' already exists`);
  }
  s(AS, "onFile");
  async function mu(t, e, r, i) {
    if (await ue.copyFile(e, r), i.preserveTimestamps) {
      OS(t.mode) && await CS(r, t.mode);
      let n = await ue.stat(e);
      await PS(r, n.atime, n.mtime);
    }
    return ue.chmod(r, t.mode);
  }
  s(mu, "copyFile");
  function OS(t) {
    return (t & 128) === 0;
  }
  s(OS, "fileIsNotWritable");
  function CS(t, e) {
    return ue.chmod(t, e | 128);
  }
  s(CS, "makeFileWritable");
  async function TS(t, e, r, i, n) {
    e || await ue.mkdir(i);
    let o = await ue.readdir(r);
    await Promise.all(o.map(async (a) => {
      let u = tr.join(r, a), c = tr.join(i, a);
      if (!await gu(u, c, n)) return;
      let { destStat: l } = await rr.checkPaths(u, c, "copy", n);
      return yu(l, u, c, n);
    })), e || await ue.chmod(i, t.mode);
  }
  s(TS, "onDir");
  async function kS(t, e, r, i) {
    let n = await ue.readlink(e);
    if (i.dereference && (n = tr.resolve(process.cwd(), n)), !t)
      return ue.symlink(n, r);
    let o = null;
    try {
      o = await ue.readlink(r);
    } catch (a) {
      if (a.code === "EINVAL" || a.code === "UNKNOWN") return ue.symlink(n, r);
      throw a;
    }
    if (i.dereference && (o = tr.resolve(process.cwd(), o)), rr.isSrcSubdir(n, o))
      throw new Error(`Cannot copy '${n}' to a subdirectory of itself, '${o}'.`);
    if (rr.isSrcSubdir(o, n))
      throw new Error(`Cannot overwrite '${o}' with '${n}'.`);
    return await ue.unlink(r), ue.symlink(n, r);
  }
  s(kS, "onLink");
  Su.exports = RS;
});

// ../node_modules/fs-extra/lib/copy/copy-sync.js
var Eu = d((oC, xu) => {
  "use strict";
  var pe = It(), ir = A("path"), IS = Ce().mkdirsSync, DS = ss().utimesMillisSync, sr = xt();
  function qS(t, e, r) {
    typeof r == "function" && (r = { filter: r }), r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ?
    !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0002"
    );
    let { srcStat: i, destStat: n } = sr.checkPathsSync(t, e, "copy", r);
    if (sr.checkParentPathsSync(t, i, e, "copy"), r.filter && !r.filter(t, e)) return;
    let o = ir.dirname(e);
    return pe.existsSync(o) || IS(o), wu(n, t, e, r);
  }
  s(qS, "copySync");
  function wu(t, e, r, i) {
    let o = (i.dereference ? pe.statSync : pe.lstatSync)(e);
    if (o.isDirectory()) return HS(o, t, e, r, i);
    if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice()) return $S(o, t, e, r, i);
    if (o.isSymbolicLink()) return GS(t, e, r, i);
    throw o.isSocket() ? new Error(`Cannot copy a socket file: ${e}`) : o.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${e}`) : new Error(
    `Unknown file: ${e}`);
  }
  s(wu, "getStats");
  function $S(t, e, r, i, n) {
    return e ? FS(t, r, i, n) : vu(t, r, i, n);
  }
  s($S, "onFile");
  function FS(t, e, r, i) {
    if (i.overwrite)
      return pe.unlinkSync(r), vu(t, e, r, i);
    if (i.errorOnExist)
      throw new Error(`'${r}' already exists`);
  }
  s(FS, "mayCopyFile");
  function vu(t, e, r, i) {
    return pe.copyFileSync(e, r), i.preserveTimestamps && NS(t.mode, e, r), os(r, t.mode);
  }
  s(vu, "copyFile");
  function NS(t, e, r) {
    return MS(t) && LS(r, t), jS(e, r);
  }
  s(NS, "handleTimestamps");
  function MS(t) {
    return (t & 128) === 0;
  }
  s(MS, "fileIsNotWritable");
  function LS(t, e) {
    return os(t, e | 128);
  }
  s(LS, "makeFileWritable");
  function os(t, e) {
    return pe.chmodSync(t, e);
  }
  s(os, "setDestMode");
  function jS(t, e) {
    let r = pe.statSync(t);
    return DS(e, r.atime, r.mtime);
  }
  s(jS, "setDestTimestamps");
  function HS(t, e, r, i, n) {
    return e ? _u(r, i, n) : BS(t.mode, r, i, n);
  }
  s(HS, "onDir");
  function BS(t, e, r, i) {
    return pe.mkdirSync(r), _u(e, r, i), os(r, t);
  }
  s(BS, "mkDirAndCopy");
  function _u(t, e, r) {
    pe.readdirSync(t).forEach((i) => WS(i, t, e, r));
  }
  s(_u, "copyDir");
  function WS(t, e, r, i) {
    let n = ir.join(e, t), o = ir.join(r, t);
    if (i.filter && !i.filter(n, o)) return;
    let { destStat: a } = sr.checkPathsSync(n, o, "copy", i);
    return wu(a, n, o, i);
  }
  s(WS, "copyDirItem");
  function GS(t, e, r, i) {
    let n = pe.readlinkSync(e);
    if (i.dereference && (n = ir.resolve(process.cwd(), n)), t) {
      let o;
      try {
        o = pe.readlinkSync(r);
      } catch (a) {
        if (a.code === "EINVAL" || a.code === "UNKNOWN") return pe.symlinkSync(n, r);
        throw a;
      }
      if (i.dereference && (o = ir.resolve(process.cwd(), o)), sr.isSrcSubdir(n, o))
        throw new Error(`Cannot copy '${n}' to a subdirectory of itself, '${o}'.`);
      if (sr.isSrcSubdir(o, n))
        throw new Error(`Cannot overwrite '${o}' with '${n}'.`);
      return US(n, r);
    } else
      return pe.symlinkSync(n, r);
  }
  s(GS, "onLink");
  function US(t, e) {
    return pe.unlinkSync(e), pe.symlinkSync(t, e);
  }
  s(US, "copyLink");
  xu.exports = qS;
});

// ../node_modules/fs-extra/lib/copy/index.js
var Hr = d((uC, Pu) => {
  "use strict";
  var VS = ne().fromPromise;
  Pu.exports = {
    copy: VS(bu()),
    copySync: Eu()
  };
});

// ../node_modules/fs-extra/lib/remove/index.js
var nr = d((cC, Au) => {
  "use strict";
  var Ru = It(), YS = ne().fromCallback;
  function KS(t, e) {
    Ru.rm(t, { recursive: !0, force: !0 }, e);
  }
  s(KS, "remove");
  function XS(t) {
    Ru.rmSync(t, { recursive: !0, force: !0 });
  }
  s(XS, "removeSync");
  Au.exports = {
    remove: YS(KS),
    removeSync: XS
  };
});

// ../node_modules/fs-extra/lib/empty/index.js
var $u = d((hC, qu) => {
  "use strict";
  var zS = ne().fromPromise, Tu = de(), ku = A("path"), Iu = Ce(), Du = nr(), Ou = zS(/* @__PURE__ */ s(async function(e) {
    let r;
    try {
      r = await Tu.readdir(e);
    } catch {
      return Iu.mkdirs(e);
    }
    return Promise.all(r.map((i) => Du.remove(ku.join(e, i))));
  }, "emptyDir"));
  function Cu(t) {
    let e;
    try {
      e = Tu.readdirSync(t);
    } catch {
      return Iu.mkdirsSync(t);
    }
    e.forEach((r) => {
      r = ku.join(t, r), Du.removeSync(r);
    });
  }
  s(Cu, "emptyDirSync");
  qu.exports = {
    emptyDirSync: Cu,
    emptydirSync: Cu,
    emptyDir: Ou,
    emptydir: Ou
  };
});

// ../node_modules/fs-extra/lib/ensure/file.js
var Lu = d((dC, Mu) => {
  "use strict";
  var JS = ne().fromPromise, Fu = A("path"), Xe = de(), Nu = Ce();
  async function QS(t) {
    let e;
    try {
      e = await Xe.stat(t);
    } catch {
    }
    if (e && e.isFile()) return;
    let r = Fu.dirname(t), i = null;
    try {
      i = await Xe.stat(r);
    } catch (n) {
      if (n.code === "ENOENT") {
        await Nu.mkdirs(r), await Xe.writeFile(t, "");
        return;
      } else
        throw n;
    }
    i.isDirectory() ? await Xe.writeFile(t, "") : await Xe.readdir(r);
  }
  s(QS, "createFile");
  function ZS(t) {
    let e;
    try {
      e = Xe.statSync(t);
    } catch {
    }
    if (e && e.isFile()) return;
    let r = Fu.dirname(t);
    try {
      Xe.statSync(r).isDirectory() || Xe.readdirSync(r);
    } catch (i) {
      if (i && i.code === "ENOENT") Nu.mkdirsSync(r);
      else throw i;
    }
    Xe.writeFileSync(t, "");
  }
  s(ZS, "createFileSync");
  Mu.exports = {
    createFile: JS(QS),
    createFileSync: ZS
  };
});

// ../node_modules/fs-extra/lib/ensure/link.js
var Gu = d((mC, Wu) => {
  "use strict";
  var eb = ne().fromPromise, ju = A("path"), ct = de(), Hu = Ce(), { pathExists: tb } = ut(), { areIdentical: Bu } = xt();
  async function rb(t, e) {
    let r;
    try {
      r = await ct.lstat(e);
    } catch {
    }
    let i;
    try {
      i = await ct.lstat(t);
    } catch (a) {
      throw a.message = a.message.replace("lstat", "ensureLink"), a;
    }
    if (r && Bu(i, r)) return;
    let n = ju.dirname(e);
    await tb(n) || await Hu.mkdirs(n), await ct.link(t, e);
  }
  s(rb, "createLink");
  function ib(t, e) {
    let r;
    try {
      r = ct.lstatSync(e);
    } catch {
    }
    try {
      let o = ct.lstatSync(t);
      if (r && Bu(o, r)) return;
    } catch (o) {
      throw o.message = o.message.replace("lstat", "ensureLink"), o;
    }
    let i = ju.dirname(e);
    return ct.existsSync(i) || Hu.mkdirsSync(i), ct.linkSync(t, e);
  }
  s(ib, "createLinkSync");
  Wu.exports = {
    createLink: eb(rb),
    createLinkSync: ib
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink-paths.js
var Vu = d((yC, Uu) => {
  "use strict";
  var lt = A("path"), or = de(), { pathExists: sb } = ut(), nb = ne().fromPromise;
  async function ob(t, e) {
    if (lt.isAbsolute(t)) {
      try {
        await or.lstat(t);
      } catch (o) {
        throw o.message = o.message.replace("lstat", "ensureSymlink"), o;
      }
      return {
        toCwd: t,
        toDst: t
      };
    }
    let r = lt.dirname(e), i = lt.join(r, t);
    if (await sb(i))
      return {
        toCwd: i,
        toDst: t
      };
    try {
      await or.lstat(t);
    } catch (o) {
      throw o.message = o.message.replace("lstat", "ensureSymlink"), o;
    }
    return {
      toCwd: t,
      toDst: lt.relative(r, t)
    };
  }
  s(ob, "symlinkPaths");
  function ab(t, e) {
    if (lt.isAbsolute(t)) {
      if (!or.existsSync(t)) throw new Error("absolute srcpath does not exist");
      return {
        toCwd: t,
        toDst: t
      };
    }
    let r = lt.dirname(e), i = lt.join(r, t);
    if (or.existsSync(i))
      return {
        toCwd: i,
        toDst: t
      };
    if (!or.existsSync(t)) throw new Error("relative srcpath does not exist");
    return {
      toCwd: t,
      toDst: lt.relative(r, t)
    };
  }
  s(ab, "symlinkPathsSync");
  Uu.exports = {
    symlinkPaths: nb(ob),
    symlinkPathsSync: ab
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink-type.js
var Xu = d((bC, Ku) => {
  "use strict";
  var Yu = de(), ub = ne().fromPromise;
  async function cb(t, e) {
    if (e) return e;
    let r;
    try {
      r = await Yu.lstat(t);
    } catch {
      return "file";
    }
    return r && r.isDirectory() ? "dir" : "file";
  }
  s(cb, "symlinkType");
  function lb(t, e) {
    if (e) return e;
    let r;
    try {
      r = Yu.lstatSync(t);
    } catch {
      return "file";
    }
    return r && r.isDirectory() ? "dir" : "file";
  }
  s(lb, "symlinkTypeSync");
  Ku.exports = {
    symlinkType: ub(cb),
    symlinkTypeSync: lb
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink.js
var Zu = d((vC, Qu) => {
  "use strict";
  var hb = ne().fromPromise, zu = A("path"), Fe = de(), { mkdirs: fb, mkdirsSync: db } = Ce(), { symlinkPaths: pb, symlinkPathsSync: mb } = Vu(),
  { symlinkType: gb, symlinkTypeSync: yb } = Xu(), { pathExists: Sb } = ut(), { areIdentical: Ju } = xt();
  async function bb(t, e, r) {
    let i;
    try {
      i = await Fe.lstat(e);
    } catch {
    }
    if (i && i.isSymbolicLink()) {
      let [u, c] = await Promise.all([
        Fe.stat(t),
        Fe.stat(e)
      ]);
      if (Ju(u, c)) return;
    }
    let n = await pb(t, e);
    t = n.toDst;
    let o = await gb(n.toCwd, r), a = zu.dirname(e);
    return await Sb(a) || await fb(a), Fe.symlink(t, e, o);
  }
  s(bb, "createSymlink");
  function wb(t, e, r) {
    let i;
    try {
      i = Fe.lstatSync(e);
    } catch {
    }
    if (i && i.isSymbolicLink()) {
      let u = Fe.statSync(t), c = Fe.statSync(e);
      if (Ju(u, c)) return;
    }
    let n = mb(t, e);
    t = n.toDst, r = yb(n.toCwd, r);
    let o = zu.dirname(e);
    return Fe.existsSync(o) || db(o), Fe.symlinkSync(t, e, r);
  }
  s(wb, "createSymlinkSync");
  Qu.exports = {
    createSymlink: hb(bb),
    createSymlinkSync: wb
  };
});

// ../node_modules/fs-extra/lib/ensure/index.js
var ac = d((xC, oc) => {
  "use strict";
  var { createFile: ec, createFileSync: tc } = Lu(), { createLink: rc, createLinkSync: ic } = Gu(), { createSymlink: sc, createSymlinkSync: nc } = Zu();
  oc.exports = {
    // file
    createFile: ec,
    createFileSync: tc,
    ensureFile: ec,
    ensureFileSync: tc,
    // link
    createLink: rc,
    createLinkSync: ic,
    ensureLink: rc,
    ensureLinkSync: ic,
    // symlink
    createSymlink: sc,
    createSymlinkSync: nc,
    ensureSymlink: sc,
    ensureSymlinkSync: nc
  };
});

// ../node_modules/jsonfile/utils.js
var Br = d((EC, uc) => {
  function vb(t, { EOL: e = `
`, finalEOL: r = !0, replacer: i = null, spaces: n } = {}) {
    let o = r ? e : "";
    return JSON.stringify(t, i, n).replace(/\n/g, e) + o;
  }
  s(vb, "stringify");
  function _b(t) {
    return Buffer.isBuffer(t) && (t = t.toString("utf8")), t.replace(/^\uFEFF/, "");
  }
  s(_b, "stripBom");
  uc.exports = { stringify: vb, stripBom: _b };
});

// ../node_modules/jsonfile/index.js
var fc = d((RC, hc) => {
  var $t;
  try {
    $t = It();
  } catch {
    $t = A("fs");
  }
  var Wr = ne(), { stringify: cc, stripBom: lc } = Br();
  async function xb(t, e = {}) {
    typeof e == "string" && (e = { encoding: e });
    let r = e.fs || $t, i = "throws" in e ? e.throws : !0, n = await Wr.fromCallback(r.readFile)(t, e);
    n = lc(n);
    let o;
    try {
      o = JSON.parse(n, e ? e.reviver : null);
    } catch (a) {
      if (i)
        throw a.message = `${t}: ${a.message}`, a;
      return null;
    }
    return o;
  }
  s(xb, "_readFile");
  var Eb = Wr.fromPromise(xb);
  function Pb(t, e = {}) {
    typeof e == "string" && (e = { encoding: e });
    let r = e.fs || $t, i = "throws" in e ? e.throws : !0;
    try {
      let n = r.readFileSync(t, e);
      return n = lc(n), JSON.parse(n, e.reviver);
    } catch (n) {
      if (i)
        throw n.message = `${t}: ${n.message}`, n;
      return null;
    }
  }
  s(Pb, "readFileSync");
  async function Rb(t, e, r = {}) {
    let i = r.fs || $t, n = cc(e, r);
    await Wr.fromCallback(i.writeFile)(t, n, r);
  }
  s(Rb, "_writeFile");
  var Ab = Wr.fromPromise(Rb);
  function Ob(t, e, r = {}) {
    let i = r.fs || $t, n = cc(e, r);
    return i.writeFileSync(t, n, r);
  }
  s(Ob, "writeFileSync");
  var Cb = {
    readFile: Eb,
    readFileSync: Pb,
    writeFile: Ab,
    writeFileSync: Ob
  };
  hc.exports = Cb;
});

// ../node_modules/fs-extra/lib/json/jsonfile.js
var pc = d((OC, dc) => {
  "use strict";
  var Gr = fc();
  dc.exports = {
    // jsonfile exports
    readJson: Gr.readFile,
    readJsonSync: Gr.readFileSync,
    writeJson: Gr.writeFile,
    writeJsonSync: Gr.writeFileSync
  };
});

// ../node_modules/fs-extra/lib/output-file/index.js
var Ur = d((CC, yc) => {
  "use strict";
  var Tb = ne().fromPromise, as = de(), mc = A("path"), gc = Ce(), kb = ut().pathExists;
  async function Ib(t, e, r = "utf-8") {
    let i = mc.dirname(t);
    return await kb(i) || await gc.mkdirs(i), as.writeFile(t, e, r);
  }
  s(Ib, "outputFile");
  function Db(t, ...e) {
    let r = mc.dirname(t);
    as.existsSync(r) || gc.mkdirsSync(r), as.writeFileSync(t, ...e);
  }
  s(Db, "outputFileSync");
  yc.exports = {
    outputFile: Tb(Ib),
    outputFileSync: Db
  };
});

// ../node_modules/fs-extra/lib/json/output-json.js
var bc = d((kC, Sc) => {
  "use strict";
  var { stringify: qb } = Br(), { outputFile: $b } = Ur();
  async function Fb(t, e, r = {}) {
    let i = qb(e, r);
    await $b(t, i, r);
  }
  s(Fb, "outputJson");
  Sc.exports = Fb;
});

// ../node_modules/fs-extra/lib/json/output-json-sync.js
var vc = d((DC, wc) => {
  "use strict";
  var { stringify: Nb } = Br(), { outputFileSync: Mb } = Ur();
  function Lb(t, e, r) {
    let i = Nb(e, r);
    Mb(t, i, r);
  }
  s(Lb, "outputJsonSync");
  wc.exports = Lb;
});

// ../node_modules/fs-extra/lib/json/index.js
var xc = d(($C, _c) => {
  "use strict";
  var jb = ne().fromPromise, me = pc();
  me.outputJson = jb(bc());
  me.outputJsonSync = vc();
  me.outputJSON = me.outputJson;
  me.outputJSONSync = me.outputJsonSync;
  me.writeJSON = me.writeJson;
  me.writeJSONSync = me.writeJsonSync;
  me.readJSON = me.readJson;
  me.readJSONSync = me.readJsonSync;
  _c.exports = me;
});

// ../node_modules/fs-extra/lib/move/move.js
var Oc = d((FC, Ac) => {
  "use strict";
  var Hb = de(), Ec = A("path"), { copy: Bb } = Hr(), { remove: Rc } = nr(), { mkdirp: Wb } = Ce(), { pathExists: Gb } = ut(), Pc = xt();
  async function Ub(t, e, r = {}) {
    let i = r.overwrite || r.clobber || !1, { srcStat: n, isChangingCase: o = !1 } = await Pc.checkPaths(t, e, "move", r);
    await Pc.checkParentPaths(t, n, e, "move");
    let a = Ec.dirname(e);
    return Ec.parse(a).root !== a && await Wb(a), Vb(t, e, i, o);
  }
  s(Ub, "move");
  async function Vb(t, e, r, i) {
    if (!i) {
      if (r)
        await Rc(e);
      else if (await Gb(e))
        throw new Error("dest already exists.");
    }
    try {
      await Hb.rename(t, e);
    } catch (n) {
      if (n.code !== "EXDEV")
        throw n;
      await Yb(t, e, r);
    }
  }
  s(Vb, "doRename");
  async function Yb(t, e, r) {
    return await Bb(t, e, {
      overwrite: r,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), Rc(t);
  }
  s(Yb, "moveAcrossDevice");
  Ac.exports = Ub;
});

// ../node_modules/fs-extra/lib/move/move-sync.js
var Dc = d((MC, Ic) => {
  "use strict";
  var Tc = It(), cs = A("path"), Kb = Hr().copySync, kc = nr().removeSync, Xb = Ce().mkdirpSync, Cc = xt();
  function zb(t, e, r) {
    r = r || {};
    let i = r.overwrite || r.clobber || !1, { srcStat: n, isChangingCase: o = !1 } = Cc.checkPathsSync(t, e, "move", r);
    return Cc.checkParentPathsSync(t, n, e, "move"), Jb(e) || Xb(cs.dirname(e)), Qb(t, e, i, o);
  }
  s(zb, "moveSync");
  function Jb(t) {
    let e = cs.dirname(t);
    return cs.parse(e).root === e;
  }
  s(Jb, "isParentRoot");
  function Qb(t, e, r, i) {
    if (i) return us(t, e, r);
    if (r)
      return kc(e), us(t, e, r);
    if (Tc.existsSync(e)) throw new Error("dest already exists.");
    return us(t, e, r);
  }
  s(Qb, "doRename");
  function us(t, e, r) {
    try {
      Tc.renameSync(t, e);
    } catch (i) {
      if (i.code !== "EXDEV") throw i;
      return Zb(t, e, r);
    }
  }
  s(us, "rename");
  function Zb(t, e, r) {
    return Kb(t, e, {
      overwrite: r,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), kc(t);
  }
  s(Zb, "moveAcrossDevice");
  Ic.exports = zb;
});

// ../node_modules/fs-extra/lib/move/index.js
var $c = d((jC, qc) => {
  "use strict";
  var ew = ne().fromPromise;
  qc.exports = {
    move: ew(Oc()),
    moveSync: Dc()
  };
});

// ../node_modules/fs-extra/lib/index.js
var Vr = d((HC, Fc) => {
  "use strict";
  Fc.exports = {
    // Export promiseified graceful-fs:
    ...de(),
    // Export extra methods:
    ...Hr(),
    ...$u(),
    ...ac(),
    ...xc(),
    ...Ce(),
    ...$c(),
    ...Ur(),
    ...ut(),
    ...nr()
  };
});

// ../node_modules/ts-dedent/dist/index.js
var ur = d((ar) => {
  "use strict";
  Object.defineProperty(ar, "__esModule", { value: !0 });
  ar.dedent = void 0;
  function Nc(t) {
    for (var e = [], r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
    var i = Array.from(typeof t == "string" ? [t] : t);
    i[i.length - 1] = i[i.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var n = i.reduce(function(u, c) {
      var h = c.match(/\n([\t ]+|(?!\s).)/g);
      return h ? u.concat(h.map(function(l) {
        var p, f;
        return (f = (p = l.match(/[\t ]/g)) === null || p === void 0 ? void 0 : p.length) !== null && f !== void 0 ? f : 0;
      })) : u;
    }, []);
    if (n.length) {
      var o = new RegExp(`
[	 ]{` + Math.min.apply(Math, n) + "}", "g");
      i = i.map(function(u) {
        return u.replace(o, `
`);
      });
    }
    i[0] = i[0].replace(/^\r?\n/, "");
    var a = i[0];
    return e.forEach(function(u, c) {
      var h = a.match(/(?:^|\n)( *)$/), l = h ? h[1] : "", p = u;
      typeof u == "string" && u.includes(`
`) && (p = String(u).split(`
`).map(function(f, b) {
        return b === 0 ? f : "" + l + f;
      }).join(`
`)), a += p + i[c + 1];
    }), a;
  }
  s(Nc, "dedent");
  ar.dedent = Nc;
  ar.default = Nc;
});

// ../node_modules/camelcase/index.js
var Wc = {};
Wa(Wc, {
  default: () => Bc
});
function Bc(t, e) {
  if (!(typeof t == "string" || Array.isArray(t)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (e = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...e
  }, Array.isArray(t) ? t = t.map((o) => o.trim()).filter((o) => o.length).join("-") : t = t.trim(), t.length === 0)
    return "";
  let r = e.locale === !1 ? (o) => o.toLowerCase() : (o) => o.toLocaleLowerCase(e.locale), i = e.locale === !1 ? (o) => o.toUpperCase() : (o) => o.
  toLocaleUpperCase(e.locale);
  return t.length === 1 ? ls.test(t) ? "" : e.pascalCase ? i(t) : r(t) : (t !== r(t) && (t = sw(t, r, i, e.preserveConsecutiveUppercase)), t =
  t.replace(iw, ""), t = e.preserveConsecutiveUppercase ? nw(t, r) : r(t), e.pascalCase && (t = i(t.charAt(0)) + t.slice(1)), ow(t, i));
}
var tw, rw, Mc, Hc, ls, iw, Lc, jc, sw, nw, ow, Gc = Ye(() => {
  tw = /[\p{Lu}]/u, rw = /[\p{Ll}]/u, Mc = /^[\p{Lu}](?![\p{Lu}])/gu, Hc = /([\p{Alpha}\p{N}_]|$)/u, ls = /[_.\- ]+/, iw = new RegExp("^" + ls.
  source), Lc = new RegExp(ls.source + Hc.source, "gu"), jc = new RegExp("\\d+" + Hc.source, "gu"), sw = /* @__PURE__ */ s((t, e, r, i) => {
    let n = !1, o = !1, a = !1, u = !1;
    for (let c = 0; c < t.length; c++) {
      let h = t[c];
      u = c > 2 ? t[c - 3] === "-" : !0, n && tw.test(h) ? (t = t.slice(0, c) + "-" + t.slice(c), n = !1, a = o, o = !0, c++) : o && a && rw.
      test(h) && (!u || i) ? (t = t.slice(0, c - 1) + "-" + t.slice(c - 1), a = o, o = !1, n = !0) : (n = e(h) === h && r(h) !== h, a = o, o =
      r(h) === h && e(h) !== h);
    }
    return t;
  }, "preserveCamelCase"), nw = /* @__PURE__ */ s((t, e) => (Mc.lastIndex = 0, t.replaceAll(Mc, (r) => e(r))), "preserveConsecutiveUppercase"),
  ow = /* @__PURE__ */ s((t, e) => (Lc.lastIndex = 0, jc.lastIndex = 0, t.replaceAll(jc, (r, i, n) => ["_", "-"].includes(t.charAt(n + r.length)) ?
  r : e(r)).replaceAll(Lc, (r, i) => e(i))), "postProcess");
  s(Bc, "camelCase");
});

// ../node_modules/@sindresorhus/merge-streams/index.js
import { on as gw, once as yw } from "node:events";
import { PassThrough as Sw } from "node:stream";
import { finished as sl } from "node:stream/promises";
function Ss(t) {
  if (!Array.isArray(t))
    throw new TypeError(`Expected an array, got \`${typeof t}\`.`);
  for (let n of t)
    gs(n);
  let e = t.some(({ readableObjectMode: n }) => n), r = bw(t, e), i = new ms({
    objectMode: e,
    writableHighWaterMark: r,
    readableHighWaterMark: r
  });
  for (let n of t)
    i.add(n);
  return t.length === 0 && al(i), i;
}
var bw, ms, ww, vw, _w, gs, xw, nl, Ew, Pw, Rw, ol, al, ys, ul, Aw, zr, rl, il, cl = Ye(() => {
  s(Ss, "mergeStreams");
  bw = /* @__PURE__ */ s((t, e) => {
    if (t.length === 0)
      return 16384;
    let r = t.filter(({ readableObjectMode: i }) => i === e).map(({ readableHighWaterMark: i }) => i);
    return Math.max(...r);
  }, "getHighWaterMark"), ms = class extends Sw {
    static {
      s(this, "MergedStream");
    }
    #e = /* @__PURE__ */ new Set([]);
    #r = /* @__PURE__ */ new Set([]);
    #i = /* @__PURE__ */ new Set([]);
    #t;
    add(e) {
      gs(e), !this.#e.has(e) && (this.#e.add(e), this.#t ??= ww(this, this.#e), xw({
        passThroughStream: this,
        stream: e,
        streams: this.#e,
        ended: this.#r,
        aborted: this.#i,
        onFinished: this.#t
      }), e.pipe(this, { end: !1 }));
    }
    remove(e) {
      return gs(e), this.#e.has(e) ? (e.unpipe(this), !0) : !1;
    }
  }, ww = /* @__PURE__ */ s(async (t, e) => {
    zr(t, rl);
    let r = new AbortController();
    try {
      await Promise.race([
        vw(t, r),
        _w(t, e, r)
      ]);
    } finally {
      r.abort(), zr(t, -rl);
    }
  }, "onMergedStreamFinished"), vw = /* @__PURE__ */ s(async (t, { signal: e }) => {
    await sl(t, { signal: e, cleanup: !0 });
  }, "onMergedStreamEnd"), _w = /* @__PURE__ */ s(async (t, e, { signal: r }) => {
    for await (let [i] of gw(t, "unpipe", { signal: r }))
      e.has(i) && i.emit(ol);
  }, "onInputStreamsUnpipe"), gs = /* @__PURE__ */ s((t) => {
    if (typeof t?.pipe != "function")
      throw new TypeError(`Expected a readable stream, got: \`${typeof t}\`.`);
  }, "validateStream"), xw = /* @__PURE__ */ s(async ({ passThroughStream: t, stream: e, streams: r, ended: i, aborted: n, onFinished: o }) => {
    zr(t, il);
    let a = new AbortController();
    try {
      await Promise.race([
        Ew(o, e),
        Pw({ passThroughStream: t, stream: e, streams: r, ended: i, aborted: n, controller: a }),
        Rw({ stream: e, streams: r, ended: i, aborted: n, controller: a })
      ]);
    } finally {
      a.abort(), zr(t, -il);
    }
    r.size === i.size + n.size && (i.size === 0 && n.size > 0 ? ys(t) : al(t));
  }, "endWhenStreamsDone"), nl = /* @__PURE__ */ s((t) => t?.code === "ERR_STREAM_PREMATURE_CLOSE", "isAbortError"), Ew = /* @__PURE__ */ s(
  async (t, e) => {
    try {
      await t, ys(e);
    } catch (r) {
      nl(r) ? ys(e) : ul(e, r);
    }
  }, "afterMergedStreamFinished"), Pw = /* @__PURE__ */ s(async ({ passThroughStream: t, stream: e, streams: r, ended: i, aborted: n, controller: {
  signal: o } }) => {
    try {
      await sl(e, { signal: o, cleanup: !0, readable: !0, writable: !1 }), r.has(e) && i.add(e);
    } catch (a) {
      if (o.aborted || !r.has(e))
        return;
      nl(a) ? n.add(e) : ul(t, a);
    }
  }, "onInputStreamEnd"), Rw = /* @__PURE__ */ s(async ({ stream: t, streams: e, ended: r, aborted: i, controller: { signal: n } }) => {
    await yw(t, ol, { signal: n }), e.delete(t), r.delete(t), i.delete(t);
  }, "onInputStreamUnpipe"), ol = Symbol("unpipe"), al = /* @__PURE__ */ s((t) => {
    t.writable && t.end();
  }, "endStream"), ys = /* @__PURE__ */ s((t) => {
    (t.readable || t.writable) && t.destroy();
  }, "abortStream"), ul = /* @__PURE__ */ s((t, e) => {
    t.destroyed || (t.once("error", Aw), t.destroy(e));
  }, "errorStream"), Aw = /* @__PURE__ */ s(() => {
  }, "noop"), zr = /* @__PURE__ */ s((t, e) => {
    let r = t.getMaxListeners();
    r !== 0 && r !== Number.POSITIVE_INFINITY && t.setMaxListeners(r + e);
  }, "updateMaxListeners"), rl = 2, il = 1;
});

// ../node_modules/fast-glob/out/utils/array.js
var ll = d((Ft) => {
  "use strict";
  Object.defineProperty(Ft, "__esModule", { value: !0 });
  Ft.splitWhen = Ft.flatten = void 0;
  function Ow(t) {
    return t.reduce((e, r) => [].concat(e, r), []);
  }
  s(Ow, "flatten");
  Ft.flatten = Ow;
  function Cw(t, e) {
    let r = [[]], i = 0;
    for (let n of t)
      e(n) ? (i++, r[i] = []) : r[i].push(n);
    return r;
  }
  s(Cw, "splitWhen");
  Ft.splitWhen = Cw;
});

// ../node_modules/fast-glob/out/utils/errno.js
var hl = d((Jr) => {
  "use strict";
  Object.defineProperty(Jr, "__esModule", { value: !0 });
  Jr.isEnoentCodeError = void 0;
  function Tw(t) {
    return t.code === "ENOENT";
  }
  s(Tw, "isEnoentCodeError");
  Jr.isEnoentCodeError = Tw;
});

// ../node_modules/fast-glob/out/utils/fs.js
var fl = d((Qr) => {
  "use strict";
  Object.defineProperty(Qr, "__esModule", { value: !0 });
  Qr.createDirentFromStats = void 0;
  var bs = class {
    static {
      s(this, "DirentFromStats");
    }
    constructor(e, r) {
      this.name = e, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.
      isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink =
      r.isSymbolicLink.bind(r);
    }
  };
  function kw(t, e) {
    return new bs(t, e);
  }
  s(kw, "createDirentFromStats");
  Qr.createDirentFromStats = kw;
});

// ../node_modules/fast-glob/out/utils/path.js
var gl = d((ie) => {
  "use strict";
  Object.defineProperty(ie, "__esModule", { value: !0 });
  ie.convertPosixPathToPattern = ie.convertWindowsPathToPattern = ie.convertPathToPattern = ie.escapePosixPath = ie.escapeWindowsPath = ie.escape =
  ie.removeLeadingDotSegment = ie.makeAbsolute = ie.unixify = void 0;
  var Iw = A("os"), Dw = A("path"), dl = Iw.platform() === "win32", qw = 2, $w = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g,
  Fw = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, Nw = /^\\\\([.?])/, Mw = /\\(?![!()+@[\]{}])/g;
  function Lw(t) {
    return t.replace(/\\/g, "/");
  }
  s(Lw, "unixify");
  ie.unixify = Lw;
  function jw(t, e) {
    return Dw.resolve(t, e);
  }
  s(jw, "makeAbsolute");
  ie.makeAbsolute = jw;
  function Hw(t) {
    if (t.charAt(0) === ".") {
      let e = t.charAt(1);
      if (e === "/" || e === "\\")
        return t.slice(qw);
    }
    return t;
  }
  s(Hw, "removeLeadingDotSegment");
  ie.removeLeadingDotSegment = Hw;
  ie.escape = dl ? ws : vs;
  function ws(t) {
    return t.replace(Fw, "\\$2");
  }
  s(ws, "escapeWindowsPath");
  ie.escapeWindowsPath = ws;
  function vs(t) {
    return t.replace($w, "\\$2");
  }
  s(vs, "escapePosixPath");
  ie.escapePosixPath = vs;
  ie.convertPathToPattern = dl ? pl : ml;
  function pl(t) {
    return ws(t).replace(Nw, "//$1").replace(Mw, "/");
  }
  s(pl, "convertWindowsPathToPattern");
  ie.convertWindowsPathToPattern = pl;
  function ml(t) {
    return vs(t);
  }
  s(ml, "convertPosixPathToPattern");
  ie.convertPosixPathToPattern = ml;
});

// ../node_modules/is-extglob/index.js
var Sl = d((qT, yl) => {
  yl.exports = /* @__PURE__ */ s(function(e) {
    if (typeof e != "string" || e === "")
      return !1;
    for (var r; r = /(\\).|([@?!+*]\(.*\))/g.exec(e); ) {
      if (r[2]) return !0;
      e = e.slice(r.index + r[0].length);
    }
    return !1;
  }, "isExtglob");
});

// ../node_modules/is-glob/index.js
var vl = d((FT, wl) => {
  var Bw = Sl(), bl = { "{": "}", "(": ")", "[": "]" }, Ww = /* @__PURE__ */ s(function(t) {
    if (t[0] === "!")
      return !0;
    for (var e = 0, r = -2, i = -2, n = -2, o = -2, a = -2; e < t.length; ) {
      if (t[e] === "*" || t[e + 1] === "?" && /[\].+)]/.test(t[e]) || i !== -1 && t[e] === "[" && t[e + 1] !== "]" && (i < e && (i = t.indexOf(
      "]", e)), i > e && (a === -1 || a > i || (a = t.indexOf("\\", e), a === -1 || a > i))) || n !== -1 && t[e] === "{" && t[e + 1] !== "}" &&
      (n = t.indexOf("}", e), n > e && (a = t.indexOf("\\", e), a === -1 || a > n)) || o !== -1 && t[e] === "(" && t[e + 1] === "?" && /[:!=]/.
      test(t[e + 2]) && t[e + 3] !== ")" && (o = t.indexOf(")", e), o > e && (a = t.indexOf("\\", e), a === -1 || a > o)) || r !== -1 && t[e] ===
      "(" && t[e + 1] !== "|" && (r < e && (r = t.indexOf("|", e)), r !== -1 && t[r + 1] !== ")" && (o = t.indexOf(")", r), o > r && (a = t.
      indexOf("\\", r), a === -1 || a > o))))
        return !0;
      if (t[e] === "\\") {
        var u = t[e + 1];
        e += 2;
        var c = bl[u];
        if (c) {
          var h = t.indexOf(c, e);
          h !== -1 && (e = h + 1);
        }
        if (t[e] === "!")
          return !0;
      } else
        e++;
    }
    return !1;
  }, "strictCheck"), Gw = /* @__PURE__ */ s(function(t) {
    if (t[0] === "!")
      return !0;
    for (var e = 0; e < t.length; ) {
      if (/[*?{}()[\]]/.test(t[e]))
        return !0;
      if (t[e] === "\\") {
        var r = t[e + 1];
        e += 2;
        var i = bl[r];
        if (i) {
          var n = t.indexOf(i, e);
          n !== -1 && (e = n + 1);
        }
        if (t[e] === "!")
          return !0;
      } else
        e++;
    }
    return !1;
  }, "relaxedCheck");
  wl.exports = /* @__PURE__ */ s(function(e, r) {
    if (typeof e != "string" || e === "")
      return !1;
    if (Bw(e))
      return !0;
    var i = Ww;
    return r && r.strict === !1 && (i = Gw), i(e);
  }, "isGlob");
});

// ../node_modules/glob-parent/index.js
var xl = d((MT, _l) => {
  "use strict";
  var Uw = vl(), Vw = A("path").posix.dirname, Yw = A("os").platform() === "win32", _s = "/", Kw = /\\/g, Xw = /[\{\[].*[\}\]]$/, zw = /(^|[^\\])([\{\[]|\([^\)]+$)/,
  Jw = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  _l.exports = /* @__PURE__ */ s(function(e, r) {
    var i = Object.assign({ flipBackslashes: !0 }, r);
    i.flipBackslashes && Yw && e.indexOf(_s) < 0 && (e = e.replace(Kw, _s)), Xw.test(e) && (e += _s), e += "a";
    do
      e = Vw(e);
    while (Uw(e) || zw.test(e));
    return e.replace(Jw, "$1");
  }, "globParent");
});

// ../node_modules/braces/lib/utils.js
var Zr = d((_e) => {
  "use strict";
  _e.isInteger = (t) => typeof t == "number" ? Number.isInteger(t) : typeof t == "string" && t.trim() !== "" ? Number.isInteger(Number(t)) :
  !1;
  _e.find = (t, e) => t.nodes.find((r) => r.type === e);
  _e.exceedsLimit = (t, e, r = 1, i) => i === !1 || !_e.isInteger(t) || !_e.isInteger(e) ? !1 : (Number(e) - Number(t)) / Number(r) >= i;
  _e.escapeNode = (t, e = 0, r) => {
    let i = t.nodes[e];
    i && (r && i.type === r || i.type === "open" || i.type === "close") && i.escaped !== !0 && (i.value = "\\" + i.value, i.escaped = !0);
  };
  _e.encloseBrace = (t) => t.type !== "brace" || t.commas >> 0 + t.ranges >> 0 ? !1 : (t.invalid = !0, !0);
  _e.isInvalidBrace = (t) => t.type !== "brace" ? !1 : t.invalid === !0 || t.dollar ? !0 : !(t.commas >> 0 + t.ranges >> 0) || t.open !== !0 ||
  t.close !== !0 ? (t.invalid = !0, !0) : !1;
  _e.isOpenOrClose = (t) => t.type === "open" || t.type === "close" ? !0 : t.open === !0 || t.close === !0;
  _e.reduce = (t) => t.reduce((e, r) => (r.type === "text" && e.push(r.value), r.type === "range" && (r.type = "text"), e), []);
  _e.flatten = (...t) => {
    let e = [], r = /* @__PURE__ */ s((i) => {
      for (let n = 0; n < i.length; n++) {
        let o = i[n];
        if (Array.isArray(o)) {
          r(o);
          continue;
        }
        o !== void 0 && e.push(o);
      }
      return e;
    }, "flat");
    return r(t), e;
  };
});

// ../node_modules/braces/lib/stringify.js
var ei = d((BT, Pl) => {
  "use strict";
  var El = Zr();
  Pl.exports = (t, e = {}) => {
    let r = /* @__PURE__ */ s((i, n = {}) => {
      let o = e.escapeInvalid && El.isInvalidBrace(n), a = i.invalid === !0 && e.escapeInvalid === !0, u = "";
      if (i.value)
        return (o || a) && El.isOpenOrClose(i) ? "\\" + i.value : i.value;
      if (i.value)
        return i.value;
      if (i.nodes)
        for (let c of i.nodes)
          u += r(c);
      return u;
    }, "stringify");
    return r(t);
  };
});

// ../node_modules/to-regex-range/node_modules/is-number/index.js
var Al = d((GT, Rl) => {
  "use strict";
  Rl.exports = function(t) {
    return typeof t == "number" ? t - t === 0 : typeof t == "string" && t.trim() !== "" ? Number.isFinite ? Number.isFinite(+t) : isFinite(+t) :
    !1;
  };
});

// ../node_modules/to-regex-range/index.js
var Fl = d((UT, $l) => {
  "use strict";
  var Ol = Al(), Pt = /* @__PURE__ */ s((t, e, r) => {
    if (Ol(t) === !1)
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    if (e === void 0 || t === e)
      return String(t);
    if (Ol(e) === !1)
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    let i = { relaxZeros: !0, ...r };
    typeof i.strictZeros == "boolean" && (i.relaxZeros = i.strictZeros === !1);
    let n = String(i.relaxZeros), o = String(i.shorthand), a = String(i.capture), u = String(i.wrap), c = t + ":" + e + "=" + n + o + a + u;
    if (Pt.cache.hasOwnProperty(c))
      return Pt.cache[c].result;
    let h = Math.min(t, e), l = Math.max(t, e);
    if (Math.abs(h - l) === 1) {
      let w = t + "|" + e;
      return i.capture ? `(${w})` : i.wrap === !1 ? w : `(?:${w})`;
    }
    let p = ql(t) || ql(e), f = { min: t, max: e, a: h, b: l }, b = [], m = [];
    if (p && (f.isPadded = p, f.maxLen = String(f.max).length), h < 0) {
      let w = l < 0 ? Math.abs(l) : 1;
      m = Cl(w, Math.abs(h), f, i), h = f.a = 0;
    }
    return l >= 0 && (b = Cl(h, l, f, i)), f.negatives = m, f.positives = b, f.result = Qw(m, b, i), i.capture === !0 ? f.result = `(${f.result}\
)` : i.wrap !== !1 && b.length + m.length > 1 && (f.result = `(?:${f.result})`), Pt.cache[c] = f, f.result;
  }, "toRegexRange");
  function Qw(t, e, r) {
    let i = xs(t, e, "-", !1, r) || [], n = xs(e, t, "", !1, r) || [], o = xs(t, e, "-?", !0, r) || [];
    return i.concat(o).concat(n).join("|");
  }
  s(Qw, "collatePatterns");
  function Zw(t, e) {
    let r = 1, i = 1, n = kl(t, r), o = /* @__PURE__ */ new Set([e]);
    for (; t <= n && n <= e; )
      o.add(n), r += 1, n = kl(t, r);
    for (n = Il(e + 1, i) - 1; t < n && n <= e; )
      o.add(n), i += 1, n = Il(e + 1, i) - 1;
    return o = [...o], o.sort(rv), o;
  }
  s(Zw, "splitToRanges");
  function ev(t, e, r) {
    if (t === e)
      return { pattern: t, count: [], digits: 0 };
    let i = tv(t, e), n = i.length, o = "", a = 0;
    for (let u = 0; u < n; u++) {
      let [c, h] = i[u];
      c === h ? o += c : c !== "0" || h !== "9" ? o += iv(c, h, r) : a++;
    }
    return a && (o += r.shorthand === !0 ? "\\d" : "[0-9]"), { pattern: o, count: [a], digits: n };
  }
  s(ev, "rangeToPattern");
  function Cl(t, e, r, i) {
    let n = Zw(t, e), o = [], a = t, u;
    for (let c = 0; c < n.length; c++) {
      let h = n[c], l = ev(String(a), String(h), i), p = "";
      if (!r.isPadded && u && u.pattern === l.pattern) {
        u.count.length > 1 && u.count.pop(), u.count.push(l.count[0]), u.string = u.pattern + Dl(u.count), a = h + 1;
        continue;
      }
      r.isPadded && (p = sv(h, r, i)), l.string = p + l.pattern + Dl(l.count), o.push(l), a = h + 1, u = l;
    }
    return o;
  }
  s(Cl, "splitToPatterns");
  function xs(t, e, r, i, n) {
    let o = [];
    for (let a of t) {
      let { string: u } = a;
      !i && !Tl(e, "string", u) && o.push(r + u), i && Tl(e, "string", u) && o.push(r + u);
    }
    return o;
  }
  s(xs, "filterPatterns");
  function tv(t, e) {
    let r = [];
    for (let i = 0; i < t.length; i++) r.push([t[i], e[i]]);
    return r;
  }
  s(tv, "zip");
  function rv(t, e) {
    return t > e ? 1 : e > t ? -1 : 0;
  }
  s(rv, "compare");
  function Tl(t, e, r) {
    return t.some((i) => i[e] === r);
  }
  s(Tl, "contains");
  function kl(t, e) {
    return Number(String(t).slice(0, -e) + "9".repeat(e));
  }
  s(kl, "countNines");
  function Il(t, e) {
    return t - t % Math.pow(10, e);
  }
  s(Il, "countZeros");
  function Dl(t) {
    let [e = 0, r = ""] = t;
    return r || e > 1 ? `{${e + (r ? "," + r : "")}}` : "";
  }
  s(Dl, "toQuantifier");
  function iv(t, e, r) {
    return `[${t}${e - t === 1 ? "" : "-"}${e}]`;
  }
  s(iv, "toCharacterClass");
  function ql(t) {
    return /^-?(0+)\d/.test(t);
  }
  s(ql, "hasPadding");
  function sv(t, e, r) {
    if (!e.isPadded)
      return t;
    let i = Math.abs(e.maxLen - String(t).length), n = r.relaxZeros !== !1;
    switch (i) {
      case 0:
        return "";
      case 1:
        return n ? "0?" : "0";
      case 2:
        return n ? "0{0,2}" : "00";
      default:
        return n ? `0{0,${i}}` : `0{${i}}`;
    }
  }
  s(sv, "padZeros");
  Pt.cache = {};
  Pt.clearCache = () => Pt.cache = {};
  $l.exports = Pt;
});

// ../node_modules/fill-range/index.js
var Rs = d((YT, Wl) => {
  "use strict";
  var nv = A("util"), Ml = Fl(), Nl = /* @__PURE__ */ s((t) => t !== null && typeof t == "object" && !Array.isArray(t), "isObject"), ov = /* @__PURE__ */ s(
  (t) => (e) => t === !0 ? Number(e) : String(e), "transform"), Es = /* @__PURE__ */ s((t) => typeof t == "number" || typeof t == "string" &&
  t !== "", "isValidValue"), cr = /* @__PURE__ */ s((t) => Number.isInteger(+t), "isNumber"), Ps = /* @__PURE__ */ s((t) => {
    let e = `${t}`, r = -1;
    if (e[0] === "-" && (e = e.slice(1)), e === "0") return !1;
    for (; e[++r] === "0"; ) ;
    return r > 0;
  }, "zeros"), av = /* @__PURE__ */ s((t, e, r) => typeof t == "string" || typeof e == "string" ? !0 : r.stringify === !0, "stringify"), uv = /* @__PURE__ */ s(
  (t, e, r) => {
    if (e > 0) {
      let i = t[0] === "-" ? "-" : "";
      i && (t = t.slice(1)), t = i + t.padStart(i ? e - 1 : e, "0");
    }
    return r === !1 ? String(t) : t;
  }, "pad"), ri = /* @__PURE__ */ s((t, e) => {
    let r = t[0] === "-" ? "-" : "";
    for (r && (t = t.slice(1), e--); t.length < e; ) t = "0" + t;
    return r ? "-" + t : t;
  }, "toMaxLen"), cv = /* @__PURE__ */ s((t, e, r) => {
    t.negatives.sort((u, c) => u < c ? -1 : u > c ? 1 : 0), t.positives.sort((u, c) => u < c ? -1 : u > c ? 1 : 0);
    let i = e.capture ? "" : "?:", n = "", o = "", a;
    return t.positives.length && (n = t.positives.map((u) => ri(String(u), r)).join("|")), t.negatives.length && (o = `-(${i}${t.negatives.map(
    (u) => ri(String(u), r)).join("|")})`), n && o ? a = `${n}|${o}` : a = n || o, e.wrap ? `(${i}${a})` : a;
  }, "toSequence"), Ll = /* @__PURE__ */ s((t, e, r, i) => {
    if (r)
      return Ml(t, e, { wrap: !1, ...i });
    let n = String.fromCharCode(t);
    if (t === e) return n;
    let o = String.fromCharCode(e);
    return `[${n}-${o}]`;
  }, "toRange"), jl = /* @__PURE__ */ s((t, e, r) => {
    if (Array.isArray(t)) {
      let i = r.wrap === !0, n = r.capture ? "" : "?:";
      return i ? `(${n}${t.join("|")})` : t.join("|");
    }
    return Ml(t, e, r);
  }, "toRegex"), Hl = /* @__PURE__ */ s((...t) => new RangeError("Invalid range arguments: " + nv.inspect(...t)), "rangeError"), Bl = /* @__PURE__ */ s(
  (t, e, r) => {
    if (r.strictRanges === !0) throw Hl([t, e]);
    return [];
  }, "invalidRange"), lv = /* @__PURE__ */ s((t, e) => {
    if (e.strictRanges === !0)
      throw new TypeError(`Expected step "${t}" to be a number`);
    return [];
  }, "invalidStep"), hv = /* @__PURE__ */ s((t, e, r = 1, i = {}) => {
    let n = Number(t), o = Number(e);
    if (!Number.isInteger(n) || !Number.isInteger(o)) {
      if (i.strictRanges === !0) throw Hl([t, e]);
      return [];
    }
    n === 0 && (n = 0), o === 0 && (o = 0);
    let a = n > o, u = String(t), c = String(e), h = String(r);
    r = Math.max(Math.abs(r), 1);
    let l = Ps(u) || Ps(c) || Ps(h), p = l ? Math.max(u.length, c.length, h.length) : 0, f = l === !1 && av(t, e, i) === !1, b = i.transform ||
    ov(f);
    if (i.toRegex && r === 1)
      return Ll(ri(t, p), ri(e, p), !0, i);
    let m = { negatives: [], positives: [] }, w = /* @__PURE__ */ s((q) => m[q < 0 ? "negatives" : "positives"].push(Math.abs(q)), "push"), _ = [],
    P = 0;
    for (; a ? n >= o : n <= o; )
      i.toRegex === !0 && r > 1 ? w(n) : _.push(uv(b(n, P), p, f)), n = a ? n - r : n + r, P++;
    return i.toRegex === !0 ? r > 1 ? cv(m, i, p) : jl(_, null, { wrap: !1, ...i }) : _;
  }, "fillNumbers"), fv = /* @__PURE__ */ s((t, e, r = 1, i = {}) => {
    if (!cr(t) && t.length > 1 || !cr(e) && e.length > 1)
      return Bl(t, e, i);
    let n = i.transform || ((f) => String.fromCharCode(f)), o = `${t}`.charCodeAt(0), a = `${e}`.charCodeAt(0), u = o > a, c = Math.min(o, a),
    h = Math.max(o, a);
    if (i.toRegex && r === 1)
      return Ll(c, h, !1, i);
    let l = [], p = 0;
    for (; u ? o >= a : o <= a; )
      l.push(n(o, p)), o = u ? o - r : o + r, p++;
    return i.toRegex === !0 ? jl(l, null, { wrap: !1, options: i }) : l;
  }, "fillLetters"), ti = /* @__PURE__ */ s((t, e, r, i = {}) => {
    if (e == null && Es(t))
      return [t];
    if (!Es(t) || !Es(e))
      return Bl(t, e, i);
    if (typeof r == "function")
      return ti(t, e, 1, { transform: r });
    if (Nl(r))
      return ti(t, e, 0, r);
    let n = { ...i };
    return n.capture === !0 && (n.wrap = !0), r = r || n.step || 1, cr(r) ? cr(t) && cr(e) ? hv(t, e, r, n) : fv(t, e, Math.max(Math.abs(r),
    1), n) : r != null && !Nl(r) ? lv(r, n) : ti(t, e, 1, r);
  }, "fill");
  Wl.exports = ti;
});

// ../node_modules/braces/lib/compile.js
var Vl = d((XT, Ul) => {
  "use strict";
  var dv = Rs(), Gl = Zr(), pv = /* @__PURE__ */ s((t, e = {}) => {
    let r = /* @__PURE__ */ s((i, n = {}) => {
      let o = Gl.isInvalidBrace(n), a = i.invalid === !0 && e.escapeInvalid === !0, u = o === !0 || a === !0, c = e.escapeInvalid === !0 ? "\
\\" : "", h = "";
      if (i.isOpen === !0)
        return c + i.value;
      if (i.isClose === !0)
        return console.log("node.isClose", c, i.value), c + i.value;
      if (i.type === "open")
        return u ? c + i.value : "(";
      if (i.type === "close")
        return u ? c + i.value : ")";
      if (i.type === "comma")
        return i.prev.type === "comma" ? "" : u ? i.value : "|";
      if (i.value)
        return i.value;
      if (i.nodes && i.ranges > 0) {
        let l = Gl.reduce(i.nodes), p = dv(...l, { ...e, wrap: !1, toRegex: !0, strictZeros: !0 });
        if (p.length !== 0)
          return l.length > 1 && p.length > 1 ? `(${p})` : p;
      }
      if (i.nodes)
        for (let l of i.nodes)
          h += r(l, i);
      return h;
    }, "walk");
    return r(t);
  }, "compile");
  Ul.exports = pv;
});

// ../node_modules/braces/lib/expand.js
var Xl = d((JT, Kl) => {
  "use strict";
  var mv = Rs(), Yl = ei(), Nt = Zr(), Rt = /* @__PURE__ */ s((t = "", e = "", r = !1) => {
    let i = [];
    if (t = [].concat(t), e = [].concat(e), !e.length) return t;
    if (!t.length)
      return r ? Nt.flatten(e).map((n) => `{${n}}`) : e;
    for (let n of t)
      if (Array.isArray(n))
        for (let o of n)
          i.push(Rt(o, e, r));
      else
        for (let o of e)
          r === !0 && typeof o == "string" && (o = `{${o}}`), i.push(Array.isArray(o) ? Rt(n, o, r) : n + o);
    return Nt.flatten(i);
  }, "append"), gv = /* @__PURE__ */ s((t, e = {}) => {
    let r = e.rangeLimit === void 0 ? 1e3 : e.rangeLimit, i = /* @__PURE__ */ s((n, o = {}) => {
      n.queue = [];
      let a = o, u = o.queue;
      for (; a.type !== "brace" && a.type !== "root" && a.parent; )
        a = a.parent, u = a.queue;
      if (n.invalid || n.dollar) {
        u.push(Rt(u.pop(), Yl(n, e)));
        return;
      }
      if (n.type === "brace" && n.invalid !== !0 && n.nodes.length === 2) {
        u.push(Rt(u.pop(), ["{}"]));
        return;
      }
      if (n.nodes && n.ranges > 0) {
        let p = Nt.reduce(n.nodes);
        if (Nt.exceedsLimit(...p, e.step, r))
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        let f = mv(...p, e);
        f.length === 0 && (f = Yl(n, e)), u.push(Rt(u.pop(), f)), n.nodes = [];
        return;
      }
      let c = Nt.encloseBrace(n), h = n.queue, l = n;
      for (; l.type !== "brace" && l.type !== "root" && l.parent; )
        l = l.parent, h = l.queue;
      for (let p = 0; p < n.nodes.length; p++) {
        let f = n.nodes[p];
        if (f.type === "comma" && n.type === "brace") {
          p === 1 && h.push(""), h.push("");
          continue;
        }
        if (f.type === "close") {
          u.push(Rt(u.pop(), h, c));
          continue;
        }
        if (f.value && f.type !== "open") {
          h.push(Rt(h.pop(), f.value));
          continue;
        }
        f.nodes && i(f, n);
      }
      return h;
    }, "walk");
    return Nt.flatten(i(t));
  }, "expand");
  Kl.exports = gv;
});

// ../node_modules/braces/lib/constants.js
var Jl = d((ZT, zl) => {
  "use strict";
  zl.exports = {
    MAX_LENGTH: 1e4,
    // Digits
    CHAR_0: "0",
    /* 0 */
    CHAR_9: "9",
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: "A",
    /* A */
    CHAR_LOWERCASE_A: "a",
    /* a */
    CHAR_UPPERCASE_Z: "Z",
    /* Z */
    CHAR_LOWERCASE_Z: "z",
    /* z */
    CHAR_LEFT_PARENTHESES: "(",
    /* ( */
    CHAR_RIGHT_PARENTHESES: ")",
    /* ) */
    CHAR_ASTERISK: "*",
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: "&",
    /* & */
    CHAR_AT: "@",
    /* @ */
    CHAR_BACKSLASH: "\\",
    /* \ */
    CHAR_BACKTICK: "`",
    /* ` */
    CHAR_CARRIAGE_RETURN: "\r",
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: "^",
    /* ^ */
    CHAR_COLON: ":",
    /* : */
    CHAR_COMMA: ",",
    /* , */
    CHAR_DOLLAR: "$",
    /* . */
    CHAR_DOT: ".",
    /* . */
    CHAR_DOUBLE_QUOTE: '"',
    /* " */
    CHAR_EQUAL: "=",
    /* = */
    CHAR_EXCLAMATION_MARK: "!",
    /* ! */
    CHAR_FORM_FEED: "\f",
    /* \f */
    CHAR_FORWARD_SLASH: "/",
    /* / */
    CHAR_HASH: "#",
    /* # */
    CHAR_HYPHEN_MINUS: "-",
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: "<",
    /* < */
    CHAR_LEFT_CURLY_BRACE: "{",
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: "[",
    /* [ */
    CHAR_LINE_FEED: `
`,
    /* \n */
    CHAR_NO_BREAK_SPACE: "\xA0",
    /* \u00A0 */
    CHAR_PERCENT: "%",
    /* % */
    CHAR_PLUS: "+",
    /* + */
    CHAR_QUESTION_MARK: "?",
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    /* > */
    CHAR_RIGHT_CURLY_BRACE: "}",
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    /* ] */
    CHAR_SEMICOLON: ";",
    /* ; */
    CHAR_SINGLE_QUOTE: "'",
    /* ' */
    CHAR_SPACE: " ",
    /*   */
    CHAR_TAB: "	",
    /* \t */
    CHAR_UNDERSCORE: "_",
    /* _ */
    CHAR_VERTICAL_LINE: "|",
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    /* \uFEFF */
  };
});

// ../node_modules/braces/lib/parse.js
var rh = d((e1, th) => {
  "use strict";
  var yv = ei(), {
    MAX_LENGTH: Ql,
    CHAR_BACKSLASH: As,
    /* \ */
    CHAR_BACKTICK: Sv,
    /* ` */
    CHAR_COMMA: bv,
    /* , */
    CHAR_DOT: wv,
    /* . */
    CHAR_LEFT_PARENTHESES: vv,
    /* ( */
    CHAR_RIGHT_PARENTHESES: _v,
    /* ) */
    CHAR_LEFT_CURLY_BRACE: xv,
    /* { */
    CHAR_RIGHT_CURLY_BRACE: Ev,
    /* } */
    CHAR_LEFT_SQUARE_BRACKET: Zl,
    /* [ */
    CHAR_RIGHT_SQUARE_BRACKET: eh,
    /* ] */
    CHAR_DOUBLE_QUOTE: Pv,
    /* " */
    CHAR_SINGLE_QUOTE: Rv,
    /* ' */
    CHAR_NO_BREAK_SPACE: Av,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: Ov
  } = Jl(), Cv = /* @__PURE__ */ s((t, e = {}) => {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    let r = e || {}, i = typeof r.maxLength == "number" ? Math.min(Ql, r.maxLength) : Ql;
    if (t.length > i)
      throw new SyntaxError(`Input length (${t.length}), exceeds max characters (${i})`);
    let n = { type: "root", input: t, nodes: [] }, o = [n], a = n, u = n, c = 0, h = t.length, l = 0, p = 0, f, b = /* @__PURE__ */ s(() => t[l++],
    "advance"), m = /* @__PURE__ */ s((w) => {
      if (w.type === "text" && u.type === "dot" && (u.type = "text"), u && u.type === "text" && w.type === "text") {
        u.value += w.value;
        return;
      }
      return a.nodes.push(w), w.parent = a, w.prev = u, u = w, w;
    }, "push");
    for (m({ type: "bos" }); l < h; )
      if (a = o[o.length - 1], f = b(), !(f === Ov || f === Av)) {
        if (f === As) {
          m({ type: "text", value: (e.keepEscaping ? f : "") + b() });
          continue;
        }
        if (f === eh) {
          m({ type: "text", value: "\\" + f });
          continue;
        }
        if (f === Zl) {
          c++;
          let w;
          for (; l < h && (w = b()); ) {
            if (f += w, w === Zl) {
              c++;
              continue;
            }
            if (w === As) {
              f += b();
              continue;
            }
            if (w === eh && (c--, c === 0))
              break;
          }
          m({ type: "text", value: f });
          continue;
        }
        if (f === vv) {
          a = m({ type: "paren", nodes: [] }), o.push(a), m({ type: "text", value: f });
          continue;
        }
        if (f === _v) {
          if (a.type !== "paren") {
            m({ type: "text", value: f });
            continue;
          }
          a = o.pop(), m({ type: "text", value: f }), a = o[o.length - 1];
          continue;
        }
        if (f === Pv || f === Rv || f === Sv) {
          let w = f, _;
          for (e.keepQuotes !== !0 && (f = ""); l < h && (_ = b()); ) {
            if (_ === As) {
              f += _ + b();
              continue;
            }
            if (_ === w) {
              e.keepQuotes === !0 && (f += _);
              break;
            }
            f += _;
          }
          m({ type: "text", value: f });
          continue;
        }
        if (f === xv) {
          p++;
          let _ = {
            type: "brace",
            open: !0,
            close: !1,
            dollar: u.value && u.value.slice(-1) === "$" || a.dollar === !0,
            depth: p,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          a = m(_), o.push(a), m({ type: "open", value: f });
          continue;
        }
        if (f === Ev) {
          if (a.type !== "brace") {
            m({ type: "text", value: f });
            continue;
          }
          let w = "close";
          a = o.pop(), a.close = !0, m({ type: w, value: f }), p--, a = o[o.length - 1];
          continue;
        }
        if (f === bv && p > 0) {
          if (a.ranges > 0) {
            a.ranges = 0;
            let w = a.nodes.shift();
            a.nodes = [w, { type: "text", value: yv(a) }];
          }
          m({ type: "comma", value: f }), a.commas++;
          continue;
        }
        if (f === wv && p > 0 && a.commas === 0) {
          let w = a.nodes;
          if (p === 0 || w.length === 0) {
            m({ type: "text", value: f });
            continue;
          }
          if (u.type === "dot") {
            if (a.range = [], u.value += f, u.type = "range", a.nodes.length !== 3 && a.nodes.length !== 5) {
              a.invalid = !0, a.ranges = 0, u.type = "text";
              continue;
            }
            a.ranges++, a.args = [];
            continue;
          }
          if (u.type === "range") {
            w.pop();
            let _ = w[w.length - 1];
            _.value += u.value + f, u = _, a.ranges--;
            continue;
          }
          m({ type: "dot", value: f });
          continue;
        }
        m({ type: "text", value: f });
      }
    do
      if (a = o.pop(), a.type !== "root") {
        a.nodes.forEach((P) => {
          P.nodes || (P.type === "open" && (P.isOpen = !0), P.type === "close" && (P.isClose = !0), P.nodes || (P.type = "text"), P.invalid =
          !0);
        });
        let w = o[o.length - 1], _ = w.nodes.indexOf(a);
        w.nodes.splice(_, 1, ...a.nodes);
      }
    while (o.length > 0);
    return m({ type: "eos" }), n;
  }, "parse");
  th.exports = Cv;
});

// ../node_modules/braces/index.js
var nh = d((r1, sh) => {
  "use strict";
  var ih = ei(), Tv = Vl(), kv = Xl(), Iv = rh(), we = /* @__PURE__ */ s((t, e = {}) => {
    let r = [];
    if (Array.isArray(t))
      for (let i of t) {
        let n = we.create(i, e);
        Array.isArray(n) ? r.push(...n) : r.push(n);
      }
    else
      r = [].concat(we.create(t, e));
    return e && e.expand === !0 && e.nodupes === !0 && (r = [...new Set(r)]), r;
  }, "braces");
  we.parse = (t, e = {}) => Iv(t, e);
  we.stringify = (t, e = {}) => ih(typeof t == "string" ? we.parse(t, e) : t, e);
  we.compile = (t, e = {}) => (typeof t == "string" && (t = we.parse(t, e)), Tv(t, e));
  we.expand = (t, e = {}) => {
    typeof t == "string" && (t = we.parse(t, e));
    let r = kv(t, e);
    return e.noempty === !0 && (r = r.filter(Boolean)), e.nodupes === !0 && (r = [...new Set(r)]), r;
  };
  we.create = (t, e = {}) => t === "" || t.length < 3 ? [t] : e.expand !== !0 ? we.compile(t, e) : we.expand(t, e);
  sh.exports = we;
});

// ../node_modules/picomatch/lib/constants.js
var lr = d((s1, lh) => {
  "use strict";
  var Dv = A("path"), Ne = "\\\\/", oh = `[^${Ne}]`, ze = "\\.", qv = "\\+", $v = "\\?", ii = "\\/", Fv = "(?=.)", ah = "[^/]", Os = `(?:${ii}\
|$)`, uh = `(?:^|${ii})`, Cs = `${ze}{1,2}${Os}`, Nv = `(?!${ze})`, Mv = `(?!${uh}${Cs})`, Lv = `(?!${ze}{0,1}${Os})`, jv = `(?!${Cs})`, Hv = `\
[^.${ii}]`, Bv = `${ah}*?`, ch = {
    DOT_LITERAL: ze,
    PLUS_LITERAL: qv,
    QMARK_LITERAL: $v,
    SLASH_LITERAL: ii,
    ONE_CHAR: Fv,
    QMARK: ah,
    END_ANCHOR: Os,
    DOTS_SLASH: Cs,
    NO_DOT: Nv,
    NO_DOTS: Mv,
    NO_DOT_SLASH: Lv,
    NO_DOTS_SLASH: jv,
    QMARK_NO_DOT: Hv,
    STAR: Bv,
    START_ANCHOR: uh
  }, Wv = {
    ...ch,
    SLASH_LITERAL: `[${Ne}]`,
    QMARK: oh,
    STAR: `${oh}*?`,
    DOTS_SLASH: `${ze}{1,2}(?:[${Ne}]|$)`,
    NO_DOT: `(?!${ze})`,
    NO_DOTS: `(?!(?:^|[${Ne}])${ze}{1,2}(?:[${Ne}]|$))`,
    NO_DOT_SLASH: `(?!${ze}{0,1}(?:[${Ne}]|$))`,
    NO_DOTS_SLASH: `(?!${ze}{1,2}(?:[${Ne}]|$))`,
    QMARK_NO_DOT: `[^.${Ne}]`,
    START_ANCHOR: `(?:^|[${Ne}])`,
    END_ANCHOR: `(?:[${Ne}]|$)`
  }, Gv = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  lh.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: Gv,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    SEP: Dv.sep,
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(t) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${t.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(t) {
      return t === !0 ? Wv : ch;
    }
  };
});

// ../node_modules/picomatch/lib/utils.js
var hr = d((ge) => {
  "use strict";
  var Uv = A("path"), Vv = process.platform === "win32", {
    REGEX_BACKSLASH: Yv,
    REGEX_REMOVE_BACKSLASH: Kv,
    REGEX_SPECIAL_CHARS: Xv,
    REGEX_SPECIAL_CHARS_GLOBAL: zv
  } = lr();
  ge.isObject = (t) => t !== null && typeof t == "object" && !Array.isArray(t);
  ge.hasRegexChars = (t) => Xv.test(t);
  ge.isRegexChar = (t) => t.length === 1 && ge.hasRegexChars(t);
  ge.escapeRegex = (t) => t.replace(zv, "\\$1");
  ge.toPosixSlashes = (t) => t.replace(Yv, "/");
  ge.removeBackslashes = (t) => t.replace(Kv, (e) => e === "\\" ? "" : e);
  ge.supportsLookbehinds = () => {
    let t = process.version.slice(1).split(".").map(Number);
    return t.length === 3 && t[0] >= 9 || t[0] === 8 && t[1] >= 10;
  };
  ge.isWindows = (t) => t && typeof t.windows == "boolean" ? t.windows : Vv === !0 || Uv.sep === "\\";
  ge.escapeLast = (t, e, r) => {
    let i = t.lastIndexOf(e, r);
    return i === -1 ? t : t[i - 1] === "\\" ? ge.escapeLast(t, e, i - 1) : `${t.slice(0, i)}\\${t.slice(i)}`;
  };
  ge.removePrefix = (t, e = {}) => {
    let r = t;
    return r.startsWith("./") && (r = r.slice(2), e.prefix = "./"), r;
  };
  ge.wrapOutput = (t, e = {}, r = {}) => {
    let i = r.contains ? "" : "^", n = r.contains ? "" : "$", o = `${i}(?:${t})${n}`;
    return e.negated === !0 && (o = `(?:^(?!${o}).*$)`), o;
  };
});

// ../node_modules/picomatch/lib/scan.js
var Sh = d((o1, yh) => {
  "use strict";
  var hh = hr(), {
    CHAR_ASTERISK: Ts,
    /* * */
    CHAR_AT: Jv,
    /* @ */
    CHAR_BACKWARD_SLASH: fr,
    /* \ */
    CHAR_COMMA: Qv,
    /* , */
    CHAR_DOT: ks,
    /* . */
    CHAR_EXCLAMATION_MARK: Is,
    /* ! */
    CHAR_FORWARD_SLASH: gh,
    /* / */
    CHAR_LEFT_CURLY_BRACE: Ds,
    /* { */
    CHAR_LEFT_PARENTHESES: qs,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET: Zv,
    /* [ */
    CHAR_PLUS: e_,
    /* + */
    CHAR_QUESTION_MARK: fh,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE: t_,
    /* } */
    CHAR_RIGHT_PARENTHESES: dh,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET: r_
    /* ] */
  } = lr(), ph = /* @__PURE__ */ s((t) => t === gh || t === fr, "isPathSeparator"), mh = /* @__PURE__ */ s((t) => {
    t.isPrefix !== !0 && (t.depth = t.isGlobstar ? 1 / 0 : 1);
  }, "depth"), i_ = /* @__PURE__ */ s((t, e) => {
    let r = e || {}, i = t.length - 1, n = r.parts === !0 || r.scanToEnd === !0, o = [], a = [], u = [], c = t, h = -1, l = 0, p = 0, f = !1,
    b = !1, m = !1, w = !1, _ = !1, P = !1, q = !1, R = !1, te = !1, I = !1, H = 0, $, C, x = { value: "", depth: 0, isGlob: !1 }, T = /* @__PURE__ */ s(
    () => h >= i, "eos"), S = /* @__PURE__ */ s(() => c.charCodeAt(h + 1), "peek"), F = /* @__PURE__ */ s(() => ($ = C, c.charCodeAt(++h)), "\
advance");
    for (; h < i; ) {
      C = F();
      let N;
      if (C === fr) {
        q = x.backslashes = !0, C = F(), C === Ds && (P = !0);
        continue;
      }
      if (P === !0 || C === Ds) {
        for (H++; T() !== !0 && (C = F()); ) {
          if (C === fr) {
            q = x.backslashes = !0, F();
            continue;
          }
          if (C === Ds) {
            H++;
            continue;
          }
          if (P !== !0 && C === ks && (C = F()) === ks) {
            if (f = x.isBrace = !0, m = x.isGlob = !0, I = !0, n === !0)
              continue;
            break;
          }
          if (P !== !0 && C === Qv) {
            if (f = x.isBrace = !0, m = x.isGlob = !0, I = !0, n === !0)
              continue;
            break;
          }
          if (C === t_ && (H--, H === 0)) {
            P = !1, f = x.isBrace = !0, I = !0;
            break;
          }
        }
        if (n === !0)
          continue;
        break;
      }
      if (C === gh) {
        if (o.push(h), a.push(x), x = { value: "", depth: 0, isGlob: !1 }, I === !0) continue;
        if ($ === ks && h === l + 1) {
          l += 2;
          continue;
        }
        p = h + 1;
        continue;
      }
      if (r.noext !== !0 && (C === e_ || C === Jv || C === Ts || C === fh || C === Is) === !0 && S() === qs) {
        if (m = x.isGlob = !0, w = x.isExtglob = !0, I = !0, C === Is && h === l && (te = !0), n === !0) {
          for (; T() !== !0 && (C = F()); ) {
            if (C === fr) {
              q = x.backslashes = !0, C = F();
              continue;
            }
            if (C === dh) {
              m = x.isGlob = !0, I = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (C === Ts) {
        if ($ === Ts && (_ = x.isGlobstar = !0), m = x.isGlob = !0, I = !0, n === !0)
          continue;
        break;
      }
      if (C === fh) {
        if (m = x.isGlob = !0, I = !0, n === !0)
          continue;
        break;
      }
      if (C === Zv) {
        for (; T() !== !0 && (N = F()); ) {
          if (N === fr) {
            q = x.backslashes = !0, F();
            continue;
          }
          if (N === r_) {
            b = x.isBracket = !0, m = x.isGlob = !0, I = !0;
            break;
          }
        }
        if (n === !0)
          continue;
        break;
      }
      if (r.nonegate !== !0 && C === Is && h === l) {
        R = x.negated = !0, l++;
        continue;
      }
      if (r.noparen !== !0 && C === qs) {
        if (m = x.isGlob = !0, n === !0) {
          for (; T() !== !0 && (C = F()); ) {
            if (C === qs) {
              q = x.backslashes = !0, C = F();
              continue;
            }
            if (C === dh) {
              I = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (m === !0) {
        if (I = !0, n === !0)
          continue;
        break;
      }
    }
    r.noext === !0 && (w = !1, m = !1);
    let D = c, W = "", g = "";
    l > 0 && (W = c.slice(0, l), c = c.slice(l), p -= l), D && m === !0 && p > 0 ? (D = c.slice(0, p), g = c.slice(p)) : m === !0 ? (D = "",
    g = c) : D = c, D && D !== "" && D !== "/" && D !== c && ph(D.charCodeAt(D.length - 1)) && (D = D.slice(0, -1)), r.unescape === !0 && (g &&
    (g = hh.removeBackslashes(g)), D && q === !0 && (D = hh.removeBackslashes(D)));
    let y = {
      prefix: W,
      input: t,
      start: l,
      base: D,
      glob: g,
      isBrace: f,
      isBracket: b,
      isGlob: m,
      isExtglob: w,
      isGlobstar: _,
      negated: R,
      negatedExtglob: te
    };
    if (r.tokens === !0 && (y.maxDepth = 0, ph(C) || a.push(x), y.tokens = a), r.parts === !0 || r.tokens === !0) {
      let N;
      for (let O = 0; O < o.length; O++) {
        let j = N ? N + 1 : l, Ae = o[O], be = t.slice(j, Ae);
        r.tokens && (O === 0 && l !== 0 ? (a[O].isPrefix = !0, a[O].value = W) : a[O].value = be, mh(a[O]), y.maxDepth += a[O].depth), (O !==
        0 || be !== "") && u.push(be), N = Ae;
      }
      if (N && N + 1 < t.length) {
        let O = t.slice(N + 1);
        u.push(O), r.tokens && (a[a.length - 1].value = O, mh(a[a.length - 1]), y.maxDepth += a[a.length - 1].depth);
      }
      y.slashes = o, y.parts = u;
    }
    return y;
  }, "scan");
  yh.exports = i_;
});

// ../node_modules/picomatch/lib/parse.js
var vh = d((u1, wh) => {
  "use strict";
  var si = lr(), ve = hr(), {
    MAX_LENGTH: ni,
    POSIX_REGEX_SOURCE: s_,
    REGEX_NON_SPECIAL_CHARS: n_,
    REGEX_SPECIAL_CHARS_BACKREF: o_,
    REPLACEMENTS: bh
  } = si, a_ = /* @__PURE__ */ s((t, e) => {
    if (typeof e.expandRange == "function")
      return e.expandRange(...t, e);
    t.sort();
    let r = `[${t.join("-")}]`;
    try {
      new RegExp(r);
    } catch {
      return t.map((n) => ve.escapeRegex(n)).join("..");
    }
    return r;
  }, "expandRange"), Mt = /* @__PURE__ */ s((t, e) => `Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`, "syntaxError"), $s = /* @__PURE__ */ s(
  (t, e) => {
    if (typeof t != "string")
      throw new TypeError("Expected a string");
    t = bh[t] || t;
    let r = { ...e }, i = typeof r.maxLength == "number" ? Math.min(ni, r.maxLength) : ni, n = t.length;
    if (n > i)
      throw new SyntaxError(`Input length: ${n}, exceeds maximum allowed length: ${i}`);
    let o = { type: "bos", value: "", output: r.prepend || "" }, a = [o], u = r.capture ? "" : "?:", c = ve.isWindows(e), h = si.globChars(c),
    l = si.extglobChars(h), {
      DOT_LITERAL: p,
      PLUS_LITERAL: f,
      SLASH_LITERAL: b,
      ONE_CHAR: m,
      DOTS_SLASH: w,
      NO_DOT: _,
      NO_DOT_SLASH: P,
      NO_DOTS_SLASH: q,
      QMARK: R,
      QMARK_NO_DOT: te,
      STAR: I,
      START_ANCHOR: H
    } = h, $ = /* @__PURE__ */ s((E) => `(${u}(?:(?!${H}${E.dot ? w : p}).)*?)`, "globstar"), C = r.dot ? "" : _, x = r.dot ? R : te, T = r.
    bash === !0 ? $(r) : I;
    r.capture && (T = `(${T})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
    let S = {
      input: t,
      index: -1,
      start: 0,
      dot: r.dot === !0,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: !1,
      negated: !1,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: !1,
      tokens: a
    };
    t = ve.removePrefix(t, S), n = t.length;
    let F = [], D = [], W = [], g = o, y, N = /* @__PURE__ */ s(() => S.index === n - 1, "eos"), O = S.peek = (E = 1) => t[S.index + E], j = S.
    advance = () => t[++S.index] || "", Ae = /* @__PURE__ */ s(() => t.slice(S.index + 1), "remaining"), be = /* @__PURE__ */ s((E = "", U = 0) => {
      S.consumed += E, S.index += U;
    }, "consume"), kr = /* @__PURE__ */ s((E) => {
      S.output += E.output != null ? E.output : E.value, be(E.value);
    }, "append"), Vy = /* @__PURE__ */ s(() => {
      let E = 1;
      for (; O() === "!" && (O(2) !== "(" || O(3) === "?"); )
        j(), S.start++, E++;
      return E % 2 === 0 ? !1 : (S.negated = !0, S.start++, !0);
    }, "negate"), Ir = /* @__PURE__ */ s((E) => {
      S[E]++, W.push(E);
    }, "increment"), vt = /* @__PURE__ */ s((E) => {
      S[E]--, W.pop();
    }, "decrement"), L = /* @__PURE__ */ s((E) => {
      if (g.type === "globstar") {
        let U = S.braces > 0 && (E.type === "comma" || E.type === "brace"), v = E.extglob === !0 || F.length && (E.type === "pipe" || E.type ===
        "paren");
        E.type !== "slash" && E.type !== "paren" && !U && !v && (S.output = S.output.slice(0, -g.output.length), g.type = "star", g.value = "\
*", g.output = T, S.output += g.output);
      }
      if (F.length && E.type !== "paren" && (F[F.length - 1].inner += E.value), (E.value || E.output) && kr(E), g && g.type === "text" && E.
      type === "text") {
        g.value += E.value, g.output = (g.output || "") + E.value;
        return;
      }
      E.prev = g, a.push(E), g = E;
    }, "push"), Dr = /* @__PURE__ */ s((E, U) => {
      let v = { ...l[U], conditions: 1, inner: "" };
      v.prev = g, v.parens = S.parens, v.output = S.output;
      let M = (r.capture ? "(" : "") + v.open;
      Ir("parens"), L({ type: E, value: U, output: S.output ? "" : m }), L({ type: "paren", extglob: !0, value: j(), output: M }), F.push(v);
    }, "extglobOpen"), Yy = /* @__PURE__ */ s((E) => {
      let U = E.close + (r.capture ? ")" : ""), v;
      if (E.type === "negate") {
        let M = T;
        if (E.inner && E.inner.length > 1 && E.inner.includes("/") && (M = $(r)), (M !== T || N() || /^\)+$/.test(Ae())) && (U = E.close = `\
)$))${M}`), E.inner.includes("*") && (v = Ae()) && /^\.[^\\/.]+$/.test(v)) {
          let K = $s(v, { ...e, fastpaths: !1 }).output;
          U = E.close = `)${K})${M})`;
        }
        E.prev.type === "bos" && (S.negatedExtglob = !0);
      }
      L({ type: "paren", extglob: !0, value: y, output: U }), vt("parens");
    }, "extglobClose");
    if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(t)) {
      let E = !1, U = t.replace(o_, (v, M, K, he, se, Xi) => he === "\\" ? (E = !0, v) : he === "?" ? M ? M + he + (se ? R.repeat(se.length) :
      "") : Xi === 0 ? x + (se ? R.repeat(se.length) : "") : R.repeat(K.length) : he === "." ? p.repeat(K.length) : he === "*" ? M ? M + he +
      (se ? T : "") : T : M ? v : `\\${v}`);
      return E === !0 && (r.unescape === !0 ? U = U.replace(/\\/g, "") : U = U.replace(/\\+/g, (v) => v.length % 2 === 0 ? "\\\\" : v ? "\\" :
      "")), U === t && r.contains === !0 ? (S.output = t, S) : (S.output = ve.wrapOutput(U, S, e), S);
    }
    for (; !N(); ) {
      if (y = j(), y === "\0")
        continue;
      if (y === "\\") {
        let v = O();
        if (v === "/" && r.bash !== !0 || v === "." || v === ";")
          continue;
        if (!v) {
          y += "\\", L({ type: "text", value: y });
          continue;
        }
        let M = /^\\+/.exec(Ae()), K = 0;
        if (M && M[0].length > 2 && (K = M[0].length, S.index += K, K % 2 !== 0 && (y += "\\")), r.unescape === !0 ? y = j() : y += j(), S.brackets ===
        0) {
          L({ type: "text", value: y });
          continue;
        }
      }
      if (S.brackets > 0 && (y !== "]" || g.value === "[" || g.value === "[^")) {
        if (r.posix !== !1 && y === ":") {
          let v = g.value.slice(1);
          if (v.includes("[") && (g.posix = !0, v.includes(":"))) {
            let M = g.value.lastIndexOf("["), K = g.value.slice(0, M), he = g.value.slice(M + 2), se = s_[he];
            if (se) {
              g.value = K + se, S.backtrack = !0, j(), !o.output && a.indexOf(g) === 1 && (o.output = m);
              continue;
            }
          }
        }
        (y === "[" && O() !== ":" || y === "-" && O() === "]") && (y = `\\${y}`), y === "]" && (g.value === "[" || g.value === "[^") && (y =
        `\\${y}`), r.posix === !0 && y === "!" && g.value === "[" && (y = "^"), g.value += y, kr({ value: y });
        continue;
      }
      if (S.quotes === 1 && y !== '"') {
        y = ve.escapeRegex(y), g.value += y, kr({ value: y });
        continue;
      }
      if (y === '"') {
        S.quotes = S.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && L({ type: "text", value: y });
        continue;
      }
      if (y === "(") {
        Ir("parens"), L({ type: "paren", value: y });
        continue;
      }
      if (y === ")") {
        if (S.parens === 0 && r.strictBrackets === !0)
          throw new SyntaxError(Mt("opening", "("));
        let v = F[F.length - 1];
        if (v && S.parens === v.parens + 1) {
          Yy(F.pop());
          continue;
        }
        L({ type: "paren", value: y, output: S.parens ? ")" : "\\)" }), vt("parens");
        continue;
      }
      if (y === "[") {
        if (r.nobracket === !0 || !Ae().includes("]")) {
          if (r.nobracket !== !0 && r.strictBrackets === !0)
            throw new SyntaxError(Mt("closing", "]"));
          y = `\\${y}`;
        } else
          Ir("brackets");
        L({ type: "bracket", value: y });
        continue;
      }
      if (y === "]") {
        if (r.nobracket === !0 || g && g.type === "bracket" && g.value.length === 1) {
          L({ type: "text", value: y, output: `\\${y}` });
          continue;
        }
        if (S.brackets === 0) {
          if (r.strictBrackets === !0)
            throw new SyntaxError(Mt("opening", "["));
          L({ type: "text", value: y, output: `\\${y}` });
          continue;
        }
        vt("brackets");
        let v = g.value.slice(1);
        if (g.posix !== !0 && v[0] === "^" && !v.includes("/") && (y = `/${y}`), g.value += y, kr({ value: y }), r.literalBrackets === !1 ||
        ve.hasRegexChars(v))
          continue;
        let M = ve.escapeRegex(g.value);
        if (S.output = S.output.slice(0, -g.value.length), r.literalBrackets === !0) {
          S.output += M, g.value = M;
          continue;
        }
        g.value = `(${u}${M}|${g.value})`, S.output += g.value;
        continue;
      }
      if (y === "{" && r.nobrace !== !0) {
        Ir("braces");
        let v = {
          type: "brace",
          value: y,
          output: "(",
          outputIndex: S.output.length,
          tokensIndex: S.tokens.length
        };
        D.push(v), L(v);
        continue;
      }
      if (y === "}") {
        let v = D[D.length - 1];
        if (r.nobrace === !0 || !v) {
          L({ type: "text", value: y, output: y });
          continue;
        }
        let M = ")";
        if (v.dots === !0) {
          let K = a.slice(), he = [];
          for (let se = K.length - 1; se >= 0 && (a.pop(), K[se].type !== "brace"); se--)
            K[se].type !== "dots" && he.unshift(K[se].value);
          M = a_(he, r), S.backtrack = !0;
        }
        if (v.comma !== !0 && v.dots !== !0) {
          let K = S.output.slice(0, v.outputIndex), he = S.tokens.slice(v.tokensIndex);
          v.value = v.output = "\\{", y = M = "\\}", S.output = K;
          for (let se of he)
            S.output += se.output || se.value;
        }
        L({ type: "brace", value: y, output: M }), vt("braces"), D.pop();
        continue;
      }
      if (y === "|") {
        F.length > 0 && F[F.length - 1].conditions++, L({ type: "text", value: y });
        continue;
      }
      if (y === ",") {
        let v = y, M = D[D.length - 1];
        M && W[W.length - 1] === "braces" && (M.comma = !0, v = "|"), L({ type: "comma", value: y, output: v });
        continue;
      }
      if (y === "/") {
        if (g.type === "dot" && S.index === S.start + 1) {
          S.start = S.index + 1, S.consumed = "", S.output = "", a.pop(), g = o;
          continue;
        }
        L({ type: "slash", value: y, output: b });
        continue;
      }
      if (y === ".") {
        if (S.braces > 0 && g.type === "dot") {
          g.value === "." && (g.output = p);
          let v = D[D.length - 1];
          g.type = "dots", g.output += y, g.value += y, v.dots = !0;
          continue;
        }
        if (S.braces + S.parens === 0 && g.type !== "bos" && g.type !== "slash") {
          L({ type: "text", value: y, output: p });
          continue;
        }
        L({ type: "dot", value: y, output: p });
        continue;
      }
      if (y === "?") {
        if (!(g && g.value === "(") && r.noextglob !== !0 && O() === "(" && O(2) !== "?") {
          Dr("qmark", y);
          continue;
        }
        if (g && g.type === "paren") {
          let M = O(), K = y;
          if (M === "<" && !ve.supportsLookbehinds())
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          (g.value === "(" && !/[!=<:]/.test(M) || M === "<" && !/<([!=]|\w+>)/.test(Ae())) && (K = `\\${y}`), L({ type: "text", value: y, output: K });
          continue;
        }
        if (r.dot !== !0 && (g.type === "slash" || g.type === "bos")) {
          L({ type: "qmark", value: y, output: te });
          continue;
        }
        L({ type: "qmark", value: y, output: R });
        continue;
      }
      if (y === "!") {
        if (r.noextglob !== !0 && O() === "(" && (O(2) !== "?" || !/[!=<:]/.test(O(3)))) {
          Dr("negate", y);
          continue;
        }
        if (r.nonegate !== !0 && S.index === 0) {
          Vy();
          continue;
        }
      }
      if (y === "+") {
        if (r.noextglob !== !0 && O() === "(" && O(2) !== "?") {
          Dr("plus", y);
          continue;
        }
        if (g && g.value === "(" || r.regex === !1) {
          L({ type: "plus", value: y, output: f });
          continue;
        }
        if (g && (g.type === "bracket" || g.type === "paren" || g.type === "brace") || S.parens > 0) {
          L({ type: "plus", value: y });
          continue;
        }
        L({ type: "plus", value: f });
        continue;
      }
      if (y === "@") {
        if (r.noextglob !== !0 && O() === "(" && O(2) !== "?") {
          L({ type: "at", extglob: !0, value: y, output: "" });
          continue;
        }
        L({ type: "text", value: y });
        continue;
      }
      if (y !== "*") {
        (y === "$" || y === "^") && (y = `\\${y}`);
        let v = n_.exec(Ae());
        v && (y += v[0], S.index += v[0].length), L({ type: "text", value: y });
        continue;
      }
      if (g && (g.type === "globstar" || g.star === !0)) {
        g.type = "star", g.star = !0, g.value += y, g.output = T, S.backtrack = !0, S.globstar = !0, be(y);
        continue;
      }
      let E = Ae();
      if (r.noextglob !== !0 && /^\([^?]/.test(E)) {
        Dr("star", y);
        continue;
      }
      if (g.type === "star") {
        if (r.noglobstar === !0) {
          be(y);
          continue;
        }
        let v = g.prev, M = v.prev, K = v.type === "slash" || v.type === "bos", he = M && (M.type === "star" || M.type === "globstar");
        if (r.bash === !0 && (!K || E[0] && E[0] !== "/")) {
          L({ type: "star", value: y, output: "" });
          continue;
        }
        let se = S.braces > 0 && (v.type === "comma" || v.type === "brace"), Xi = F.length && (v.type === "pipe" || v.type === "paren");
        if (!K && v.type !== "paren" && !se && !Xi) {
          L({ type: "star", value: y, output: "" });
          continue;
        }
        for (; E.slice(0, 3) === "/**"; ) {
          let qr = t[S.index + 4];
          if (qr && qr !== "/")
            break;
          E = E.slice(3), be("/**", 3);
        }
        if (v.type === "bos" && N()) {
          g.type = "globstar", g.value += y, g.output = $(r), S.output = g.output, S.globstar = !0, be(y);
          continue;
        }
        if (v.type === "slash" && v.prev.type !== "bos" && !he && N()) {
          S.output = S.output.slice(0, -(v.output + g.output).length), v.output = `(?:${v.output}`, g.type = "globstar", g.output = $(r) + (r.
          strictSlashes ? ")" : "|$)"), g.value += y, S.globstar = !0, S.output += v.output + g.output, be(y);
          continue;
        }
        if (v.type === "slash" && v.prev.type !== "bos" && E[0] === "/") {
          let qr = E[1] !== void 0 ? "|$" : "";
          S.output = S.output.slice(0, -(v.output + g.output).length), v.output = `(?:${v.output}`, g.type = "globstar", g.output = `${$(r)}${b}\
|${b}${qr})`, g.value += y, S.output += v.output + g.output, S.globstar = !0, be(y + j()), L({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (v.type === "bos" && E[0] === "/") {
          g.type = "globstar", g.value += y, g.output = `(?:^|${b}|${$(r)}${b})`, S.output = g.output, S.globstar = !0, be(y + j()), L({ type: "\
slash", value: "/", output: "" });
          continue;
        }
        S.output = S.output.slice(0, -g.output.length), g.type = "globstar", g.output = $(r), g.value += y, S.output += g.output, S.globstar =
        !0, be(y);
        continue;
      }
      let U = { type: "star", value: y, output: T };
      if (r.bash === !0) {
        U.output = ".*?", (g.type === "bos" || g.type === "slash") && (U.output = C + U.output), L(U);
        continue;
      }
      if (g && (g.type === "bracket" || g.type === "paren") && r.regex === !0) {
        U.output = y, L(U);
        continue;
      }
      (S.index === S.start || g.type === "slash" || g.type === "dot") && (g.type === "dot" ? (S.output += P, g.output += P) : r.dot === !0 ?
      (S.output += q, g.output += q) : (S.output += C, g.output += C), O() !== "*" && (S.output += m, g.output += m)), L(U);
    }
    for (; S.brackets > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(Mt("closing", "]"));
      S.output = ve.escapeLast(S.output, "["), vt("brackets");
    }
    for (; S.parens > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(Mt("closing", ")"));
      S.output = ve.escapeLast(S.output, "("), vt("parens");
    }
    for (; S.braces > 0; ) {
      if (r.strictBrackets === !0) throw new SyntaxError(Mt("closing", "}"));
      S.output = ve.escapeLast(S.output, "{"), vt("braces");
    }
    if (r.strictSlashes !== !0 && (g.type === "star" || g.type === "bracket") && L({ type: "maybe_slash", value: "", output: `${b}?` }), S.backtrack ===
    !0) {
      S.output = "";
      for (let E of S.tokens)
        S.output += E.output != null ? E.output : E.value, E.suffix && (S.output += E.suffix);
    }
    return S;
  }, "parse");
  $s.fastpaths = (t, e) => {
    let r = { ...e }, i = typeof r.maxLength == "number" ? Math.min(ni, r.maxLength) : ni, n = t.length;
    if (n > i)
      throw new SyntaxError(`Input length: ${n}, exceeds maximum allowed length: ${i}`);
    t = bh[t] || t;
    let o = ve.isWindows(e), {
      DOT_LITERAL: a,
      SLASH_LITERAL: u,
      ONE_CHAR: c,
      DOTS_SLASH: h,
      NO_DOT: l,
      NO_DOTS: p,
      NO_DOTS_SLASH: f,
      STAR: b,
      START_ANCHOR: m
    } = si.globChars(o), w = r.dot ? p : l, _ = r.dot ? f : l, P = r.capture ? "" : "?:", q = { negated: !1, prefix: "" }, R = r.bash === !0 ?
    ".*?" : b;
    r.capture && (R = `(${R})`);
    let te = /* @__PURE__ */ s((C) => C.noglobstar === !0 ? R : `(${P}(?:(?!${m}${C.dot ? h : a}).)*?)`, "globstar"), I = /* @__PURE__ */ s(
    (C) => {
      switch (C) {
        case "*":
          return `${w}${c}${R}`;
        case ".*":
          return `${a}${c}${R}`;
        case "*.*":
          return `${w}${R}${a}${c}${R}`;
        case "*/*":
          return `${w}${R}${u}${c}${_}${R}`;
        case "**":
          return w + te(r);
        case "**/*":
          return `(?:${w}${te(r)}${u})?${_}${c}${R}`;
        case "**/*.*":
          return `(?:${w}${te(r)}${u})?${_}${R}${a}${c}${R}`;
        case "**/.*":
          return `(?:${w}${te(r)}${u})?${a}${c}${R}`;
        default: {
          let x = /^(.*?)\.(\w+)$/.exec(C);
          if (!x) return;
          let T = I(x[1]);
          return T ? T + a + x[2] : void 0;
        }
      }
    }, "create"), H = ve.removePrefix(t, q), $ = I(H);
    return $ && r.strictSlashes !== !0 && ($ += `${u}?`), $;
  };
  wh.exports = $s;
});

// ../node_modules/picomatch/lib/picomatch.js
var xh = d((l1, _h) => {
  "use strict";
  var u_ = A("path"), c_ = Sh(), Fs = vh(), Ns = hr(), l_ = lr(), h_ = /* @__PURE__ */ s((t) => t && typeof t == "object" && !Array.isArray(
  t), "isObject"), re = /* @__PURE__ */ s((t, e, r = !1) => {
    if (Array.isArray(t)) {
      let l = t.map((f) => re(f, e, r));
      return /* @__PURE__ */ s((f) => {
        for (let b of l) {
          let m = b(f);
          if (m) return m;
        }
        return !1;
      }, "arrayMatcher");
    }
    let i = h_(t) && t.tokens && t.input;
    if (t === "" || typeof t != "string" && !i)
      throw new TypeError("Expected pattern to be a non-empty string");
    let n = e || {}, o = Ns.isWindows(e), a = i ? re.compileRe(t, e) : re.makeRe(t, e, !1, !0), u = a.state;
    delete a.state;
    let c = /* @__PURE__ */ s(() => !1, "isIgnored");
    if (n.ignore) {
      let l = { ...e, ignore: null, onMatch: null, onResult: null };
      c = re(n.ignore, l, r);
    }
    let h = /* @__PURE__ */ s((l, p = !1) => {
      let { isMatch: f, match: b, output: m } = re.test(l, a, e, { glob: t, posix: o }), w = { glob: t, state: u, regex: a, posix: o, input: l,
      output: m, match: b, isMatch: f };
      return typeof n.onResult == "function" && n.onResult(w), f === !1 ? (w.isMatch = !1, p ? w : !1) : c(l) ? (typeof n.onIgnore == "funct\
ion" && n.onIgnore(w), w.isMatch = !1, p ? w : !1) : (typeof n.onMatch == "function" && n.onMatch(w), p ? w : !0);
    }, "matcher");
    return r && (h.state = u), h;
  }, "picomatch");
  re.test = (t, e, r, { glob: i, posix: n } = {}) => {
    if (typeof t != "string")
      throw new TypeError("Expected input to be a string");
    if (t === "")
      return { isMatch: !1, output: "" };
    let o = r || {}, a = o.format || (n ? Ns.toPosixSlashes : null), u = t === i, c = u && a ? a(t) : t;
    return u === !1 && (c = a ? a(t) : t, u = c === i), (u === !1 || o.capture === !0) && (o.matchBase === !0 || o.basename === !0 ? u = re.
    matchBase(t, e, r, n) : u = e.exec(c)), { isMatch: !!u, match: u, output: c };
  };
  re.matchBase = (t, e, r, i = Ns.isWindows(r)) => (e instanceof RegExp ? e : re.makeRe(e, r)).test(u_.basename(t));
  re.isMatch = (t, e, r) => re(e, r)(t);
  re.parse = (t, e) => Array.isArray(t) ? t.map((r) => re.parse(r, e)) : Fs(t, { ...e, fastpaths: !1 });
  re.scan = (t, e) => c_(t, e);
  re.compileRe = (t, e, r = !1, i = !1) => {
    if (r === !0)
      return t.output;
    let n = e || {}, o = n.contains ? "" : "^", a = n.contains ? "" : "$", u = `${o}(?:${t.output})${a}`;
    t && t.negated === !0 && (u = `^(?!${u}).*$`);
    let c = re.toRegex(u, e);
    return i === !0 && (c.state = t), c;
  };
  re.makeRe = (t, e = {}, r = !1, i = !1) => {
    if (!t || typeof t != "string")
      throw new TypeError("Expected a non-empty string");
    let n = { negated: !1, fastpaths: !0 };
    return e.fastpaths !== !1 && (t[0] === "." || t[0] === "*") && (n.output = Fs.fastpaths(t, e)), n.output || (n = Fs(t, e)), re.compileRe(
    n, e, r, i);
  };
  re.toRegex = (t, e) => {
    try {
      let r = e || {};
      return new RegExp(t, r.flags || (r.nocase ? "i" : ""));
    } catch (r) {
      if (e && e.debug === !0) throw r;
      return /$^/;
    }
  };
  re.constants = l_;
  _h.exports = re;
});

// ../node_modules/picomatch/index.js
var Ph = d((f1, Eh) => {
  "use strict";
  Eh.exports = xh();
});

// ../node_modules/micromatch/index.js
var Th = d((d1, Ch) => {
  "use strict";
  var Ah = A("util"), Oh = nh(), Me = Ph(), Ms = hr(), Rh = /* @__PURE__ */ s((t) => t === "" || t === "./", "isEmptyString"), V = /* @__PURE__ */ s(
  (t, e, r) => {
    e = [].concat(e), t = [].concat(t);
    let i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), a = 0, u = /* @__PURE__ */ s((l) => {
      o.add(l.output), r && r.onResult && r.onResult(l);
    }, "onResult");
    for (let l = 0; l < e.length; l++) {
      let p = Me(String(e[l]), { ...r, onResult: u }, !0), f = p.state.negated || p.state.negatedExtglob;
      f && a++;
      for (let b of t) {
        let m = p(b, !0);
        (f ? !m.isMatch : m.isMatch) && (f ? i.add(m.output) : (i.delete(m.output), n.add(m.output)));
      }
    }
    let h = (a === e.length ? [...o] : [...n]).filter((l) => !i.has(l));
    if (r && h.length === 0) {
      if (r.failglob === !0)
        throw new Error(`No matches found for "${e.join(", ")}"`);
      if (r.nonull === !0 || r.nullglob === !0)
        return r.unescape ? e.map((l) => l.replace(/\\/g, "")) : e;
    }
    return h;
  }, "micromatch");
  V.match = V;
  V.matcher = (t, e) => Me(t, e);
  V.isMatch = (t, e, r) => Me(e, r)(t);
  V.any = V.isMatch;
  V.not = (t, e, r = {}) => {
    e = [].concat(e).map(String);
    let i = /* @__PURE__ */ new Set(), n = [], o = /* @__PURE__ */ s((u) => {
      r.onResult && r.onResult(u), n.push(u.output);
    }, "onResult"), a = new Set(V(t, e, { ...r, onResult: o }));
    for (let u of n)
      a.has(u) || i.add(u);
    return [...i];
  };
  V.contains = (t, e, r) => {
    if (typeof t != "string")
      throw new TypeError(`Expected a string: "${Ah.inspect(t)}"`);
    if (Array.isArray(e))
      return e.some((i) => V.contains(t, i, r));
    if (typeof e == "string") {
      if (Rh(t) || Rh(e))
        return !1;
      if (t.includes(e) || t.startsWith("./") && t.slice(2).includes(e))
        return !0;
    }
    return V.isMatch(t, e, { ...r, contains: !0 });
  };
  V.matchKeys = (t, e, r) => {
    if (!Ms.isObject(t))
      throw new TypeError("Expected the first argument to be an object");
    let i = V(Object.keys(t), e, r), n = {};
    for (let o of i) n[o] = t[o];
    return n;
  };
  V.some = (t, e, r) => {
    let i = [].concat(t);
    for (let n of [].concat(e)) {
      let o = Me(String(n), r);
      if (i.some((a) => o(a)))
        return !0;
    }
    return !1;
  };
  V.every = (t, e, r) => {
    let i = [].concat(t);
    for (let n of [].concat(e)) {
      let o = Me(String(n), r);
      if (!i.every((a) => o(a)))
        return !1;
    }
    return !0;
  };
  V.all = (t, e, r) => {
    if (typeof t != "string")
      throw new TypeError(`Expected a string: "${Ah.inspect(t)}"`);
    return [].concat(e).every((i) => Me(i, r)(t));
  };
  V.capture = (t, e, r) => {
    let i = Ms.isWindows(r), o = Me.makeRe(String(t), { ...r, capture: !0 }).exec(i ? Ms.toPosixSlashes(e) : e);
    if (o)
      return o.slice(1).map((a) => a === void 0 ? "" : a);
  };
  V.makeRe = (...t) => Me.makeRe(...t);
  V.scan = (...t) => Me.scan(...t);
  V.parse = (t, e) => {
    let r = [];
    for (let i of [].concat(t || []))
      for (let n of Oh(String(i), e))
        r.push(Me.parse(n, e));
    return r;
  };
  V.braces = (t, e) => {
    if (typeof t != "string") throw new TypeError("Expected a string");
    return e && e.nobrace === !0 || !/\{.*\}/.test(t) ? [t] : Oh(t, e);
  };
  V.braceExpand = (t, e) => {
    if (typeof t != "string") throw new TypeError("Expected a string");
    return V.braces(t, { ...e, expand: !0 });
  };
  Ch.exports = V;
});

// ../node_modules/fast-glob/out/utils/pattern.js
var Mh = d((k) => {
  "use strict";
  Object.defineProperty(k, "__esModule", { value: !0 });
  k.removeDuplicateSlashes = k.matchAny = k.convertPatternsToRe = k.makeRe = k.getPatternParts = k.expandBraceExpansion = k.expandPatternsWithBraceExpansion =
  k.isAffectDepthOfReadingPattern = k.endsWithSlashGlobStar = k.hasGlobStar = k.getBaseDirectory = k.isPatternRelatedToParentDirectory = k.getPatternsOutsideCurrentDirectory =
  k.getPatternsInsideCurrentDirectory = k.getPositivePatterns = k.getNegativePatterns = k.isPositivePattern = k.isNegativePattern = k.convertToNegativePattern =
  k.convertToPositivePattern = k.isDynamicPattern = k.isStaticPattern = void 0;
  var f_ = A("path"), d_ = xl(), Ls = Th(), kh = "**", p_ = "\\", m_ = /[*?]|^!/, g_ = /\[[^[]*]/, y_ = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/, S_ = /[!*+?@]\([^(]*\)/,
  b_ = /,|\.\./, w_ = /(?!^)\/{2,}/g;
  function Ih(t, e = {}) {
    return !Dh(t, e);
  }
  s(Ih, "isStaticPattern");
  k.isStaticPattern = Ih;
  function Dh(t, e = {}) {
    return t === "" ? !1 : !!(e.caseSensitiveMatch === !1 || t.includes(p_) || m_.test(t) || g_.test(t) || y_.test(t) || e.extglob !== !1 &&
    S_.test(t) || e.braceExpansion !== !1 && v_(t));
  }
  s(Dh, "isDynamicPattern");
  k.isDynamicPattern = Dh;
  function v_(t) {
    let e = t.indexOf("{");
    if (e === -1)
      return !1;
    let r = t.indexOf("}", e + 1);
    if (r === -1)
      return !1;
    let i = t.slice(e, r);
    return b_.test(i);
  }
  s(v_, "hasBraceExpansion");
  function __(t) {
    return oi(t) ? t.slice(1) : t;
  }
  s(__, "convertToPositivePattern");
  k.convertToPositivePattern = __;
  function x_(t) {
    return "!" + t;
  }
  s(x_, "convertToNegativePattern");
  k.convertToNegativePattern = x_;
  function oi(t) {
    return t.startsWith("!") && t[1] !== "(";
  }
  s(oi, "isNegativePattern");
  k.isNegativePattern = oi;
  function qh(t) {
    return !oi(t);
  }
  s(qh, "isPositivePattern");
  k.isPositivePattern = qh;
  function E_(t) {
    return t.filter(oi);
  }
  s(E_, "getNegativePatterns");
  k.getNegativePatterns = E_;
  function P_(t) {
    return t.filter(qh);
  }
  s(P_, "getPositivePatterns");
  k.getPositivePatterns = P_;
  function R_(t) {
    return t.filter((e) => !js(e));
  }
  s(R_, "getPatternsInsideCurrentDirectory");
  k.getPatternsInsideCurrentDirectory = R_;
  function A_(t) {
    return t.filter(js);
  }
  s(A_, "getPatternsOutsideCurrentDirectory");
  k.getPatternsOutsideCurrentDirectory = A_;
  function js(t) {
    return t.startsWith("..") || t.startsWith("./..");
  }
  s(js, "isPatternRelatedToParentDirectory");
  k.isPatternRelatedToParentDirectory = js;
  function O_(t) {
    return d_(t, { flipBackslashes: !1 });
  }
  s(O_, "getBaseDirectory");
  k.getBaseDirectory = O_;
  function C_(t) {
    return t.includes(kh);
  }
  s(C_, "hasGlobStar");
  k.hasGlobStar = C_;
  function $h(t) {
    return t.endsWith("/" + kh);
  }
  s($h, "endsWithSlashGlobStar");
  k.endsWithSlashGlobStar = $h;
  function T_(t) {
    let e = f_.basename(t);
    return $h(t) || Ih(e);
  }
  s(T_, "isAffectDepthOfReadingPattern");
  k.isAffectDepthOfReadingPattern = T_;
  function k_(t) {
    return t.reduce((e, r) => e.concat(Fh(r)), []);
  }
  s(k_, "expandPatternsWithBraceExpansion");
  k.expandPatternsWithBraceExpansion = k_;
  function Fh(t) {
    let e = Ls.braces(t, { expand: !0, nodupes: !0, keepEscaping: !0 });
    return e.sort((r, i) => r.length - i.length), e.filter((r) => r !== "");
  }
  s(Fh, "expandBraceExpansion");
  k.expandBraceExpansion = Fh;
  function I_(t, e) {
    let { parts: r } = Ls.scan(t, Object.assign(Object.assign({}, e), { parts: !0 }));
    return r.length === 0 && (r = [t]), r[0].startsWith("/") && (r[0] = r[0].slice(1), r.unshift("")), r;
  }
  s(I_, "getPatternParts");
  k.getPatternParts = I_;
  function Nh(t, e) {
    return Ls.makeRe(t, e);
  }
  s(Nh, "makeRe");
  k.makeRe = Nh;
  function D_(t, e) {
    return t.map((r) => Nh(r, e));
  }
  s(D_, "convertPatternsToRe");
  k.convertPatternsToRe = D_;
  function q_(t, e) {
    return e.some((r) => r.test(t));
  }
  s(q_, "matchAny");
  k.matchAny = q_;
  function $_(t) {
    return t.replace(w_, "/");
  }
  s($_, "removeDuplicateSlashes");
  k.removeDuplicateSlashes = $_;
});

// ../node_modules/merge2/index.js
var Bh = d((y1, Hh) => {
  "use strict";
  var F_ = A("stream"), Lh = F_.PassThrough, N_ = Array.prototype.slice;
  Hh.exports = M_;
  function M_() {
    let t = [], e = N_.call(arguments), r = !1, i = e[e.length - 1];
    i && !Array.isArray(i) && i.pipe == null ? e.pop() : i = {};
    let n = i.end !== !1, o = i.pipeError === !0;
    i.objectMode == null && (i.objectMode = !0), i.highWaterMark == null && (i.highWaterMark = 64 * 1024);
    let a = Lh(i);
    function u() {
      for (let l = 0, p = arguments.length; l < p; l++)
        t.push(jh(arguments[l], i));
      return c(), this;
    }
    s(u, "addStream");
    function c() {
      if (r)
        return;
      r = !0;
      let l = t.shift();
      if (!l) {
        process.nextTick(h);
        return;
      }
      Array.isArray(l) || (l = [l]);
      let p = l.length + 1;
      function f() {
        --p > 0 || (r = !1, c());
      }
      s(f, "next");
      function b(m) {
        function w() {
          m.removeListener("merge2UnpipeEnd", w), m.removeListener("end", w), o && m.removeListener("error", _), f();
        }
        s(w, "onend");
        function _(P) {
          a.emit("error", P);
        }
        if (s(_, "onerror"), m._readableState.endEmitted)
          return f();
        m.on("merge2UnpipeEnd", w), m.on("end", w), o && m.on("error", _), m.pipe(a, { end: !1 }), m.resume();
      }
      s(b, "pipe");
      for (let m = 0; m < l.length; m++)
        b(l[m]);
      f();
    }
    s(c, "mergeStream");
    function h() {
      r = !1, a.emit("queueDrain"), n && a.end();
    }
    return s(h, "endStream"), a.setMaxListeners(0), a.add = u, a.on("unpipe", function(l) {
      l.emit("merge2UnpipeEnd");
    }), e.length && u.apply(null, e), a;
  }
  s(M_, "merge2");
  function jh(t, e) {
    if (Array.isArray(t))
      for (let r = 0, i = t.length; r < i; r++)
        t[r] = jh(t[r], e);
    else {
      if (!t._readableState && t.pipe && (t = t.pipe(Lh(e))), !t._readableState || !t.pause || !t.pipe)
        throw new Error("Only readable stream can be merged.");
      t.pause();
    }
    return t;
  }
  s(jh, "pauseStreams");
});

// ../node_modules/fast-glob/out/utils/stream.js
var Gh = d((ai) => {
  "use strict";
  Object.defineProperty(ai, "__esModule", { value: !0 });
  ai.merge = void 0;
  var L_ = Bh();
  function j_(t) {
    let e = L_(t);
    return t.forEach((r) => {
      r.once("error", (i) => e.emit("error", i));
    }), e.once("close", () => Wh(t)), e.once("end", () => Wh(t)), e;
  }
  s(j_, "merge");
  ai.merge = j_;
  function Wh(t) {
    t.forEach((e) => e.emit("close"));
  }
  s(Wh, "propagateCloseEventToSources");
});

// ../node_modules/fast-glob/out/utils/string.js
var Uh = d((Lt) => {
  "use strict";
  Object.defineProperty(Lt, "__esModule", { value: !0 });
  Lt.isEmpty = Lt.isString = void 0;
  function H_(t) {
    return typeof t == "string";
  }
  s(H_, "isString");
  Lt.isString = H_;
  function B_(t) {
    return t === "";
  }
  s(B_, "isEmpty");
  Lt.isEmpty = B_;
});

// ../node_modules/fast-glob/out/utils/index.js
var Je = d((ce) => {
  "use strict";
  Object.defineProperty(ce, "__esModule", { value: !0 });
  ce.string = ce.stream = ce.pattern = ce.path = ce.fs = ce.errno = ce.array = void 0;
  var W_ = ll();
  ce.array = W_;
  var G_ = hl();
  ce.errno = G_;
  var U_ = fl();
  ce.fs = U_;
  var V_ = gl();
  ce.path = V_;
  var Y_ = Mh();
  ce.pattern = Y_;
  var K_ = Gh();
  ce.stream = K_;
  var X_ = Uh();
  ce.string = X_;
});

// ../node_modules/fast-glob/out/managers/tasks.js
var Xh = d((le) => {
  "use strict";
  Object.defineProperty(le, "__esModule", { value: !0 });
  le.convertPatternGroupToTask = le.convertPatternGroupsToTasks = le.groupPatternsByBaseDirectory = le.getNegativePatternsAsPositive = le.getPositivePatterns =
  le.convertPatternsToTasks = le.generate = void 0;
  var ke = Je();
  function z_(t, e) {
    let r = Vh(t, e), i = Vh(e.ignore, e), n = Yh(r), o = Kh(r, i), a = n.filter((l) => ke.pattern.isStaticPattern(l, e)), u = n.filter((l) => ke.
    pattern.isDynamicPattern(l, e)), c = Hs(
      a,
      o,
      /* dynamic */
      !1
    ), h = Hs(
      u,
      o,
      /* dynamic */
      !0
    );
    return c.concat(h);
  }
  s(z_, "generate");
  le.generate = z_;
  function Vh(t, e) {
    let r = t;
    return e.braceExpansion && (r = ke.pattern.expandPatternsWithBraceExpansion(r)), e.baseNameMatch && (r = r.map((i) => i.includes("/") ? i :
    `**/${i}`)), r.map((i) => ke.pattern.removeDuplicateSlashes(i));
  }
  s(Vh, "processPatterns");
  function Hs(t, e, r) {
    let i = [], n = ke.pattern.getPatternsOutsideCurrentDirectory(t), o = ke.pattern.getPatternsInsideCurrentDirectory(t), a = Bs(n), u = Bs(
    o);
    return i.push(...Ws(a, e, r)), "." in u ? i.push(Gs(".", o, e, r)) : i.push(...Ws(u, e, r)), i;
  }
  s(Hs, "convertPatternsToTasks");
  le.convertPatternsToTasks = Hs;
  function Yh(t) {
    return ke.pattern.getPositivePatterns(t);
  }
  s(Yh, "getPositivePatterns");
  le.getPositivePatterns = Yh;
  function Kh(t, e) {
    return ke.pattern.getNegativePatterns(t).concat(e).map(ke.pattern.convertToPositivePattern);
  }
  s(Kh, "getNegativePatternsAsPositive");
  le.getNegativePatternsAsPositive = Kh;
  function Bs(t) {
    let e = {};
    return t.reduce((r, i) => {
      let n = ke.pattern.getBaseDirectory(i);
      return n in r ? r[n].push(i) : r[n] = [i], r;
    }, e);
  }
  s(Bs, "groupPatternsByBaseDirectory");
  le.groupPatternsByBaseDirectory = Bs;
  function Ws(t, e, r) {
    return Object.keys(t).map((i) => Gs(i, t[i], e, r));
  }
  s(Ws, "convertPatternGroupsToTasks");
  le.convertPatternGroupsToTasks = Ws;
  function Gs(t, e, r, i) {
    return {
      dynamic: i,
      positive: e,
      negative: r,
      base: t,
      patterns: [].concat(e, r.map(ke.pattern.convertToNegativePattern))
    };
  }
  s(Gs, "convertPatternGroupToTask");
  le.convertPatternGroupToTask = Gs;
});

// ../node_modules/@nodelib/fs.stat/out/providers/async.js
var Jh = d((ui) => {
  "use strict";
  Object.defineProperty(ui, "__esModule", { value: !0 });
  ui.read = void 0;
  function J_(t, e, r) {
    e.fs.lstat(t, (i, n) => {
      if (i !== null) {
        zh(r, i);
        return;
      }
      if (!n.isSymbolicLink() || !e.followSymbolicLink) {
        Us(r, n);
        return;
      }
      e.fs.stat(t, (o, a) => {
        if (o !== null) {
          if (e.throwErrorOnBrokenSymbolicLink) {
            zh(r, o);
            return;
          }
          Us(r, n);
          return;
        }
        e.markSymbolicLink && (a.isSymbolicLink = () => !0), Us(r, a);
      });
    });
  }
  s(J_, "read");
  ui.read = J_;
  function zh(t, e) {
    t(e);
  }
  s(zh, "callFailureCallback");
  function Us(t, e) {
    t(null, e);
  }
  s(Us, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.stat/out/providers/sync.js
var Qh = d((ci) => {
  "use strict";
  Object.defineProperty(ci, "__esModule", { value: !0 });
  ci.read = void 0;
  function Q_(t, e) {
    let r = e.fs.lstatSync(t);
    if (!r.isSymbolicLink() || !e.followSymbolicLink)
      return r;
    try {
      let i = e.fs.statSync(t);
      return e.markSymbolicLink && (i.isSymbolicLink = () => !0), i;
    } catch (i) {
      if (!e.throwErrorOnBrokenSymbolicLink)
        return r;
      throw i;
    }
  }
  s(Q_, "read");
  ci.read = Q_;
});

// ../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var Zh = d((ht) => {
  "use strict";
  Object.defineProperty(ht, "__esModule", { value: !0 });
  ht.createFileSystemAdapter = ht.FILE_SYSTEM_ADAPTER = void 0;
  var li = A("fs");
  ht.FILE_SYSTEM_ADAPTER = {
    lstat: li.lstat,
    stat: li.stat,
    lstatSync: li.lstatSync,
    statSync: li.statSync
  };
  function Z_(t) {
    return t === void 0 ? ht.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, ht.FILE_SYSTEM_ADAPTER), t);
  }
  s(Z_, "createFileSystemAdapter");
  ht.createFileSystemAdapter = Z_;
});

// ../node_modules/@nodelib/fs.stat/out/settings.js
var ef = d((Ys) => {
  "use strict";
  Object.defineProperty(Ys, "__esModule", { value: !0 });
  var ex = Zh(), Vs = class {
    static {
      s(this, "Settings");
    }
    constructor(e = {}) {
      this._options = e, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, !0), this.fs = ex.createFileSystemAdapter(
      this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, !1), this.throwErrorOnBrokenSymbolicLink = this.
      _getValue(this._options.throwErrorOnBrokenSymbolicLink, !0);
    }
    _getValue(e, r) {
      return e ?? r;
    }
  };
  Ys.default = Vs;
});

// ../node_modules/@nodelib/fs.stat/out/index.js
var At = d((ft) => {
  "use strict";
  Object.defineProperty(ft, "__esModule", { value: !0 });
  ft.statSync = ft.stat = ft.Settings = void 0;
  var tf = Jh(), tx = Qh(), Ks = ef();
  ft.Settings = Ks.default;
  function rx(t, e, r) {
    if (typeof e == "function") {
      tf.read(t, Xs(), e);
      return;
    }
    tf.read(t, Xs(e), r);
  }
  s(rx, "stat");
  ft.stat = rx;
  function ix(t, e) {
    let r = Xs(e);
    return tx.read(t, r);
  }
  s(ix, "statSync");
  ft.statSync = ix;
  function Xs(t = {}) {
    return t instanceof Ks.default ? t : new Ks.default(t);
  }
  s(Xs, "getSettings");
});

// ../node_modules/queue-microtask/index.js
var nf = d((F1, sf) => {
  var rf;
  sf.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : global) : (t) => (rf || (rf = Promise.
  resolve())).then(t).catch((e) => setTimeout(() => {
    throw e;
  }, 0));
});

// ../node_modules/run-parallel/index.js
var af = d((N1, of) => {
  of.exports = nx;
  var sx = nf();
  function nx(t, e) {
    let r, i, n, o = !0;
    Array.isArray(t) ? (r = [], i = t.length) : (n = Object.keys(t), r = {}, i = n.length);
    function a(c) {
      function h() {
        e && e(c, r), e = null;
      }
      s(h, "end"), o ? sx(h) : h();
    }
    s(a, "done");
    function u(c, h, l) {
      r[c] = l, (--i === 0 || h) && a(h);
    }
    s(u, "each"), i ? n ? n.forEach(function(c) {
      t[c](function(h, l) {
        u(c, h, l);
      });
    }) : t.forEach(function(c, h) {
      c(function(l, p) {
        u(h, l, p);
      });
    }) : a(null), o = !1;
  }
  s(nx, "runParallel");
});

// ../node_modules/@nodelib/fs.scandir/out/constants.js
var zs = d((fi) => {
  "use strict";
  Object.defineProperty(fi, "__esModule", { value: !0 });
  fi.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
  var hi = process.versions.node.split(".");
  if (hi[0] === void 0 || hi[1] === void 0)
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
  var uf = Number.parseInt(hi[0], 10), ox = Number.parseInt(hi[1], 10), cf = 10, ax = 10, ux = uf > cf, cx = uf === cf && ox >= ax;
  fi.IS_SUPPORT_READDIR_WITH_FILE_TYPES = ux || cx;
});

// ../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var lf = d((di) => {
  "use strict";
  Object.defineProperty(di, "__esModule", { value: !0 });
  di.createDirentFromStats = void 0;
  var Js = class {
    static {
      s(this, "DirentFromStats");
    }
    constructor(e, r) {
      this.name = e, this.isBlockDevice = r.isBlockDevice.bind(r), this.isCharacterDevice = r.isCharacterDevice.bind(r), this.isDirectory = r.
      isDirectory.bind(r), this.isFIFO = r.isFIFO.bind(r), this.isFile = r.isFile.bind(r), this.isSocket = r.isSocket.bind(r), this.isSymbolicLink =
      r.isSymbolicLink.bind(r);
    }
  };
  function lx(t, e) {
    return new Js(t, e);
  }
  s(lx, "createDirentFromStats");
  di.createDirentFromStats = lx;
});

// ../node_modules/@nodelib/fs.scandir/out/utils/index.js
var Qs = d((pi) => {
  "use strict";
  Object.defineProperty(pi, "__esModule", { value: !0 });
  pi.fs = void 0;
  var hx = lf();
  pi.fs = hx;
});

// ../node_modules/@nodelib/fs.scandir/out/providers/common.js
var Zs = d((mi) => {
  "use strict";
  Object.defineProperty(mi, "__esModule", { value: !0 });
  mi.joinPathSegments = void 0;
  function fx(t, e, r) {
    return t.endsWith(r) ? t + e : t + r + e;
  }
  s(fx, "joinPathSegments");
  mi.joinPathSegments = fx;
});

// ../node_modules/@nodelib/fs.scandir/out/providers/async.js
var gf = d((dt) => {
  "use strict";
  Object.defineProperty(dt, "__esModule", { value: !0 });
  dt.readdir = dt.readdirWithFileTypes = dt.read = void 0;
  var dx = At(), hf = af(), px = zs(), ff = Qs(), df = Zs();
  function mx(t, e, r) {
    if (!e.stats && px.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
      pf(t, e, r);
      return;
    }
    mf(t, e, r);
  }
  s(mx, "read");
  dt.read = mx;
  function pf(t, e, r) {
    e.fs.readdir(t, { withFileTypes: !0 }, (i, n) => {
      if (i !== null) {
        gi(r, i);
        return;
      }
      let o = n.map((u) => ({
        dirent: u,
        name: u.name,
        path: df.joinPathSegments(t, u.name, e.pathSegmentSeparator)
      }));
      if (!e.followSymbolicLinks) {
        en(r, o);
        return;
      }
      let a = o.map((u) => gx(u, e));
      hf(a, (u, c) => {
        if (u !== null) {
          gi(r, u);
          return;
        }
        en(r, c);
      });
    });
  }
  s(pf, "readdirWithFileTypes");
  dt.readdirWithFileTypes = pf;
  function gx(t, e) {
    return (r) => {
      if (!t.dirent.isSymbolicLink()) {
        r(null, t);
        return;
      }
      e.fs.stat(t.path, (i, n) => {
        if (i !== null) {
          if (e.throwErrorOnBrokenSymbolicLink) {
            r(i);
            return;
          }
          r(null, t);
          return;
        }
        t.dirent = ff.fs.createDirentFromStats(t.name, n), r(null, t);
      });
    };
  }
  s(gx, "makeRplTaskEntry");
  function mf(t, e, r) {
    e.fs.readdir(t, (i, n) => {
      if (i !== null) {
        gi(r, i);
        return;
      }
      let o = n.map((a) => {
        let u = df.joinPathSegments(t, a, e.pathSegmentSeparator);
        return (c) => {
          dx.stat(u, e.fsStatSettings, (h, l) => {
            if (h !== null) {
              c(h);
              return;
            }
            let p = {
              name: a,
              path: u,
              dirent: ff.fs.createDirentFromStats(a, l)
            };
            e.stats && (p.stats = l), c(null, p);
          });
        };
      });
      hf(o, (a, u) => {
        if (a !== null) {
          gi(r, a);
          return;
        }
        en(r, u);
      });
    });
  }
  s(mf, "readdir");
  dt.readdir = mf;
  function gi(t, e) {
    t(e);
  }
  s(gi, "callFailureCallback");
  function en(t, e) {
    t(null, e);
  }
  s(en, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var vf = d((pt) => {
  "use strict";
  Object.defineProperty(pt, "__esModule", { value: !0 });
  pt.readdir = pt.readdirWithFileTypes = pt.read = void 0;
  var yx = At(), Sx = zs(), yf = Qs(), Sf = Zs();
  function bx(t, e) {
    return !e.stats && Sx.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? bf(t, e) : wf(t, e);
  }
  s(bx, "read");
  pt.read = bx;
  function bf(t, e) {
    return e.fs.readdirSync(t, { withFileTypes: !0 }).map((i) => {
      let n = {
        dirent: i,
        name: i.name,
        path: Sf.joinPathSegments(t, i.name, e.pathSegmentSeparator)
      };
      if (n.dirent.isSymbolicLink() && e.followSymbolicLinks)
        try {
          let o = e.fs.statSync(n.path);
          n.dirent = yf.fs.createDirentFromStats(n.name, o);
        } catch (o) {
          if (e.throwErrorOnBrokenSymbolicLink)
            throw o;
        }
      return n;
    });
  }
  s(bf, "readdirWithFileTypes");
  pt.readdirWithFileTypes = bf;
  function wf(t, e) {
    return e.fs.readdirSync(t).map((i) => {
      let n = Sf.joinPathSegments(t, i, e.pathSegmentSeparator), o = yx.statSync(n, e.fsStatSettings), a = {
        name: i,
        path: n,
        dirent: yf.fs.createDirentFromStats(i, o)
      };
      return e.stats && (a.stats = o), a;
    });
  }
  s(wf, "readdir");
  pt.readdir = wf;
});

// ../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var _f = d((mt) => {
  "use strict";
  Object.defineProperty(mt, "__esModule", { value: !0 });
  mt.createFileSystemAdapter = mt.FILE_SYSTEM_ADAPTER = void 0;
  var jt = A("fs");
  mt.FILE_SYSTEM_ADAPTER = {
    lstat: jt.lstat,
    stat: jt.stat,
    lstatSync: jt.lstatSync,
    statSync: jt.statSync,
    readdir: jt.readdir,
    readdirSync: jt.readdirSync
  };
  function wx(t) {
    return t === void 0 ? mt.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, mt.FILE_SYSTEM_ADAPTER), t);
  }
  s(wx, "createFileSystemAdapter");
  mt.createFileSystemAdapter = wx;
});

// ../node_modules/@nodelib/fs.scandir/out/settings.js
var xf = d((rn) => {
  "use strict";
  Object.defineProperty(rn, "__esModule", { value: !0 });
  var vx = A("path"), _x = At(), xx = _f(), tn = class {
    static {
      s(this, "Settings");
    }
    constructor(e = {}) {
      this._options = e, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !1), this.fs = xx.createFileSystemAdapter(
      this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, vx.sep), this.stats = this._getValue(
      this._options.stats, !1), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !0), this.
      fsStatSettings = new _x.Settings({
        followSymbolicLink: this.followSymbolicLinks,
        fs: this.fs,
        throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(e, r) {
      return e ?? r;
    }
  };
  rn.default = tn;
});

// ../node_modules/@nodelib/fs.scandir/out/index.js
var yi = d((gt) => {
  "use strict";
  Object.defineProperty(gt, "__esModule", { value: !0 });
  gt.Settings = gt.scandirSync = gt.scandir = void 0;
  var Ef = gf(), Ex = vf(), sn = xf();
  gt.Settings = sn.default;
  function Px(t, e, r) {
    if (typeof e == "function") {
      Ef.read(t, nn(), e);
      return;
    }
    Ef.read(t, nn(e), r);
  }
  s(Px, "scandir");
  gt.scandir = Px;
  function Rx(t, e) {
    let r = nn(e);
    return Ex.read(t, r);
  }
  s(Rx, "scandirSync");
  gt.scandirSync = Rx;
  function nn(t = {}) {
    return t instanceof sn.default ? t : new sn.default(t);
  }
  s(nn, "getSettings");
});

// ../node_modules/reusify/reusify.js
var Rf = d((tk, Pf) => {
  "use strict";
  function Ax(t) {
    var e = new t(), r = e;
    function i() {
      var o = e;
      return o.next ? e = o.next : (e = new t(), r = e), o.next = null, o;
    }
    s(i, "get");
    function n(o) {
      r.next = o, r = o;
    }
    return s(n, "release"), {
      get: i,
      release: n
    };
  }
  s(Ax, "reusify");
  Pf.exports = Ax;
});

// ../node_modules/fastq/queue.js
var Of = d((ik, on) => {
  "use strict";
  var Ox = Rf();
  function Af(t, e, r) {
    if (typeof t == "function" && (r = e, e = t, t = null), r < 1)
      throw new Error("fastqueue concurrency must be greater than 1");
    var i = Ox(Cx), n = null, o = null, a = 0, u = null, c = {
      push: w,
      drain: xe,
      saturated: xe,
      pause: l,
      paused: !1,
      concurrency: r,
      running: h,
      resume: b,
      idle: m,
      length: p,
      getQueue: f,
      unshift: _,
      empty: xe,
      kill: q,
      killAndDrain: R,
      error: te
    };
    return c;
    function h() {
      return a;
    }
    function l() {
      c.paused = !0;
    }
    function p() {
      for (var I = n, H = 0; I; )
        I = I.next, H++;
      return H;
    }
    function f() {
      for (var I = n, H = []; I; )
        H.push(I.value), I = I.next;
      return H;
    }
    function b() {
      if (c.paused) {
        c.paused = !1;
        for (var I = 0; I < c.concurrency; I++)
          a++, P();
      }
    }
    function m() {
      return a === 0 && c.length() === 0;
    }
    function w(I, H) {
      var $ = i.get();
      $.context = t, $.release = P, $.value = I, $.callback = H || xe, $.errorHandler = u, a === c.concurrency || c.paused ? o ? (o.next = $,
      o = $) : (n = $, o = $, c.saturated()) : (a++, e.call(t, $.value, $.worked));
    }
    function _(I, H) {
      var $ = i.get();
      $.context = t, $.release = P, $.value = I, $.callback = H || xe, a === c.concurrency || c.paused ? n ? ($.next = n, n = $) : (n = $, o =
      $, c.saturated()) : (a++, e.call(t, $.value, $.worked));
    }
    function P(I) {
      I && i.release(I);
      var H = n;
      H ? c.paused ? a-- : (o === n && (o = null), n = H.next, H.next = null, e.call(t, H.value, H.worked), o === null && c.empty()) : --a ===
      0 && c.drain();
    }
    function q() {
      n = null, o = null, c.drain = xe;
    }
    function R() {
      n = null, o = null, c.drain(), c.drain = xe;
    }
    function te(I) {
      u = I;
    }
  }
  s(Af, "fastqueue");
  function xe() {
  }
  s(xe, "noop");
  function Cx() {
    this.value = null, this.callback = xe, this.next = null, this.release = xe, this.context = null, this.errorHandler = null;
    var t = this;
    this.worked = /* @__PURE__ */ s(function(r, i) {
      var n = t.callback, o = t.errorHandler, a = t.value;
      t.value = null, t.callback = xe, t.errorHandler && o(r, a), n.call(t.context, r, i), t.release(t);
    }, "worked");
  }
  s(Cx, "Task");
  function Tx(t, e, r) {
    typeof t == "function" && (r = e, e = t, t = null);
    function i(l, p) {
      e.call(this, l).then(function(f) {
        p(null, f);
      }, p);
    }
    s(i, "asyncWrapper");
    var n = Af(t, i, r), o = n.push, a = n.unshift;
    return n.push = u, n.unshift = c, n.drained = h, n;
    function u(l) {
      var p = new Promise(function(f, b) {
        o(l, function(m, w) {
          if (m) {
            b(m);
            return;
          }
          f(w);
        });
      });
      return p.catch(xe), p;
    }
    s(u, "push");
    function c(l) {
      var p = new Promise(function(f, b) {
        a(l, function(m, w) {
          if (m) {
            b(m);
            return;
          }
          f(w);
        });
      });
      return p.catch(xe), p;
    }
    s(c, "unshift");
    function h() {
      if (n.idle())
        return new Promise(function(f) {
          f();
        });
      var l = n.drain, p = new Promise(function(f) {
        n.drain = function() {
          l(), f();
        };
      });
      return p;
    }
    s(h, "drained");
  }
  s(Tx, "queueAsPromised");
  on.exports = Af;
  on.exports.promise = Tx;
});

// ../node_modules/@nodelib/fs.walk/out/readers/common.js
var Si = d((Le) => {
  "use strict";
  Object.defineProperty(Le, "__esModule", { value: !0 });
  Le.joinPathSegments = Le.replacePathSegmentSeparator = Le.isAppliedFilter = Le.isFatalError = void 0;
  function kx(t, e) {
    return t.errorFilter === null ? !0 : !t.errorFilter(e);
  }
  s(kx, "isFatalError");
  Le.isFatalError = kx;
  function Ix(t, e) {
    return t === null || t(e);
  }
  s(Ix, "isAppliedFilter");
  Le.isAppliedFilter = Ix;
  function Dx(t, e) {
    return t.split(/[/\\]/).join(e);
  }
  s(Dx, "replacePathSegmentSeparator");
  Le.replacePathSegmentSeparator = Dx;
  function qx(t, e, r) {
    return t === "" ? e : t.endsWith(r) ? t + e : t + r + e;
  }
  s(qx, "joinPathSegments");
  Le.joinPathSegments = qx;
});

// ../node_modules/@nodelib/fs.walk/out/readers/reader.js
var cn = d((un) => {
  "use strict";
  Object.defineProperty(un, "__esModule", { value: !0 });
  var $x = Si(), an = class {
    static {
      s(this, "Reader");
    }
    constructor(e, r) {
      this._root = e, this._settings = r, this._root = $x.replacePathSegmentSeparator(e, r.pathSegmentSeparator);
    }
  };
  un.default = an;
});

// ../node_modules/@nodelib/fs.walk/out/readers/async.js
var fn = d((hn) => {
  "use strict";
  Object.defineProperty(hn, "__esModule", { value: !0 });
  var Fx = A("events"), Nx = yi(), Mx = Of(), bi = Si(), Lx = cn(), ln = class extends Lx.default {
    static {
      s(this, "AsyncReader");
    }
    constructor(e, r) {
      super(e, r), this._settings = r, this._scandir = Nx.scandir, this._emitter = new Fx.EventEmitter(), this._queue = Mx(this._worker.bind(
      this), this._settings.concurrency), this._isFatalError = !1, this._isDestroyed = !1, this._queue.drain = () => {
        this._isFatalError || this._emitter.emit("end");
      };
    }
    read() {
      return this._isFatalError = !1, this._isDestroyed = !1, setImmediate(() => {
        this._pushToQueue(this._root, this._settings.basePath);
      }), this._emitter;
    }
    get isDestroyed() {
      return this._isDestroyed;
    }
    destroy() {
      if (this._isDestroyed)
        throw new Error("The reader is already destroyed");
      this._isDestroyed = !0, this._queue.killAndDrain();
    }
    onEntry(e) {
      this._emitter.on("entry", e);
    }
    onError(e) {
      this._emitter.once("error", e);
    }
    onEnd(e) {
      this._emitter.once("end", e);
    }
    _pushToQueue(e, r) {
      let i = { directory: e, base: r };
      this._queue.push(i, (n) => {
        n !== null && this._handleError(n);
      });
    }
    _worker(e, r) {
      this._scandir(e.directory, this._settings.fsScandirSettings, (i, n) => {
        if (i !== null) {
          r(i, void 0);
          return;
        }
        for (let o of n)
          this._handleEntry(o, e.base);
        r(null, void 0);
      });
    }
    _handleError(e) {
      this._isDestroyed || !bi.isFatalError(this._settings, e) || (this._isFatalError = !0, this._isDestroyed = !0, this._emitter.emit("erro\
r", e));
    }
    _handleEntry(e, r) {
      if (this._isDestroyed || this._isFatalError)
        return;
      let i = e.path;
      r !== void 0 && (e.path = bi.joinPathSegments(r, e.name, this._settings.pathSegmentSeparator)), bi.isAppliedFilter(this._settings.entryFilter,
      e) && this._emitEntry(e), e.dirent.isDirectory() && bi.isAppliedFilter(this._settings.deepFilter, e) && this._pushToQueue(i, r === void 0 ?
      void 0 : e.path);
    }
    _emitEntry(e) {
      this._emitter.emit("entry", e);
    }
  };
  hn.default = ln;
});

// ../node_modules/@nodelib/fs.walk/out/providers/async.js
var Cf = d((pn) => {
  "use strict";
  Object.defineProperty(pn, "__esModule", { value: !0 });
  var jx = fn(), dn = class {
    static {
      s(this, "AsyncProvider");
    }
    constructor(e, r) {
      this._root = e, this._settings = r, this._reader = new jx.default(this._root, this._settings), this._storage = [];
    }
    read(e) {
      this._reader.onError((r) => {
        Hx(e, r);
      }), this._reader.onEntry((r) => {
        this._storage.push(r);
      }), this._reader.onEnd(() => {
        Bx(e, this._storage);
      }), this._reader.read();
    }
  };
  pn.default = dn;
  function Hx(t, e) {
    t(e);
  }
  s(Hx, "callFailureCallback");
  function Bx(t, e) {
    t(null, e);
  }
  s(Bx, "callSuccessCallback");
});

// ../node_modules/@nodelib/fs.walk/out/providers/stream.js
var Tf = d((gn) => {
  "use strict";
  Object.defineProperty(gn, "__esModule", { value: !0 });
  var Wx = A("stream"), Gx = fn(), mn = class {
    static {
      s(this, "StreamProvider");
    }
    constructor(e, r) {
      this._root = e, this._settings = r, this._reader = new Gx.default(this._root, this._settings), this._stream = new Wx.Readable({
        objectMode: !0,
        read: /* @__PURE__ */ s(() => {
        }, "read"),
        destroy: /* @__PURE__ */ s(() => {
          this._reader.isDestroyed || this._reader.destroy();
        }, "destroy")
      });
    }
    read() {
      return this._reader.onError((e) => {
        this._stream.emit("error", e);
      }), this._reader.onEntry((e) => {
        this._stream.push(e);
      }), this._reader.onEnd(() => {
        this._stream.push(null);
      }), this._reader.read(), this._stream;
    }
  };
  gn.default = mn;
});

// ../node_modules/@nodelib/fs.walk/out/readers/sync.js
var kf = d((Sn) => {
  "use strict";
  Object.defineProperty(Sn, "__esModule", { value: !0 });
  var Ux = yi(), wi = Si(), Vx = cn(), yn = class extends Vx.default {
    static {
      s(this, "SyncReader");
    }
    constructor() {
      super(...arguments), this._scandir = Ux.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
    }
    read() {
      return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
    }
    _pushToQueue(e, r) {
      this._queue.add({ directory: e, base: r });
    }
    _handleQueue() {
      for (let e of this._queue.values())
        this._handleDirectory(e.directory, e.base);
    }
    _handleDirectory(e, r) {
      try {
        let i = this._scandir(e, this._settings.fsScandirSettings);
        for (let n of i)
          this._handleEntry(n, r);
      } catch (i) {
        this._handleError(i);
      }
    }
    _handleError(e) {
      if (wi.isFatalError(this._settings, e))
        throw e;
    }
    _handleEntry(e, r) {
      let i = e.path;
      r !== void 0 && (e.path = wi.joinPathSegments(r, e.name, this._settings.pathSegmentSeparator)), wi.isAppliedFilter(this._settings.entryFilter,
      e) && this._pushToStorage(e), e.dirent.isDirectory() && wi.isAppliedFilter(this._settings.deepFilter, e) && this._pushToQueue(i, r ===
      void 0 ? void 0 : e.path);
    }
    _pushToStorage(e) {
      this._storage.push(e);
    }
  };
  Sn.default = yn;
});

// ../node_modules/@nodelib/fs.walk/out/providers/sync.js
var If = d((wn) => {
  "use strict";
  Object.defineProperty(wn, "__esModule", { value: !0 });
  var Yx = kf(), bn = class {
    static {
      s(this, "SyncProvider");
    }
    constructor(e, r) {
      this._root = e, this._settings = r, this._reader = new Yx.default(this._root, this._settings);
    }
    read() {
      return this._reader.read();
    }
  };
  wn.default = bn;
});

// ../node_modules/@nodelib/fs.walk/out/settings.js
var Df = d((_n) => {
  "use strict";
  Object.defineProperty(_n, "__esModule", { value: !0 });
  var Kx = A("path"), Xx = yi(), vn = class {
    static {
      s(this, "Settings");
    }
    constructor(e = {}) {
      this._options = e, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency,
      Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.
      entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this.
      _options.pathSegmentSeparator, Kx.sep), this.fsScandirSettings = new Xx.Settings({
        followSymbolicLinks: this._options.followSymbolicLinks,
        fs: this._options.fs,
        pathSegmentSeparator: this._options.pathSegmentSeparator,
        stats: this._options.stats,
        throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
      });
    }
    _getValue(e, r) {
      return e ?? r;
    }
  };
  _n.default = vn;
});

// ../node_modules/@nodelib/fs.walk/out/index.js
var _i = d((je) => {
  "use strict";
  Object.defineProperty(je, "__esModule", { value: !0 });
  je.Settings = je.walkStream = je.walkSync = je.walk = void 0;
  var qf = Cf(), zx = Tf(), Jx = If(), xn = Df();
  je.Settings = xn.default;
  function Qx(t, e, r) {
    if (typeof e == "function") {
      new qf.default(t, vi()).read(e);
      return;
    }
    new qf.default(t, vi(e)).read(r);
  }
  s(Qx, "walk");
  je.walk = Qx;
  function Zx(t, e) {
    let r = vi(e);
    return new Jx.default(t, r).read();
  }
  s(Zx, "walkSync");
  je.walkSync = Zx;
  function eE(t, e) {
    let r = vi(e);
    return new zx.default(t, r).read();
  }
  s(eE, "walkStream");
  je.walkStream = eE;
  function vi(t = {}) {
    return t instanceof xn.default ? t : new xn.default(t);
  }
  s(vi, "getSettings");
});

// ../node_modules/fast-glob/out/readers/reader.js
var xi = d((Pn) => {
  "use strict";
  Object.defineProperty(Pn, "__esModule", { value: !0 });
  var tE = A("path"), rE = At(), $f = Je(), En = class {
    static {
      s(this, "Reader");
    }
    constructor(e) {
      this._settings = e, this._fsStatSettings = new rE.Settings({
        followSymbolicLink: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
      });
    }
    _getFullEntryPath(e) {
      return tE.resolve(this._settings.cwd, e);
    }
    _makeEntry(e, r) {
      let i = {
        name: r,
        path: r,
        dirent: $f.fs.createDirentFromStats(r, e)
      };
      return this._settings.stats && (i.stats = e), i;
    }
    _isFatalError(e) {
      return !$f.errno.isEnoentCodeError(e) && !this._settings.suppressErrors;
    }
  };
  Pn.default = En;
});

// ../node_modules/fast-glob/out/readers/stream.js
var On = d((An) => {
  "use strict";
  Object.defineProperty(An, "__esModule", { value: !0 });
  var iE = A("stream"), sE = At(), nE = _i(), oE = xi(), Rn = class extends oE.default {
    static {
      s(this, "ReaderStream");
    }
    constructor() {
      super(...arguments), this._walkStream = nE.walkStream, this._stat = sE.stat;
    }
    dynamic(e, r) {
      return this._walkStream(e, r);
    }
    static(e, r) {
      let i = e.map(this._getFullEntryPath, this), n = new iE.PassThrough({ objectMode: !0 });
      n._write = (o, a, u) => this._getEntry(i[o], e[o], r).then((c) => {
        c !== null && r.entryFilter(c) && n.push(c), o === i.length - 1 && n.end(), u();
      }).catch(u);
      for (let o = 0; o < i.length; o++)
        n.write(o);
      return n;
    }
    _getEntry(e, r, i) {
      return this._getStat(e).then((n) => this._makeEntry(n, r)).catch((n) => {
        if (i.errorFilter(n))
          return null;
        throw n;
      });
    }
    _getStat(e) {
      return new Promise((r, i) => {
        this._stat(e, this._fsStatSettings, (n, o) => n === null ? r(o) : i(n));
      });
    }
  };
  An.default = Rn;
});

// ../node_modules/fast-glob/out/readers/async.js
var Ff = d((Tn) => {
  "use strict";
  Object.defineProperty(Tn, "__esModule", { value: !0 });
  var aE = _i(), uE = xi(), cE = On(), Cn = class extends uE.default {
    static {
      s(this, "ReaderAsync");
    }
    constructor() {
      super(...arguments), this._walkAsync = aE.walk, this._readerStream = new cE.default(this._settings);
    }
    dynamic(e, r) {
      return new Promise((i, n) => {
        this._walkAsync(e, r, (o, a) => {
          o === null ? i(a) : n(o);
        });
      });
    }
    async static(e, r) {
      let i = [], n = this._readerStream.static(e, r);
      return new Promise((o, a) => {
        n.once("error", a), n.on("data", (u) => i.push(u)), n.once("end", () => o(i));
      });
    }
  };
  Tn.default = Cn;
});

// ../node_modules/fast-glob/out/providers/matchers/matcher.js
var Nf = d((In) => {
  "use strict";
  Object.defineProperty(In, "__esModule", { value: !0 });
  var dr = Je(), kn = class {
    static {
      s(this, "Matcher");
    }
    constructor(e, r, i) {
      this._patterns = e, this._settings = r, this._micromatchOptions = i, this._storage = [], this._fillStorage();
    }
    _fillStorage() {
      for (let e of this._patterns) {
        let r = this._getPatternSegments(e), i = this._splitSegmentsIntoSections(r);
        this._storage.push({
          complete: i.length <= 1,
          pattern: e,
          segments: r,
          sections: i
        });
      }
    }
    _getPatternSegments(e) {
      return dr.pattern.getPatternParts(e, this._micromatchOptions).map((i) => dr.pattern.isDynamicPattern(i, this._settings) ? {
        dynamic: !0,
        pattern: i,
        patternRe: dr.pattern.makeRe(i, this._micromatchOptions)
      } : {
        dynamic: !1,
        pattern: i
      });
    }
    _splitSegmentsIntoSections(e) {
      return dr.array.splitWhen(e, (r) => r.dynamic && dr.pattern.hasGlobStar(r.pattern));
    }
  };
  In.default = kn;
});

// ../node_modules/fast-glob/out/providers/matchers/partial.js
var Mf = d((qn) => {
  "use strict";
  Object.defineProperty(qn, "__esModule", { value: !0 });
  var lE = Nf(), Dn = class extends lE.default {
    static {
      s(this, "PartialMatcher");
    }
    match(e) {
      let r = e.split("/"), i = r.length, n = this._storage.filter((o) => !o.complete || o.segments.length > i);
      for (let o of n) {
        let a = o.sections[0];
        if (!o.complete && i > a.length || r.every((c, h) => {
          let l = o.segments[h];
          return !!(l.dynamic && l.patternRe.test(c) || !l.dynamic && l.pattern === c);
        }))
          return !0;
      }
      return !1;
    }
  };
  qn.default = Dn;
});

// ../node_modules/fast-glob/out/providers/filters/deep.js
var Lf = d((Fn) => {
  "use strict";
  Object.defineProperty(Fn, "__esModule", { value: !0 });
  var Ei = Je(), hE = Mf(), $n = class {
    static {
      s(this, "DeepFilter");
    }
    constructor(e, r) {
      this._settings = e, this._micromatchOptions = r;
    }
    getFilter(e, r, i) {
      let n = this._getMatcher(r), o = this._getNegativePatternsRe(i);
      return (a) => this._filter(e, a, n, o);
    }
    _getMatcher(e) {
      return new hE.default(e, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(e) {
      let r = e.filter(Ei.pattern.isAffectDepthOfReadingPattern);
      return Ei.pattern.convertPatternsToRe(r, this._micromatchOptions);
    }
    _filter(e, r, i, n) {
      if (this._isSkippedByDeep(e, r.path) || this._isSkippedSymbolicLink(r))
        return !1;
      let o = Ei.path.removeLeadingDotSegment(r.path);
      return this._isSkippedByPositivePatterns(o, i) ? !1 : this._isSkippedByNegativePatterns(o, n);
    }
    _isSkippedByDeep(e, r) {
      return this._settings.deep === 1 / 0 ? !1 : this._getEntryLevel(e, r) >= this._settings.deep;
    }
    _getEntryLevel(e, r) {
      let i = r.split("/").length;
      if (e === "")
        return i;
      let n = e.split("/").length;
      return i - n;
    }
    _isSkippedSymbolicLink(e) {
      return !this._settings.followSymbolicLinks && e.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(e, r) {
      return !this._settings.baseNameMatch && !r.match(e);
    }
    _isSkippedByNegativePatterns(e, r) {
      return !Ei.pattern.matchAny(e, r);
    }
  };
  Fn.default = $n;
});

// ../node_modules/fast-glob/out/providers/filters/entry.js
var jf = d((Mn) => {
  "use strict";
  Object.defineProperty(Mn, "__esModule", { value: !0 });
  var Ot = Je(), Nn = class {
    static {
      s(this, "EntryFilter");
    }
    constructor(e, r) {
      this._settings = e, this._micromatchOptions = r, this.index = /* @__PURE__ */ new Map();
    }
    getFilter(e, r) {
      let i = Ot.pattern.convertPatternsToRe(e, this._micromatchOptions), n = Ot.pattern.convertPatternsToRe(r, Object.assign(Object.assign(
      {}, this._micromatchOptions), { dot: !0 }));
      return (o) => this._filter(o, i, n);
    }
    _filter(e, r, i) {
      let n = Ot.path.removeLeadingDotSegment(e.path);
      if (this._settings.unique && this._isDuplicateEntry(n) || this._onlyFileFilter(e) || this._onlyDirectoryFilter(e) || this._isSkippedByAbsoluteNegativePatterns(
      n, i))
        return !1;
      let o = e.dirent.isDirectory(), a = this._isMatchToPatterns(n, r, o) && !this._isMatchToPatterns(n, i, o);
      return this._settings.unique && a && this._createIndexRecord(n), a;
    }
    _isDuplicateEntry(e) {
      return this.index.has(e);
    }
    _createIndexRecord(e) {
      this.index.set(e, void 0);
    }
    _onlyFileFilter(e) {
      return this._settings.onlyFiles && !e.dirent.isFile();
    }
    _onlyDirectoryFilter(e) {
      return this._settings.onlyDirectories && !e.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(e, r) {
      if (!this._settings.absolute)
        return !1;
      let i = Ot.path.makeAbsolute(this._settings.cwd, e);
      return Ot.pattern.matchAny(i, r);
    }
    _isMatchToPatterns(e, r, i) {
      let n = Ot.pattern.matchAny(e, r);
      return !n && i ? Ot.pattern.matchAny(e + "/", r) : n;
    }
  };
  Mn.default = Nn;
});

// ../node_modules/fast-glob/out/providers/filters/error.js
var Hf = d((jn) => {
  "use strict";
  Object.defineProperty(jn, "__esModule", { value: !0 });
  var fE = Je(), Ln = class {
    static {
      s(this, "ErrorFilter");
    }
    constructor(e) {
      this._settings = e;
    }
    getFilter() {
      return (e) => this._isNonFatalError(e);
    }
    _isNonFatalError(e) {
      return fE.errno.isEnoentCodeError(e) || this._settings.suppressErrors;
    }
  };
  jn.default = Ln;
});

// ../node_modules/fast-glob/out/providers/transformers/entry.js
var Wf = d((Bn) => {
  "use strict";
  Object.defineProperty(Bn, "__esModule", { value: !0 });
  var Bf = Je(), Hn = class {
    static {
      s(this, "EntryTransformer");
    }
    constructor(e) {
      this._settings = e;
    }
    getTransformer() {
      return (e) => this._transform(e);
    }
    _transform(e) {
      let r = e.path;
      return this._settings.absolute && (r = Bf.path.makeAbsolute(this._settings.cwd, r), r = Bf.path.unixify(r)), this._settings.markDirectories &&
      e.dirent.isDirectory() && (r += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, e), { path: r }) : r;
    }
  };
  Bn.default = Hn;
});

// ../node_modules/fast-glob/out/providers/provider.js
var Pi = d((Gn) => {
  "use strict";
  Object.defineProperty(Gn, "__esModule", { value: !0 });
  var dE = A("path"), pE = Lf(), mE = jf(), gE = Hf(), yE = Wf(), Wn = class {
    static {
      s(this, "Provider");
    }
    constructor(e) {
      this._settings = e, this.errorFilter = new gE.default(this._settings), this.entryFilter = new mE.default(this._settings, this._getMicromatchOptions()),
      this.deepFilter = new pE.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new yE.default(this._settings);
    }
    _getRootDirectory(e) {
      return dE.resolve(this._settings.cwd, e.base);
    }
    _getReaderOptions(e) {
      let r = e.base === "." ? "" : e.base;
      return {
        basePath: r,
        pathSegmentSeparator: "/",
        concurrency: this._settings.concurrency,
        deepFilter: this.deepFilter.getFilter(r, e.positive, e.negative),
        entryFilter: this.entryFilter.getFilter(e.positive, e.negative),
        errorFilter: this.errorFilter.getFilter(),
        followSymbolicLinks: this._settings.followSymbolicLinks,
        fs: this._settings.fs,
        stats: this._settings.stats,
        throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
        transform: this.entryTransformer.getTransformer()
      };
    }
    _getMicromatchOptions() {
      return {
        dot: this._settings.dot,
        matchBase: this._settings.baseNameMatch,
        nobrace: !this._settings.braceExpansion,
        nocase: !this._settings.caseSensitiveMatch,
        noext: !this._settings.extglob,
        noglobstar: !this._settings.globstar,
        posix: !0,
        strictSlashes: !1
      };
    }
  };
  Gn.default = Wn;
});

// ../node_modules/fast-glob/out/providers/async.js
var Gf = d((Vn) => {
  "use strict";
  Object.defineProperty(Vn, "__esModule", { value: !0 });
  var SE = Ff(), bE = Pi(), Un = class extends bE.default {
    static {
      s(this, "ProviderAsync");
    }
    constructor() {
      super(...arguments), this._reader = new SE.default(this._settings);
    }
    async read(e) {
      let r = this._getRootDirectory(e), i = this._getReaderOptions(e);
      return (await this.api(r, e, i)).map((o) => i.transform(o));
    }
    api(e, r, i) {
      return r.dynamic ? this._reader.dynamic(e, i) : this._reader.static(r.patterns, i);
    }
  };
  Vn.default = Un;
});

// ../node_modules/fast-glob/out/providers/stream.js
var Uf = d((Kn) => {
  "use strict";
  Object.defineProperty(Kn, "__esModule", { value: !0 });
  var wE = A("stream"), vE = On(), _E = Pi(), Yn = class extends _E.default {
    static {
      s(this, "ProviderStream");
    }
    constructor() {
      super(...arguments), this._reader = new vE.default(this._settings);
    }
    read(e) {
      let r = this._getRootDirectory(e), i = this._getReaderOptions(e), n = this.api(r, e, i), o = new wE.Readable({ objectMode: !0, read: /* @__PURE__ */ s(
      () => {
      }, "read") });
      return n.once("error", (a) => o.emit("error", a)).on("data", (a) => o.emit("data", i.transform(a))).once("end", () => o.emit("end")), o.
      once("close", () => n.destroy()), o;
    }
    api(e, r, i) {
      return r.dynamic ? this._reader.dynamic(e, i) : this._reader.static(r.patterns, i);
    }
  };
  Kn.default = Yn;
});

// ../node_modules/fast-glob/out/readers/sync.js
var Vf = d((zn) => {
  "use strict";
  Object.defineProperty(zn, "__esModule", { value: !0 });
  var xE = At(), EE = _i(), PE = xi(), Xn = class extends PE.default {
    static {
      s(this, "ReaderSync");
    }
    constructor() {
      super(...arguments), this._walkSync = EE.walkSync, this._statSync = xE.statSync;
    }
    dynamic(e, r) {
      return this._walkSync(e, r);
    }
    static(e, r) {
      let i = [];
      for (let n of e) {
        let o = this._getFullEntryPath(n), a = this._getEntry(o, n, r);
        a === null || !r.entryFilter(a) || i.push(a);
      }
      return i;
    }
    _getEntry(e, r, i) {
      try {
        let n = this._getStat(e);
        return this._makeEntry(n, r);
      } catch (n) {
        if (i.errorFilter(n))
          return null;
        throw n;
      }
    }
    _getStat(e) {
      return this._statSync(e, this._fsStatSettings);
    }
  };
  zn.default = Xn;
});

// ../node_modules/fast-glob/out/providers/sync.js
var Yf = d((Qn) => {
  "use strict";
  Object.defineProperty(Qn, "__esModule", { value: !0 });
  var RE = Vf(), AE = Pi(), Jn = class extends AE.default {
    static {
      s(this, "ProviderSync");
    }
    constructor() {
      super(...arguments), this._reader = new RE.default(this._settings);
    }
    read(e) {
      let r = this._getRootDirectory(e), i = this._getReaderOptions(e);
      return this.api(r, e, i).map(i.transform);
    }
    api(e, r, i) {
      return r.dynamic ? this._reader.dynamic(e, i) : this._reader.static(r.patterns, i);
    }
  };
  Qn.default = Jn;
});

// ../node_modules/fast-glob/out/settings.js
var Kf = d((Bt) => {
  "use strict";
  Object.defineProperty(Bt, "__esModule", { value: !0 });
  Bt.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  var Ht = A("fs"), OE = A("os"), CE = Math.max(OE.cpus().length, 1);
  Bt.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: Ht.lstat,
    lstatSync: Ht.lstatSync,
    stat: Ht.stat,
    statSync: Ht.statSync,
    readdir: Ht.readdir,
    readdirSync: Ht.readdirSync
  };
  var Zn = class {
    static {
      s(this, "Settings");
    }
    constructor(e = {}) {
      this._options = e, this.absolute = this._getValue(this._options.absolute, !1), this.baseNameMatch = this._getValue(this._options.baseNameMatch,
      !1), this.braceExpansion = this._getValue(this._options.braceExpansion, !0), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch,
      !0), this.concurrency = this._getValue(this._options.concurrency, CE), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.
      deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, !1), this.extglob = this._getValue(this.
      _options.extglob, !0), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, !0), this.fs = this._getFileSystemMethods(
      this._options.fs), this.globstar = this._getValue(this._options.globstar, !0), this.ignore = this._getValue(this._options.ignore, []),
      this.markDirectories = this._getValue(this._options.markDirectories, !1), this.objectMode = this._getValue(this._options.objectMode, !1),
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, !1), this.onlyFiles = this._getValue(this._options.onlyFiles, !0),
      this.stats = this._getValue(this._options.stats, !1), this.suppressErrors = this._getValue(this._options.suppressErrors, !1), this.throwErrorOnBrokenSymbolicLink =
      this._getValue(this._options.throwErrorOnBrokenSymbolicLink, !1), this.unique = this._getValue(this._options.unique, !0), this.onlyDirectories &&
      (this.onlyFiles = !1), this.stats && (this.objectMode = !0), this.ignore = [].concat(this.ignore);
    }
    _getValue(e, r) {
      return e === void 0 ? r : e;
    }
    _getFileSystemMethods(e = {}) {
      return Object.assign(Object.assign({}, Bt.DEFAULT_FILE_SYSTEM_ADAPTER), e);
    }
  };
  Bt.default = Zn;
});

// ../node_modules/fast-glob/out/index.js
var io = d((Zk, zf) => {
  "use strict";
  var Xf = Xh(), TE = Gf(), kE = Uf(), IE = Yf(), eo = Kf(), Ee = Je();
  async function to(t, e) {
    Ie(t);
    let r = ro(t, TE.default, e), i = await Promise.all(r);
    return Ee.array.flatten(i);
  }
  s(to, "FastGlob");
  (function(t) {
    t.glob = t, t.globSync = e, t.globStream = r, t.async = t;
    function e(h, l) {
      Ie(h);
      let p = ro(h, IE.default, l);
      return Ee.array.flatten(p);
    }
    s(e, "sync"), t.sync = e;
    function r(h, l) {
      Ie(h);
      let p = ro(h, kE.default, l);
      return Ee.stream.merge(p);
    }
    s(r, "stream"), t.stream = r;
    function i(h, l) {
      Ie(h);
      let p = [].concat(h), f = new eo.default(l);
      return Xf.generate(p, f);
    }
    s(i, "generateTasks"), t.generateTasks = i;
    function n(h, l) {
      Ie(h);
      let p = new eo.default(l);
      return Ee.pattern.isDynamicPattern(h, p);
    }
    s(n, "isDynamicPattern"), t.isDynamicPattern = n;
    function o(h) {
      return Ie(h), Ee.path.escape(h);
    }
    s(o, "escapePath"), t.escapePath = o;
    function a(h) {
      return Ie(h), Ee.path.convertPathToPattern(h);
    }
    s(a, "convertPathToPattern"), t.convertPathToPattern = a;
    let u;
    (function(h) {
      function l(f) {
        return Ie(f), Ee.path.escapePosixPath(f);
      }
      s(l, "escapePath"), h.escapePath = l;
      function p(f) {
        return Ie(f), Ee.path.convertPosixPathToPattern(f);
      }
      s(p, "convertPathToPattern"), h.convertPathToPattern = p;
    })(u = t.posix || (t.posix = {}));
    let c;
    (function(h) {
      function l(f) {
        return Ie(f), Ee.path.escapeWindowsPath(f);
      }
      s(l, "escapePath"), h.escapePath = l;
      function p(f) {
        return Ie(f), Ee.path.convertWindowsPathToPattern(f);
      }
      s(p, "convertPathToPattern"), h.convertPathToPattern = p;
    })(c = t.win32 || (t.win32 = {}));
  })(to || (to = {}));
  function ro(t, e, r) {
    let i = [].concat(t), n = new eo.default(r), o = Xf.generate(i, n), a = new e(n);
    return o.map(a.read, a);
  }
  s(ro, "getWorks");
  function Ie(t) {
    if (![].concat(t).every((i) => Ee.string.isString(i) && !Ee.string.isEmpty(i)))
      throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
  s(Ie, "assertPatternsInput");
  zf.exports = to;
});

// ../node_modules/globby/node_modules/path-type/index.js
import DE, { promises as qE } from "fs";
async function so(t, e, r) {
  if (typeof r != "string")
    throw new TypeError(`Expected a string, got ${typeof r}`);
  try {
    return (await qE[t](r))[e]();
  } catch (i) {
    if (i.code === "ENOENT")
      return !1;
    throw i;
  }
}
function no(t, e, r) {
  if (typeof r != "string")
    throw new TypeError(`Expected a string, got ${typeof r}`);
  try {
    return DE[t](r)[e]();
  } catch (i) {
    if (i.code === "ENOENT")
      return !1;
    throw i;
  }
}
var rI, Jf, iI, sI, Qf, nI, Zf = Ye(() => {
  s(so, "isType");
  s(no, "isTypeSync");
  rI = so.bind(null, "stat", "isFile"), Jf = so.bind(null, "stat", "isDirectory"), iI = so.bind(null, "lstat", "isSymbolicLink"), sI = no.bind(
  null, "statSync", "isFile"), Qf = no.bind(null, "statSync", "isDirectory"), nI = no.bind(null, "lstatSync", "isSymbolicLink");
});

// ../node_modules/unicorn-magic/default.js
var ed = Ye(() => {
});

// ../node_modules/unicorn-magic/node.js
import { fileURLToPath as $E } from "node:url";
function pr(t) {
  return t instanceof URL ? $E(t) : t;
}
var oo = Ye(() => {
  ed();
  s(pr, "toPath");
});

// ../node_modules/ignore/index.js
var cd = d((pI, ud) => {
  function td(t) {
    return Array.isArray(t) ? t : [t];
  }
  s(td, "makeArray");
  var co = "", rd = " ", ao = "\\", FE = /^\s+$/, NE = /(?:[^\\]|^)\\$/, ME = /^\\!/, LE = /^\\#/, jE = /\r?\n/g, HE = /^\.*\/|^\.+$/, uo = "\
/", nd = "node-ignore";
  typeof Symbol < "u" && (nd = Symbol.for("node-ignore"));
  var id = nd, BE = /* @__PURE__ */ s((t, e, r) => Object.defineProperty(t, e, { value: r }), "define"), WE = /([0-z])-([0-z])/g, od = /* @__PURE__ */ s(
  () => !1, "RETURN_FALSE"), GE = /* @__PURE__ */ s((t) => t.replace(
    WE,
    (e, r, i) => r.charCodeAt(0) <= i.charCodeAt(0) ? e : co
  ), "sanitizeRange"), UE = /* @__PURE__ */ s((t) => {
    let { length: e } = t;
    return t.slice(0, e - e % 2);
  }, "cleanRangeBackSlash"), VE = [
    [
      // remove BOM
      // TODO:
      // Other similar zero-width characters?
      /^\uFEFF/,
      () => co
    ],
    // > Trailing spaces are ignored unless they are quoted with backslash ("\")
    [
      // (a\ ) -> (a )
      // (a  ) -> (a)
      // (a \ ) -> (a  )
      /\\?\s+$/,
      (t) => t.indexOf("\\") === 0 ? rd : co
    ],
    // replace (\ ) with ' '
    [
      /\\\s/g,
      () => rd
    ],
    // Escape metacharacters
    // which is written down by users but means special for regular expressions.
    // > There are 12 characters with special meanings:
    // > - the backslash \,
    // > - the caret ^,
    // > - the dollar sign $,
    // > - the period or dot .,
    // > - the vertical bar or pipe symbol |,
    // > - the question mark ?,
    // > - the asterisk or star *,
    // > - the plus sign +,
    // > - the opening parenthesis (,
    // > - the closing parenthesis ),
    // > - and the opening square bracket [,
    // > - the opening curly brace {,
    // > These special characters are often called "metacharacters".
    [
      /[\\$.|*+(){^]/g,
      (t) => `\\${t}`
    ],
    [
      // > a question mark (?) matches a single character
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    // leading slash
    [
      // > A leading slash matches the beginning of the pathname.
      // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
      // A leading slash matches the beginning of the pathname
      /^\//,
      () => "^"
    ],
    // replace special metacharacter slash after the leading slash
    [
      /\//g,
      () => "\\/"
    ],
    [
      // > A leading "**" followed by a slash means match in all directories.
      // > For example, "**/foo" matches file or directory "foo" anywhere,
      // > the same as pattern "foo".
      // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
      // >   under directory "foo".
      // Notice that the '*'s have been replaced as '\\*'
      /^\^*\\\*\\\*\\\//,
      // '**/foo' <-> 'foo'
      () => "^(?:.*\\/)?"
    ],
    // starting
    [
      // there will be no leading '/'
      //   (which has been replaced by section "leading slash")
      // If starts with '**', adding a '^' to the regular expression also works
      /^(?=[^^])/,
      /* @__PURE__ */ s(function() {
        return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
      }, "startingReplacer")
    ],
    // two globstars
    [
      // Use lookahead assertions so that we could match more than one `'/**'`
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      // Zero, one or several directories
      // should not use '*', or it will be replaced by the next replacer
      // Check if it is not the last `'/**'`
      (t, e, r) => e + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    // normal intermediate wildcards
    [
      // Never replace escaped '*'
      // ignore rule '\*' will match the path '*'
      // 'abc.*/' -> go
      // 'abc.*'  -> skip this rule,
      //    coz trailing single wildcard will be handed by [trailing wildcard]
      /(^|[^\\]+)(\\\*)+(?=.+)/g,
      // '*.js' matches '.js'
      // '*.js' doesn't match 'abc'
      (t, e, r) => {
        let i = r.replace(/\\\*/g, "[^\\/]*");
        return e + i;
      }
    ],
    [
      // unescape, revert step 3 except for back slash
      // For example, if a user escape a '\\*',
      // after step 3, the result will be '\\\\\\*'
      /\\\\\\(?=[$.|*+(){^])/g,
      () => ao
    ],
    [
      // '\\\\' -> '\\'
      /\\\\/g,
      () => ao
    ],
    [
      // > The range notation, e.g. [a-zA-Z],
      // > can be used to match one of the characters in a range.
      // `\` is escaped by step 3
      /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
      (t, e, r, i, n) => e === ao ? `\\[${r}${UE(i)}${n}` : n === "]" && i.length % 2 === 0 ? `[${GE(r)}${i}]` : "[]"
    ],
    // ending
    [
      // 'js' will not match 'js.'
      // 'ab' will not match 'abc'
      /(?:[^*])$/,
      // WTF!
      // https://git-scm.com/docs/gitignore
      // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
      // which re-fixes #24, #38
      // > If there is a separator at the end of the pattern then the pattern
      // > will only match directories, otherwise the pattern can match both
      // > files and directories.
      // 'js*' will not match 'a.js'
      // 'js/' will not match 'a.js'
      // 'js' will match 'a.js' and 'a.js/'
      (t) => /\/$/.test(t) ? `${t}$` : `${t}(?=$|\\/$)`
    ],
    // trailing wildcard
    [
      /(\^|\\\/)?\\\*$/,
      (t, e) => `${e ? `${e}[^/]+` : "[^/]*"}(?=$|\\/$)`
    ]
  ], sd = /* @__PURE__ */ Object.create(null), YE = /* @__PURE__ */ s((t, e) => {
    let r = sd[t];
    return r || (r = VE.reduce(
      (i, n) => i.replace(n[0], n[1].bind(t)),
      t
    ), sd[t] = r), e ? new RegExp(r, "i") : new RegExp(r);
  }, "makeRegex"), fo = /* @__PURE__ */ s((t) => typeof t == "string", "isString"), KE = /* @__PURE__ */ s((t) => t && fo(t) && !FE.test(t) &&
  !NE.test(t) && t.indexOf("#") !== 0, "checkPattern"), XE = /* @__PURE__ */ s((t) => t.split(jE), "splitPattern"), lo = class {
    static {
      s(this, "IgnoreRule");
    }
    constructor(e, r, i, n) {
      this.origin = e, this.pattern = r, this.negative = i, this.regex = n;
    }
  }, zE = /* @__PURE__ */ s((t, e) => {
    let r = t, i = !1;
    t.indexOf("!") === 0 && (i = !0, t = t.substr(1)), t = t.replace(ME, "!").replace(LE, "#");
    let n = YE(t, e);
    return new lo(
      r,
      t,
      i,
      n
    );
  }, "createRule"), JE = /* @__PURE__ */ s((t, e) => {
    throw new e(t);
  }, "throwError"), Qe = /* @__PURE__ */ s((t, e, r) => fo(t) ? t ? Qe.isNotRelative(t) ? r(
    `path should be a \`path.relative()\`d string, but got "${e}"`,
    RangeError
  ) : !0 : r("path must not be empty", TypeError) : r(
    `path must be a string, but got \`${e}\``,
    TypeError
  ), "checkPath"), ad = /* @__PURE__ */ s((t) => HE.test(t), "isNotRelative");
  Qe.isNotRelative = ad;
  Qe.convert = (t) => t;
  var ho = class {
    static {
      s(this, "Ignore");
    }
    constructor({
      ignorecase: e = !0,
      ignoreCase: r = e,
      allowRelativePaths: i = !1
    } = {}) {
      BE(this, id, !0), this._rules = [], this._ignoreCase = r, this._allowRelativePaths = i, this._initCache();
    }
    _initCache() {
      this._ignoreCache = /* @__PURE__ */ Object.create(null), this._testCache = /* @__PURE__ */ Object.create(null);
    }
    _addPattern(e) {
      if (e && e[id]) {
        this._rules = this._rules.concat(e._rules), this._added = !0;
        return;
      }
      if (KE(e)) {
        let r = zE(e, this._ignoreCase);
        this._added = !0, this._rules.push(r);
      }
    }
    // @param {Array<string> | string | Ignore} pattern
    add(e) {
      return this._added = !1, td(
        fo(e) ? XE(e) : e
      ).forEach(this._addPattern, this), this._added && this._initCache(), this;
    }
    // legacy
    addPattern(e) {
      return this.add(e);
    }
    //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param {boolean} whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns {TestResult} true if a file is ignored
    _testOne(e, r) {
      let i = !1, n = !1;
      return this._rules.forEach((o) => {
        let { negative: a } = o;
        if (n === a && i !== n || a && !i && !n && !r)
          return;
        o.regex.test(e) && (i = !a, n = a);
      }), {
        ignored: i,
        unignored: n
      };
    }
    // @returns {TestResult}
    _test(e, r, i, n) {
      let o = e && Qe.convert(e);
      return Qe(
        o,
        e,
        this._allowRelativePaths ? od : JE
      ), this._t(o, r, i, n);
    }
    _t(e, r, i, n) {
      if (e in r)
        return r[e];
      if (n || (n = e.split(uo)), n.pop(), !n.length)
        return r[e] = this._testOne(e, i);
      let o = this._t(
        n.join(uo) + uo,
        r,
        i,
        n
      );
      return r[e] = o.ignored ? o : this._testOne(e, i);
    }
    ignores(e) {
      return this._test(e, this._ignoreCache, !1).ignored;
    }
    createFilter() {
      return (e) => !this.ignores(e);
    }
    filter(e) {
      return td(e).filter(this.createFilter());
    }
    // @returns {TestResult}
    test(e) {
      return this._test(e, this._testCache, !0);
    }
  }, Ri = /* @__PURE__ */ s((t) => new ho(t), "factory"), QE = /* @__PURE__ */ s((t) => Qe(t && Qe.convert(t), t, od), "isPathValid");
  Ri.isPathValid = QE;
  Ri.default = Ri;
  ud.exports = Ri;
  if (
    // Detect `process` so that it can run in browsers.
    typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
  ) {
    let t = /* @__PURE__ */ s((r) => /^\\\\\?\\/.test(r) || /["<>|\u0000-\u001F]+/u.test(r) ? r : r.replace(/\\/g, "/"), "makePosix");
    Qe.convert = t;
    let e = /^[a-z]:\//i;
    Qe.isNotRelative = (r) => e.test(r) || ad(r);
  }
});

// ../node_modules/slash/index.js
function Wt(t) {
  return t.startsWith("\\\\?\\") ? t : t.replace(/\\/g, "/");
}
var ld = Ye(() => {
  s(Wt, "slash");
});

// ../node_modules/globby/utilities.js
var mr, po = Ye(() => {
  mr = /* @__PURE__ */ s((t) => t[0] === "!", "isNegativePattern");
});

// ../node_modules/globby/ignore.js
import ZE from "node:process";
import eP from "node:fs";
import tP from "node:fs/promises";
import Gt from "node:path";
var mo, hd, rP, fd, Ai, iP, sP, nP, dd, pd, go, yo, md, gd, So = Ye(() => {
  mo = Oe(io(), 1), hd = Oe(cd(), 1);
  ld();
  oo();
  po();
  rP = [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ], fd = {
    absolute: !0,
    dot: !0
  }, Ai = "**/.gitignore", iP = /* @__PURE__ */ s((t, e) => mr(t) ? "!" + Gt.posix.join(e, t.slice(1)) : Gt.posix.join(e, t), "applyBaseToPa\
ttern"), sP = /* @__PURE__ */ s((t, e) => {
    let r = Wt(Gt.relative(e, Gt.dirname(t.filePath)));
    return t.content.split(/\r?\n/).filter((i) => i && !i.startsWith("#")).map((i) => iP(i, r));
  }, "parseIgnoreFile"), nP = /* @__PURE__ */ s((t, e) => {
    if (e = Wt(e), Gt.isAbsolute(t)) {
      if (Wt(t).startsWith(e))
        return Gt.relative(e, t);
      throw new Error(`Path ${t} is not in cwd ${e}`);
    }
    return t;
  }, "toRelativePath"), dd = /* @__PURE__ */ s((t, e) => {
    let r = t.flatMap((n) => sP(n, e)), i = (0, hd.default)().add(r);
    return (n) => (n = pr(n), n = nP(n, e), n ? i.ignores(Wt(n)) : !1);
  }, "getIsIgnoredPredicate"), pd = /* @__PURE__ */ s((t = {}) => ({
    cwd: pr(t.cwd) ?? ZE.cwd(),
    suppressErrors: !!t.suppressErrors,
    deep: typeof t.deep == "number" ? t.deep : Number.POSITIVE_INFINITY,
    ignore: [...t.ignore ?? [], ...rP]
  }), "normalizeOptions"), go = /* @__PURE__ */ s(async (t, e) => {
    let { cwd: r, suppressErrors: i, deep: n, ignore: o } = pd(e), a = await (0, mo.default)(t, {
      cwd: r,
      suppressErrors: i,
      deep: n,
      ignore: o,
      ...fd
    }), u = await Promise.all(
      a.map(async (c) => ({
        filePath: c,
        content: await tP.readFile(c, "utf8")
      }))
    );
    return dd(u, r);
  }, "isIgnoredByIgnoreFiles"), yo = /* @__PURE__ */ s((t, e) => {
    let { cwd: r, suppressErrors: i, deep: n, ignore: o } = pd(e), u = mo.default.sync(t, {
      cwd: r,
      suppressErrors: i,
      deep: n,
      ignore: o,
      ...fd
    }).map((c) => ({
      filePath: c,
      content: eP.readFileSync(c, "utf8")
    }));
    return dd(u, r);
  }, "isIgnoredByIgnoreFilesSync"), md = /* @__PURE__ */ s((t) => go(Ai, t), "isGitIgnored"), gd = /* @__PURE__ */ s((t) => yo(Ai, t), "isGi\
tIgnoredSync");
});

// ../node_modules/globby/index.js
var kd = {};
Wa(kd, {
  convertPathToPattern: () => gP,
  generateGlobTasks: () => pP,
  generateGlobTasksSync: () => mP,
  globby: () => lP,
  globbyStream: () => fP,
  globbySync: () => hP,
  isDynamicPattern: () => dP,
  isGitIgnored: () => md,
  isGitIgnoredSync: () => gd
});
import bd from "node:process";
import oP from "node:fs";
import Ut from "node:path";
var Vt, aP, wd, vd, yd, Sd, bo, uP, _d, xd, Oi, Ed, cP, Pd, Rd, Ad, Od, Cd, Td, wo, lP, hP, fP, dP, pP, mP, gP, Id = Ye(() => {
  cl();
  Vt = Oe(io(), 1);
  Zf();
  oo();
  So();
  po();
  So();
  aP = /* @__PURE__ */ s((t) => {
    if (t.some((e) => typeof e != "string"))
      throw new TypeError("Patterns must be a string or an array of strings");
  }, "assertPatternsInput"), wd = /* @__PURE__ */ s((t, e) => {
    let r = mr(t) ? t.slice(1) : t;
    return Ut.isAbsolute(r) ? r : Ut.join(e, r);
  }, "normalizePathForDirectoryGlob"), vd = /* @__PURE__ */ s(({ directoryPath: t, files: e, extensions: r }) => {
    let i = r?.length > 0 ? `.${r.length > 1 ? `{${r.join(",")}}` : r[0]}` : "";
    return e ? e.map((n) => Ut.posix.join(t, `**/${Ut.extname(n) ? n : `${n}${i}`}`)) : [Ut.posix.join(t, `**${i ? `/*${i}` : ""}`)];
  }, "getDirectoryGlob"), yd = /* @__PURE__ */ s(async (t, {
    cwd: e = bd.cwd(),
    files: r,
    extensions: i
  } = {}) => (await Promise.all(
    t.map(async (o) => await Jf(wd(o, e)) ? vd({ directoryPath: o, files: r, extensions: i }) : o)
  )).flat(), "directoryToGlob"), Sd = /* @__PURE__ */ s((t, {
    cwd: e = bd.cwd(),
    files: r,
    extensions: i
  } = {}) => t.flatMap((n) => Qf(wd(n, e)) ? vd({ directoryPath: n, files: r, extensions: i }) : n), "directoryToGlobSync"), bo = /* @__PURE__ */ s(
  (t) => (t = [...new Set([t].flat())], aP(t), t), "toPatternsArray"), uP = /* @__PURE__ */ s((t) => {
    if (!t)
      return;
    let e;
    try {
      e = oP.statSync(t);
    } catch {
      return;
    }
    if (!e.isDirectory())
      throw new Error("The `cwd` option must be a path to a directory");
  }, "checkCwdOption"), _d = /* @__PURE__ */ s((t = {}) => (t = {
    ...t,
    ignore: t.ignore ?? [],
    expandDirectories: t.expandDirectories ?? !0,
    cwd: pr(t.cwd)
  }, uP(t.cwd), t), "normalizeOptions"), xd = /* @__PURE__ */ s((t) => async (e, r) => t(bo(e), _d(r)), "normalizeArguments"), Oi = /* @__PURE__ */ s(
  (t) => (e, r) => t(bo(e), _d(r)), "normalizeArgumentsSync"), Ed = /* @__PURE__ */ s((t) => {
    let { ignoreFiles: e, gitignore: r } = t, i = e ? bo(e) : [];
    return r && i.push(Ai), i;
  }, "getIgnoreFilesPatterns"), cP = /* @__PURE__ */ s(async (t) => {
    let e = Ed(t);
    return Rd(
      e.length > 0 && await go(e, t)
    );
  }, "getFilter"), Pd = /* @__PURE__ */ s((t) => {
    let e = Ed(t);
    return Rd(
      e.length > 0 && yo(e, t)
    );
  }, "getFilterSync"), Rd = /* @__PURE__ */ s((t) => {
    let e = /* @__PURE__ */ new Set();
    return (r) => {
      let i = Ut.normalize(r.path ?? r);
      return e.has(i) || t && t(i) ? !1 : (e.add(i), !0);
    };
  }, "createFilterFunction"), Ad = /* @__PURE__ */ s((t, e) => t.flat().filter((r) => e(r)), "unionFastGlobResults"), Od = /* @__PURE__ */ s(
  (t, e) => {
    let r = [];
    for (; t.length > 0; ) {
      let i = t.findIndex((o) => mr(o));
      if (i === -1) {
        r.push({ patterns: t, options: e });
        break;
      }
      let n = t[i].slice(1);
      for (let o of r)
        o.options.ignore.push(n);
      i !== 0 && r.push({
        patterns: t.slice(0, i),
        options: {
          ...e,
          ignore: [
            ...e.ignore,
            n
          ]
        }
      }), t = t.slice(i + 1);
    }
    return r;
  }, "convertNegativePatterns"), Cd = /* @__PURE__ */ s((t, e) => ({
    ...e ? { cwd: e } : {},
    ...Array.isArray(t) ? { files: t } : t
  }), "normalizeExpandDirectoriesOption"), Td = /* @__PURE__ */ s(async (t, e) => {
    let r = Od(t, e), { cwd: i, expandDirectories: n } = e;
    if (!n)
      return r;
    let o = Cd(n, i);
    return Promise.all(
      r.map(async (a) => {
        let { patterns: u, options: c } = a;
        return [
          u,
          c.ignore
        ] = await Promise.all([
          yd(u, o),
          yd(c.ignore, { cwd: i })
        ]), { patterns: u, options: c };
      })
    );
  }, "generateTasks"), wo = /* @__PURE__ */ s((t, e) => {
    let r = Od(t, e), { cwd: i, expandDirectories: n } = e;
    if (!n)
      return r;
    let o = Cd(n, i);
    return r.map((a) => {
      let { patterns: u, options: c } = a;
      return u = Sd(u, o), c.ignore = Sd(c.ignore, { cwd: i }), { patterns: u, options: c };
    });
  }, "generateTasksSync"), lP = xd(async (t, e) => {
    let [
      r,
      i
    ] = await Promise.all([
      Td(t, e),
      cP(e)
    ]), n = await Promise.all(r.map((o) => (0, Vt.default)(o.patterns, o.options)));
    return Ad(n, i);
  }), hP = Oi((t, e) => {
    let r = wo(t, e), i = Pd(e), n = r.map((o) => Vt.default.sync(o.patterns, o.options));
    return Ad(n, i);
  }), fP = Oi((t, e) => {
    let r = wo(t, e), i = Pd(e), n = r.map((a) => Vt.default.stream(a.patterns, a.options));
    return Ss(n).filter((a) => i(a));
  }), dP = Oi(
    (t, e) => t.some((r) => Vt.default.isDynamicPattern(r, e))
  ), pP = xd(Td), mP = Oi(wo), { convertPathToPattern: gP } = Vt.default;
});

// ../node_modules/prompts/node_modules/kleur/index.js
var Q = d((iq, ap) => {
  "use strict";
  var { FORCE_COLOR: uR, NODE_DISABLE_COLORS: cR, TERM: lR } = process.env, B = {
    enabled: !cR && lR !== "dumb" && uR !== "0",
    // modifiers
    reset: G(0, 0),
    bold: G(1, 22),
    dim: G(2, 22),
    italic: G(3, 23),
    underline: G(4, 24),
    inverse: G(7, 27),
    hidden: G(8, 28),
    strikethrough: G(9, 29),
    // colors
    black: G(30, 39),
    red: G(31, 39),
    green: G(32, 39),
    yellow: G(33, 39),
    blue: G(34, 39),
    magenta: G(35, 39),
    cyan: G(36, 39),
    white: G(37, 39),
    gray: G(90, 39),
    grey: G(90, 39),
    // background colors
    bgBlack: G(40, 49),
    bgRed: G(41, 49),
    bgGreen: G(42, 49),
    bgYellow: G(43, 49),
    bgBlue: G(44, 49),
    bgMagenta: G(45, 49),
    bgCyan: G(46, 49),
    bgWhite: G(47, 49)
  };
  function op(t, e) {
    let r = 0, i, n = "", o = "";
    for (; r < t.length; r++)
      i = t[r], n += i.open, o += i.close, e.includes(i.close) && (e = e.replace(i.rgx, i.close + i.open));
    return n + e + o;
  }
  s(op, "run");
  function hR(t, e) {
    let r = { has: t, keys: e };
    return r.reset = B.reset.bind(r), r.bold = B.bold.bind(r), r.dim = B.dim.bind(r), r.italic = B.italic.bind(r), r.underline = B.underline.
    bind(r), r.inverse = B.inverse.bind(r), r.hidden = B.hidden.bind(r), r.strikethrough = B.strikethrough.bind(r), r.black = B.black.bind(r),
    r.red = B.red.bind(r), r.green = B.green.bind(r), r.yellow = B.yellow.bind(r), r.blue = B.blue.bind(r), r.magenta = B.magenta.bind(r), r.
    cyan = B.cyan.bind(r), r.white = B.white.bind(r), r.gray = B.gray.bind(r), r.grey = B.grey.bind(r), r.bgBlack = B.bgBlack.bind(r), r.bgRed =
    B.bgRed.bind(r), r.bgGreen = B.bgGreen.bind(r), r.bgYellow = B.bgYellow.bind(r), r.bgBlue = B.bgBlue.bind(r), r.bgMagenta = B.bgMagenta.
    bind(r), r.bgCyan = B.bgCyan.bind(r), r.bgWhite = B.bgWhite.bind(r), r;
  }
  s(hR, "chain");
  function G(t, e) {
    let r = {
      open: `\x1B[${t}m`,
      close: `\x1B[${e}m`,
      rgx: new RegExp(`\\x1b\\[${e}m`, "g")
    };
    return function(i) {
      return this !== void 0 && this.has !== void 0 ? (this.has.includes(t) || (this.has.push(t), this.keys.push(r)), i === void 0 ? this : B.
      enabled ? op(this.keys, i + "") : i + "") : i === void 0 ? hR([t], [r]) : B.enabled ? op([r], i + "") : i + "";
    };
  }
  s(G, "init");
  ap.exports = B;
});

// ../node_modules/prompts/dist/util/action.js
var cp = d((nq, up) => {
  "use strict";
  up.exports = (t, e) => {
    if (!(t.meta && t.name !== "escape")) {
      if (t.ctrl) {
        if (t.name === "a") return "first";
        if (t.name === "c" || t.name === "d") return "abort";
        if (t.name === "e") return "last";
        if (t.name === "g") return "reset";
      }
      if (e) {
        if (t.name === "j") return "down";
        if (t.name === "k") return "up";
      }
      return t.name === "return" || t.name === "enter" ? "submit" : t.name === "backspace" ? "delete" : t.name === "delete" ? "deleteForward" :
      t.name === "abort" ? "abort" : t.name === "escape" ? "exit" : t.name === "tab" ? "next" : t.name === "pagedown" ? "nextPage" : t.name ===
      "pageup" ? "prevPage" : t.name === "home" ? "home" : t.name === "end" ? "end" : t.name === "up" ? "up" : t.name === "down" ? "down" : t.
      name === "right" ? "right" : t.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/dist/util/strip.js
var Ii = d((oq, lp) => {
  "use strict";
  lp.exports = (t) => {
    let e = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|"), r = new RegExp(e, "g");
    return typeof t == "string" ? t.replace(r, "") : t;
  };
});

// ../node_modules/sisteransi/src/index.js
var ee = d((aq, hp) => {
  "use strict";
  var Co = "\x1B", Z = `${Co}[`, fR = "\x07", To = {
    to(t, e) {
      return e ? `${Z}${e + 1};${t + 1}H` : `${Z}${t + 1}G`;
    },
    move(t, e) {
      let r = "";
      return t < 0 ? r += `${Z}${-t}D` : t > 0 && (r += `${Z}${t}C`), e < 0 ? r += `${Z}${-e}A` : e > 0 && (r += `${Z}${e}B`), r;
    },
    up: /* @__PURE__ */ s((t = 1) => `${Z}${t}A`, "up"),
    down: /* @__PURE__ */ s((t = 1) => `${Z}${t}B`, "down"),
    forward: /* @__PURE__ */ s((t = 1) => `${Z}${t}C`, "forward"),
    backward: /* @__PURE__ */ s((t = 1) => `${Z}${t}D`, "backward"),
    nextLine: /* @__PURE__ */ s((t = 1) => `${Z}E`.repeat(t), "nextLine"),
    prevLine: /* @__PURE__ */ s((t = 1) => `${Z}F`.repeat(t), "prevLine"),
    left: `${Z}G`,
    hide: `${Z}?25l`,
    show: `${Z}?25h`,
    save: `${Co}7`,
    restore: `${Co}8`
  }, dR = {
    up: /* @__PURE__ */ s((t = 1) => `${Z}S`.repeat(t), "up"),
    down: /* @__PURE__ */ s((t = 1) => `${Z}T`.repeat(t), "down")
  }, pR = {
    screen: `${Z}2J`,
    up: /* @__PURE__ */ s((t = 1) => `${Z}1J`.repeat(t), "up"),
    down: /* @__PURE__ */ s((t = 1) => `${Z}J`.repeat(t), "down"),
    line: `${Z}2K`,
    lineEnd: `${Z}K`,
    lineStart: `${Z}1K`,
    lines(t) {
      let e = "";
      for (let r = 0; r < t; r++)
        e += this.line + (r < t - 1 ? To.up() : "");
      return t && (e += To.left), e;
    }
  };
  hp.exports = { cursor: To, scroll: dR, erase: pR, beep: fR };
});

// ../node_modules/prompts/dist/util/clear.js
var gp = d((cq, mp) => {
  "use strict";
  function mR(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (!r) {
      if (Array.isArray(t) || (r = gR(t)) || e && t && typeof t.length == "number") {
        r && (t = r);
        var i = 0, n = /* @__PURE__ */ s(function() {
        }, "F");
        return { s: n, n: /* @__PURE__ */ s(function() {
          return i >= t.length ? { done: !0 } : { done: !1, value: t[i++] };
        }, "n"), e: /* @__PURE__ */ s(function(h) {
          throw h;
        }, "e"), f: n };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var o = !0, a = !1, u;
    return { s: /* @__PURE__ */ s(function() {
      r = r.call(t);
    }, "s"), n: /* @__PURE__ */ s(function() {
      var h = r.next();
      return o = h.done, h;
    }, "n"), e: /* @__PURE__ */ s(function(h) {
      a = !0, u = h;
    }, "e"), f: /* @__PURE__ */ s(function() {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (a) throw u;
      }
    }, "f") };
  }
  s(mR, "_createForOfIteratorHelper");
  function gR(t, e) {
    if (t) {
      if (typeof t == "string") return fp(t, e);
      var r = Object.prototype.toString.call(t).slice(8, -1);
      if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return fp(t, e);
    }
  }
  s(gR, "_unsupportedIterableToArray");
  function fp(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, i = new Array(e); r < e; r++) i[r] = t[r];
    return i;
  }
  s(fp, "_arrayLikeToArray");
  var yR = Ii(), pp = ee(), dp = pp.erase, SR = pp.cursor, bR = /* @__PURE__ */ s((t) => [...yR(t)].length, "width");
  mp.exports = function(t, e) {
    if (!e) return dp.line + SR.to(0);
    let r = 0, i = t.split(/\r?\n/);
    var n = mR(i), o;
    try {
      for (n.s(); !(o = n.n()).done; ) {
        let a = o.value;
        r += 1 + Math.floor(Math.max(bR(a) - 1, 0) / e);
      }
    } catch (a) {
      n.e(a);
    } finally {
      n.f();
    }
    return dp.lines(r);
  };
});

// ../node_modules/prompts/dist/util/figures.js
var ko = d((hq, yp) => {
  "use strict";
  var br = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, wR = {
    arrowUp: br.arrowUp,
    arrowDown: br.arrowDown,
    arrowLeft: br.arrowLeft,
    arrowRight: br.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, vR = process.platform === "win32" ? wR : br;
  yp.exports = vR;
});

// ../node_modules/prompts/dist/util/style.js
var bp = d((fq, Sp) => {
  "use strict";
  var Xt = Q(), Ct = ko(), Io = Object.freeze({
    password: {
      scale: 1,
      render: /* @__PURE__ */ s((t) => "*".repeat(t.length), "render")
    },
    emoji: {
      scale: 2,
      render: /* @__PURE__ */ s((t) => "\u{1F603}".repeat(t.length), "render")
    },
    invisible: {
      scale: 0,
      render: /* @__PURE__ */ s((t) => "", "render")
    },
    default: {
      scale: 1,
      render: /* @__PURE__ */ s((t) => `${t}`, "render")
    }
  }), _R = /* @__PURE__ */ s((t) => Io[t] || Io.default, "render"), wr = Object.freeze({
    aborted: Xt.red(Ct.cross),
    done: Xt.green(Ct.tick),
    exited: Xt.yellow(Ct.cross),
    default: Xt.cyan("?")
  }), xR = /* @__PURE__ */ s((t, e, r) => e ? wr.aborted : r ? wr.exited : t ? wr.done : wr.default, "symbol"), ER = /* @__PURE__ */ s((t) => Xt.
  gray(t ? Ct.ellipsis : Ct.pointerSmall), "delimiter"), PR = /* @__PURE__ */ s((t, e) => Xt.gray(t ? e ? Ct.pointerSmall : "+" : Ct.line), "\
item");
  Sp.exports = {
    styles: Io,
    render: _R,
    symbols: wr,
    symbol: xR,
    delimiter: ER,
    item: PR
  };
});

// ../node_modules/prompts/dist/util/lines.js
var vp = d((pq, wp) => {
  "use strict";
  var RR = Ii();
  wp.exports = function(t, e) {
    let r = String(RR(t) || "").split(/\r?\n/);
    return e ? r.map((i) => Math.ceil(i.length / e)).reduce((i, n) => i + n) : r.length;
  };
});

// ../node_modules/prompts/dist/util/wrap.js
var xp = d((mq, _p) => {
  "use strict";
  _p.exports = (t, e = {}) => {
    let r = Number.isSafeInteger(parseInt(e.margin)) ? new Array(parseInt(e.margin)).fill(" ").join("") : e.margin || "", i = e.width;
    return (t || "").split(/\r?\n/g).map((n) => n.split(/\s+/g).reduce((o, a) => (a.length + r.length >= i || o[o.length - 1].length + a.length +
    1 < i ? o[o.length - 1] += ` ${a}` : o.push(`${r}${a}`), o), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/dist/util/entriesToDisplay.js
var Pp = d((gq, Ep) => {
  "use strict";
  Ep.exports = (t, e, r) => {
    r = r || e;
    let i = Math.min(e - r, t - Math.floor(r / 2));
    i < 0 && (i = 0);
    let n = Math.min(i + r, e);
    return {
      startIndex: i,
      endIndex: n
    };
  };
});

// ../node_modules/prompts/dist/util/index.js
var qe = d((yq, Rp) => {
  "use strict";
  Rp.exports = {
    action: cp(),
    clear: gp(),
    style: bp(),
    strip: Ii(),
    figures: ko(),
    lines: vp(),
    wrap: xp(),
    entriesToDisplay: Pp()
  };
});

// ../node_modules/prompts/dist/elements/prompt.js
var et = d((Sq, Cp) => {
  "use strict";
  var Ap = A("readline"), AR = qe(), OR = AR.action, CR = A("events"), Op = ee(), TR = Op.beep, kR = Op.cursor, IR = Q(), Do = class extends CR {
    static {
      s(this, "Prompt");
    }
    constructor(e = {}) {
      super(), this.firstRender = !0, this.in = e.stdin || process.stdin, this.out = e.stdout || process.stdout, this.onRender = (e.onRender ||
      (() => {
      })).bind(this);
      let r = Ap.createInterface({
        input: this.in,
        escapeCodeTimeout: 50
      });
      Ap.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let i = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, n = /* @__PURE__ */ s((o, a) => {
        let u = OR(a, i);
        u === !1 ? this._ && this._(o, a) : typeof this[u] == "function" ? this[u](a) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(kR.show), this.in.removeListener("keypress", n), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", n);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(TR);
    }
    render() {
      this.onRender(IR), this.firstRender && (this.firstRender = !1);
    }
  };
  Cp.exports = Do;
});

// ../node_modules/prompts/dist/elements/text.js
var qp = d((wq, Dp) => {
  "use strict";
  function Tp(t, e, r, i, n, o, a) {
    try {
      var u = t[o](a), c = u.value;
    } catch (h) {
      r(h);
      return;
    }
    u.done ? e(c) : Promise.resolve(c).then(i, n);
  }
  s(Tp, "asyncGeneratorStep");
  function kp(t) {
    return function() {
      var e = this, r = arguments;
      return new Promise(function(i, n) {
        var o = t.apply(e, r);
        function a(c) {
          Tp(o, i, n, a, u, "next", c);
        }
        s(a, "_next");
        function u(c) {
          Tp(o, i, n, a, u, "throw", c);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(kp, "_asyncToGenerator");
  var Di = Q(), DR = et(), Ip = ee(), qR = Ip.erase, vr = Ip.cursor, qi = qe(), qo = qi.style, $o = qi.clear, $R = qi.lines, FR = qi.figures,
  Fo = class extends DR {
    static {
      s(this, "TextPrompt");
    }
    constructor(e = {}) {
      super(e), this.transform = qo.render(e.style), this.scale = this.transform.scale, this.msg = e.message, this.initial = e.initial || "",
      this.validator = e.validate || (() => !0), this.value = "", this.errorMsg = e.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = $o("", this.out.columns), this.render();
    }
    set value(e) {
      !e && this.initial ? (this.placeholder = !0, this.rendered = Di.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(e)), this._value = e, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    validate() {
      var e = this;
      return kp(function* () {
        let r = yield e.validator(e.value);
        typeof r == "string" && (e.errorMsg = r, r = !1), e.error = !r;
      })();
    }
    submit() {
      var e = this;
      return kp(function* () {
        if (e.value = e.value || e.initial, e.cursorOffset = 0, e.cursor = e.rendered.length, yield e.validate(), e.error) {
          e.red = !0, e.fire(), e.render();
          return;
        }
        e.done = !0, e.aborted = !1, e.fire(), e.render(), e.out.write(`
`), e.close();
      })();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(e) {
      this.placeholder || (this.cursor = this.cursor + e, this.cursorOffset += e);
    }
    _(e, r) {
      let i = this.value.slice(0, this.cursor), n = this.value.slice(this.cursor);
      this.value = `${i}${e}${n}`, this.red = !1, this.cursor = this.placeholder ? 0 : i.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let e = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${e}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let e = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${e}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(vr.down($R(this.outputError, this.out.columns) - 1) + $o(this.
      outputError, this.out.columns)), this.out.write($o(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [qo.symbol(this.done, this.aborted), Di.bold(this.msg), qo.delimiter(this.done), this.red ? Di.red(this.rendered) : this.rendered].join(
      " "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((e, r, i) => e + `
${i ? " " : FR.pointerSmall} ${Di.red().italic(r)}`, "")), this.out.write(qR.line + vr.to(0) + this.outputText + vr.save + this.outputError +
      vr.restore + vr.move(this.cursorOffset, 0)));
    }
  };
  Dp.exports = Fo;
});

// ../node_modules/prompts/dist/elements/select.js
var Mp = d((_q, Np) => {
  "use strict";
  var tt = Q(), NR = et(), _r = qe(), $p = _r.style, Fp = _r.clear, $i = _r.figures, MR = _r.wrap, LR = _r.entriesToDisplay, jR = ee(), HR = jR.
  cursor, No = class extends NR {
    static {
      s(this, "SelectPrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.hint = e.hint || "- Use arrow-keys. Return to submit.", this.warn = e.warn || "- This option is d\
isabled", this.cursor = e.initial || 0, this.choices = e.choices.map((r, i) => (typeof r == "string" && (r = {
        title: r,
        value: i
      }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? i : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = e.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = Fp("", this.out.
      columns), this.render();
    }
    moveCursor(e) {
      this.cursor = e, this.value = this.choices[e].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(e, r) {
      if (e === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(HR.hide) : this.out.write(Fp(this.outputText, this.out.columns)), super.render();
      let e = LR(this.cursor, this.choices.length, this.optionsPerPage), r = e.startIndex, i = e.endIndex;
      if (this.outputText = [$p.symbol(this.done, this.aborted), tt.bold(this.msg), $p.delimiter(!1), this.done ? this.selection.title : this.
      selection.disabled ? tt.yellow(this.warn) : tt.gray(this.hint)].join(" "), !this.done) {
        this.outputText += `
`;
        for (let n = r; n < i; n++) {
          let o, a, u = "", c = this.choices[n];
          n === r && r > 0 ? a = $i.arrowUp : n === i - 1 && i < this.choices.length ? a = $i.arrowDown : a = " ", c.disabled ? (o = this.cursor ===
          n ? tt.gray().underline(c.title) : tt.strikethrough().gray(c.title), a = (this.cursor === n ? tt.bold().gray($i.pointer) + " " : "\
  ") + a) : (o = this.cursor === n ? tt.cyan().underline(c.title) : c.title, a = (this.cursor === n ? tt.cyan($i.pointer) + " " : "  ") + a,
          c.description && this.cursor === n && (u = ` - ${c.description}`, (a.length + o.length + u.length >= this.out.columns || c.description.
          split(/\r?\n/).length > 1) && (u = `
` + MR(c.description, {
            margin: 3,
            width: this.out.columns
          })))), this.outputText += `${a} ${o}${tt.gray(u)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  Np.exports = No;
});

// ../node_modules/prompts/dist/elements/toggle.js
var Gp = d((Eq, Wp) => {
  "use strict";
  var Fi = Q(), BR = et(), Hp = qe(), Lp = Hp.style, WR = Hp.clear, Bp = ee(), jp = Bp.cursor, GR = Bp.erase, Mo = class extends BR {
    static {
      s(this, "TogglePrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.value = !!e.initial, this.active = e.active || "on", this.inactive = e.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(e, r) {
      if (e === " ")
        this.value = !this.value;
      else if (e === "1")
        this.value = !0;
      else if (e === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(jp.hide) : this.out.write(WR(this.outputText, this.out.columns)), super.render(), this.
      outputText = [Lp.symbol(this.done, this.aborted), Fi.bold(this.msg), Lp.delimiter(this.done), this.value ? this.inactive : Fi.cyan().underline(
      this.inactive), Fi.gray("/"), this.value ? Fi.cyan().underline(this.active) : this.active].join(" "), this.out.write(GR.line + jp.to(0) +
      this.outputText));
    }
  };
  Wp.exports = Mo;
});

// ../node_modules/prompts/dist/dateparts/datepart.js
var He = d((Rq, Up) => {
  "use strict";
  var Lo = class t {
    static {
      s(this, "DatePart");
    }
    constructor({
      token: e,
      date: r,
      parts: i,
      locales: n
    }) {
      this.token = e, this.date = r || /* @__PURE__ */ new Date(), this.parts = i || [this], this.locales = n || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let e = this.parts.indexOf(this);
      return this.parts.find((r, i) => i > e && r instanceof t);
    }
    setTo(e) {
    }
    prev() {
      let e = [].concat(this.parts).reverse(), r = e.indexOf(this);
      return e.find((i, n) => n > r && i instanceof t);
    }
    toString() {
      return String(this.date);
    }
  };
  Up.exports = Lo;
});

// ../node_modules/prompts/dist/dateparts/meridiem.js
var Yp = d((Oq, Vp) => {
  "use strict";
  var UR = He(), jo = class extends UR {
    static {
      s(this, "Meridiem");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let e = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? e.toUpperCase() : e;
    }
  };
  Vp.exports = jo;
});

// ../node_modules/prompts/dist/dateparts/day.js
var Xp = d((Tq, Kp) => {
  "use strict";
  var VR = He(), YR = /* @__PURE__ */ s((t) => (t = t % 10, t === 1 ? "st" : t === 2 ? "nd" : t === 3 ? "rd" : "th"), "pos"), Ho = class extends VR {
    static {
      s(this, "Day");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(e) {
      this.date.setDate(parseInt(e.substr(-2)));
    }
    toString() {
      let e = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(e).padStart(2, "0") : this.token === "Do" ? e + YR(e) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : e;
    }
  };
  Kp.exports = Ho;
});

// ../node_modules/prompts/dist/dateparts/hours.js
var Jp = d((Iq, zp) => {
  "use strict";
  var KR = He(), Bo = class extends KR {
    static {
      s(this, "Hours");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(e) {
      this.date.setHours(parseInt(e.substr(-2)));
    }
    toString() {
      let e = this.date.getHours();
      return /h/.test(this.token) && (e = e % 12 || 12), this.token.length > 1 ? String(e).padStart(2, "0") : e;
    }
  };
  zp.exports = Bo;
});

// ../node_modules/prompts/dist/dateparts/milliseconds.js
var Zp = d((qq, Qp) => {
  "use strict";
  var XR = He(), Wo = class extends XR {
    static {
      s(this, "Milliseconds");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(e) {
      this.date.setMilliseconds(parseInt(e.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  Qp.exports = Wo;
});

// ../node_modules/prompts/dist/dateparts/minutes.js
var tm = d((Fq, em) => {
  "use strict";
  var zR = He(), Go = class extends zR {
    static {
      s(this, "Minutes");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(e) {
      this.date.setMinutes(parseInt(e.substr(-2)));
    }
    toString() {
      let e = this.date.getMinutes();
      return this.token.length > 1 ? String(e).padStart(2, "0") : e;
    }
  };
  em.exports = Go;
});

// ../node_modules/prompts/dist/dateparts/month.js
var im = d((Mq, rm) => {
  "use strict";
  var JR = He(), Uo = class extends JR {
    static {
      s(this, "Month");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(e) {
      e = parseInt(e.substr(-2)) - 1, this.date.setMonth(e < 0 ? 0 : e);
    }
    toString() {
      let e = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(e + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[e] : r === 4 ? this.locales.months[e] : String(e +
      1);
    }
  };
  rm.exports = Uo;
});

// ../node_modules/prompts/dist/dateparts/seconds.js
var nm = d((jq, sm) => {
  "use strict";
  var QR = He(), Vo = class extends QR {
    static {
      s(this, "Seconds");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(e) {
      this.date.setSeconds(parseInt(e.substr(-2)));
    }
    toString() {
      let e = this.date.getSeconds();
      return this.token.length > 1 ? String(e).padStart(2, "0") : e;
    }
  };
  sm.exports = Vo;
});

// ../node_modules/prompts/dist/dateparts/year.js
var am = d((Bq, om) => {
  "use strict";
  var ZR = He(), Yo = class extends ZR {
    static {
      s(this, "Year");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(e) {
      this.date.setFullYear(e.substr(-4));
    }
    toString() {
      let e = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? e.substr(-2) : e;
    }
  };
  om.exports = Yo;
});

// ../node_modules/prompts/dist/dateparts/index.js
var cm = d((Gq, um) => {
  "use strict";
  um.exports = {
    DatePart: He(),
    Meridiem: Yp(),
    Day: Xp(),
    Hours: Jp(),
    Milliseconds: Zp(),
    Minutes: tm(),
    Month: im(),
    Seconds: nm(),
    Year: am()
  };
});

// ../node_modules/prompts/dist/elements/date.js
var bm = d((Uq, Sm) => {
  "use strict";
  function lm(t, e, r, i, n, o, a) {
    try {
      var u = t[o](a), c = u.value;
    } catch (h) {
      r(h);
      return;
    }
    u.done ? e(c) : Promise.resolve(c).then(i, n);
  }
  s(lm, "asyncGeneratorStep");
  function hm(t) {
    return function() {
      var e = this, r = arguments;
      return new Promise(function(i, n) {
        var o = t.apply(e, r);
        function a(c) {
          lm(o, i, n, a, u, "next", c);
        }
        s(a, "_next");
        function u(c) {
          lm(o, i, n, a, u, "throw", c);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(hm, "_asyncToGenerator");
  var Ko = Q(), eA = et(), zo = qe(), fm = zo.style, dm = zo.clear, tA = zo.figures, ym = ee(), rA = ym.erase, pm = ym.cursor, rt = cm(), mm = rt.
  DatePart, iA = rt.Meridiem, sA = rt.Day, nA = rt.Hours, oA = rt.Milliseconds, aA = rt.Minutes, uA = rt.Month, cA = rt.Seconds, lA = rt.Year,
  hA = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, gm = {
    1: ({
      token: t
    }) => t.replace(/\\(.)/g, "$1"),
    2: (t) => new sA(t),
    // Day // TODO
    3: (t) => new uA(t),
    // Month
    4: (t) => new lA(t),
    // Year
    5: (t) => new iA(t),
    // AM/PM // TODO (special)
    6: (t) => new nA(t),
    // Hours
    7: (t) => new aA(t),
    // Minutes
    8: (t) => new cA(t),
    // Seconds
    9: (t) => new oA(t)
    // Fractional seconds
  }, fA = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, Xo = class extends eA {
    static {
      s(this, "DatePrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(fA, e.locales), this._date = e.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = e.error || "Please Enter A Valid Value", this.validator = e.validate || (() => !0), this.mask =
      e.mask || "YYYY-MM-DD HH:mm:ss", this.clear = dm("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(e) {
      e && this._date.setTime(e.getTime());
    }
    set mask(e) {
      let r;
      for (this.parts = []; r = hA.exec(e); ) {
        let n = r.shift(), o = r.findIndex((a) => a != null);
        this.parts.push(o in gm ? gm[o]({
          token: r[o] || n,
          date: this.date,
          parts: this.parts,
          locales: this.locales
        }) : r[o] || n);
      }
      let i = this.parts.reduce((n, o) => (typeof o == "string" && typeof n[n.length - 1] == "string" ? n[n.length - 1] += o : n.push(o), n),
      []);
      this.parts.splice(0), this.parts.push(...i), this.reset();
    }
    moveCursor(e) {
      this.typed = "", this.cursor = e, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((e) => e instanceof mm)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    validate() {
      var e = this;
      return hm(function* () {
        let r = yield e.validator(e.value);
        typeof r == "string" && (e.errorMsg = r, r = !1), e.error = !r;
      })();
    }
    submit() {
      var e = this;
      return hm(function* () {
        if (yield e.validate(), e.error) {
          e.color = "red", e.fire(), e.render();
          return;
        }
        e.done = !0, e.aborted = !1, e.fire(), e.render(), e.out.write(`
`), e.close();
      })();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let e = this.parts[this.cursor].prev();
      if (e == null) return this.bell();
      this.moveCursor(this.parts.indexOf(e)), this.render();
    }
    right() {
      let e = this.parts[this.cursor].next();
      if (e == null) return this.bell();
      this.moveCursor(this.parts.indexOf(e)), this.render();
    }
    next() {
      let e = this.parts[this.cursor].next();
      this.moveCursor(e ? this.parts.indexOf(e) : this.parts.findIndex((r) => r instanceof mm)), this.render();
    }
    _(e) {
      /\d/.test(e) && (this.typed += e, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(pm.hide) : this.out.write(dm(this.outputText, this.out.columns)), super.render(), this.
      outputText = [fm.symbol(this.done, this.aborted), Ko.bold(this.msg), fm.delimiter(!1), this.parts.reduce((e, r, i) => e.concat(i === this.
      cursor && !this.done ? Ko.cyan().underline(r.toString()) : r), []).join("")].join(" "), this.error && (this.outputText += this.errorMsg.
      split(`
`).reduce((e, r, i) => e + `
${i ? " " : tA.pointerSmall} ${Ko.red().italic(r)}`, "")), this.out.write(rA.line + pm.to(0) + this.outputText));
    }
  };
  Sm.exports = Xo;
});

// ../node_modules/prompts/dist/elements/number.js
var Rm = d((Yq, Pm) => {
  "use strict";
  function wm(t, e, r, i, n, o, a) {
    try {
      var u = t[o](a), c = u.value;
    } catch (h) {
      r(h);
      return;
    }
    u.done ? e(c) : Promise.resolve(c).then(i, n);
  }
  s(wm, "asyncGeneratorStep");
  function vm(t) {
    return function() {
      var e = this, r = arguments;
      return new Promise(function(i, n) {
        var o = t.apply(e, r);
        function a(c) {
          wm(o, i, n, a, u, "next", c);
        }
        s(a, "_next");
        function u(c) {
          wm(o, i, n, a, u, "throw", c);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(vm, "_asyncToGenerator");
  var Ni = Q(), dA = et(), Em = ee(), Mi = Em.cursor, pA = Em.erase, Li = qe(), Jo = Li.style, mA = Li.figures, _m = Li.clear, gA = Li.lines,
  yA = /[0-9]/, Qo = /* @__PURE__ */ s((t) => t !== void 0, "isDef"), xm = /* @__PURE__ */ s((t, e) => {
    let r = Math.pow(10, e);
    return Math.round(t * r) / r;
  }, "round"), Zo = class extends dA {
    static {
      s(this, "NumberPrompt");
    }
    constructor(e = {}) {
      super(e), this.transform = Jo.render(e.style), this.msg = e.message, this.initial = Qo(e.initial) ? e.initial : "", this.float = !!e.float,
      this.round = e.round || 2, this.inc = e.increment || 1, this.min = Qo(e.min) ? e.min : -1 / 0, this.max = Qo(e.max) ? e.max : 1 / 0, this.
      errorMsg = e.error || "Please Enter A Valid Value", this.validator = e.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(e) {
      !e && e !== 0 ? (this.placeholder = !0, this.rendered = Ni.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${xm(e, this.round)}`), this._value = xm(e, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(e) {
      return this.float ? parseFloat(e) : parseInt(e);
    }
    valid(e) {
      return e === "-" || e === "." && this.float || yA.test(e);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let e = this.value;
      this.value = e !== "" ? e : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    validate() {
      var e = this;
      return vm(function* () {
        let r = yield e.validator(e.value);
        typeof r == "string" && (e.errorMsg = r, r = !1), e.error = !r;
      })();
    }
    submit() {
      var e = this;
      return vm(function* () {
        if (yield e.validate(), e.error) {
          e.color = "red", e.fire(), e.render();
          return;
        }
        let r = e.value;
        e.value = r !== "" ? r : e.initial, e.done = !0, e.aborted = !1, e.error = !1, e.fire(), e.render(), e.out.write(`
`), e.close();
      })();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let e = this.value.toString();
      if (e.length === 0) return this.bell();
      this.value = this.parse(e = e.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(e, r) {
      if (!this.valid(e)) return this.bell();
      let i = Date.now();
      if (i - this.lastHit > 1e3 && (this.typed = ""), this.typed += e, this.lastHit = i, this.color = "cyan", e === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Mi.down(gA(this.outputError, this.out.columns) - 1) + _m(this.
      outputError, this.out.columns)), this.out.write(_m(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [Jo.symbol(this.done, this.aborted), Ni.bold(this.msg), Jo.delimiter(this.done), !this.done || !this.done && !this.placeholder ? Ni[this.
      color]().underline(this.rendered) : this.rendered].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((e, r, i) => e + `
${i ? " " : mA.pointerSmall} ${Ni.red().italic(r)}`, "")), this.out.write(pA.line + Mi.to(0) + this.outputText + Mi.save + this.outputError +
      Mi.restore));
    }
  };
  Pm.exports = Zo;
});

// ../node_modules/prompts/dist/elements/multiselect.js
var ta = d((Xq, Cm) => {
  "use strict";
  var Be = Q(), SA = ee(), bA = SA.cursor, wA = et(), xr = qe(), Am = xr.clear, yt = xr.figures, Om = xr.style, vA = xr.wrap, _A = xr.entriesToDisplay,
  ea = class extends wA {
    static {
      s(this, "MultiselectPrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.cursor = e.cursor || 0, this.scrollIndex = e.cursor || 0, this.hint = e.hint || "", this.warn = e.
      warn || "- This option is disabled -", this.minSelected = e.min, this.showMinError = !1, this.maxChoices = e.max, this.instructions = e.
      instructions, this.optionsPerPage = e.optionsPerPage || 10, this.value = e.choices.map((r, i) => (typeof r == "string" && (r = {
        title: r,
        value: i
      }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? i : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = Am("", this.out.columns), e.overrideRender || this.render();
    }
    reset() {
      this.value.map((e) => !e.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((e) => e.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let e = this.value.filter((r) => r.selected);
      this.minSelected && e.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let e = this.value[this.cursor];
      if (e.selected)
        e.selected = !1, this.render();
      else {
        if (e.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        e.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let e = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = e), this.render();
    }
    _(e, r) {
      if (e === " ")
        this.handleSpaceToggle();
      else if (e === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${yt.arrowUp}/${yt.arrowDown}: Highlight option
    ${yt.arrowLeft}/${yt.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(e, r, i, n) {
      let o = (r.selected ? Be.green(yt.radioOn) : yt.radioOff) + " " + n + " ", a, u;
      return r.disabled ? a = e === i ? Be.gray().underline(r.title) : Be.strikethrough().gray(r.title) : (a = e === i ? Be.cyan().underline(
      r.title) : r.title, e === i && r.description && (u = ` - ${r.description}`, (o.length + a.length + u.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (u = `
` + vA(r.description, {
        margin: o.length,
        width: this.out.columns
      })))), o + a + Be.gray(u || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(e) {
      if (e.length === 0)
        return Be.red("No matches for this query.");
      let r = _A(this.cursor, e.length, this.optionsPerPage), i = r.startIndex, n = r.endIndex, o, a = [];
      for (let u = i; u < n; u++)
        u === i && i > 0 ? o = yt.arrowUp : u === n - 1 && n < e.length ? o = yt.arrowDown : o = " ", a.push(this.renderOption(this.cursor, e[u],
        u, o));
      return `
` + a.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(e) {
      return this.done ? "" : this.paginateOptions(e);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let e = [Be.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && e.push(Be.yellow(this.warn)), e.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(bA.hide), super.render();
      let e = [Om.symbol(this.done, this.aborted), Be.bold(this.msg), Om.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (e += Be.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), e += this.renderOptions(
      this.value), this.out.write(this.clear + e), this.clear = Am(e, this.out.columns);
    }
  };
  Cm.exports = ea;
});

// ../node_modules/prompts/dist/elements/autocomplete.js
var Fm = d((Jq, $m) => {
  "use strict";
  function Tm(t, e, r, i, n, o, a) {
    try {
      var u = t[o](a), c = u.value;
    } catch (h) {
      r(h);
      return;
    }
    u.done ? e(c) : Promise.resolve(c).then(i, n);
  }
  s(Tm, "asyncGeneratorStep");
  function xA(t) {
    return function() {
      var e = this, r = arguments;
      return new Promise(function(i, n) {
        var o = t.apply(e, r);
        function a(c) {
          Tm(o, i, n, a, u, "next", c);
        }
        s(a, "_next");
        function u(c) {
          Tm(o, i, n, a, u, "throw", c);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(xA, "_asyncToGenerator");
  var Er = Q(), EA = et(), qm = ee(), PA = qm.erase, km = qm.cursor, Pr = qe(), ra = Pr.style, Im = Pr.clear, ia = Pr.figures, RA = Pr.wrap,
  AA = Pr.entriesToDisplay, Dm = /* @__PURE__ */ s((t, e) => t[e] && (t[e].value || t[e].title || t[e]), "getVal"), OA = /* @__PURE__ */ s((t, e) => t[e] &&
  (t[e].title || t[e].value || t[e]), "getTitle"), CA = /* @__PURE__ */ s((t, e) => {
    let r = t.findIndex((i) => i.value === e || i.title === e);
    return r > -1 ? r : void 0;
  }, "getIndex"), sa = class extends EA {
    static {
      s(this, "AutocompletePrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.suggest = e.suggest, this.choices = e.choices, this.initial = typeof e.initial == "number" ? e.initial :
      CA(e.choices, e.initial), this.select = this.initial || e.cursor || 0, this.i18n = {
        noMatches: e.noMatches || "no matches found"
      }, this.fallback = e.fallback || this.initial, this.clearFirst = e.clearFirst || !1, this.suggestions = [], this.input = "", this.limit =
      e.limit || 10, this.cursor = 0, this.transform = ra.render(e.style), this.scale = this.transform.scale, this.render = this.render.bind(
      this), this.complete = this.complete.bind(this), this.clear = Im("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(e) {
      this._fb = Number.isSafeInteger(parseInt(e)) ? parseInt(e) : e;
    }
    get fallback() {
      let e;
      return typeof this._fb == "number" ? e = this.choices[this._fb] : typeof this._fb == "string" && (e = {
        title: this._fb
      }), e || this._fb || {
        title: this.i18n.noMatches
      };
    }
    moveSelect(e) {
      this.select = e, this.suggestions.length > 0 ? this.value = Dm(this.suggestions, e) : this.value = this.fallback.value, this.fire();
    }
    complete(e) {
      var r = this;
      return xA(function* () {
        let i = r.completing = r.suggest(r.input, r.choices), n = yield i;
        if (r.completing !== i) return;
        r.suggestions = n.map((a, u, c) => ({
          title: OA(c, u),
          value: Dm(c, u),
          description: a.description
        })), r.completing = !1;
        let o = Math.max(n.length - 1, 0);
        r.moveSelect(Math.min(o, r.select)), e && e();
      })();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(e, r) {
      let i = this.input.slice(0, this.cursor), n = this.input.slice(this.cursor);
      this.input = `${i}${e}${n}`, this.cursor = i.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let e = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${e}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let e = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${e}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(e, r, i, n) {
      let o, a = i ? ia.arrowUp : n ? ia.arrowDown : " ", u = r ? Er.cyan().underline(e.title) : e.title;
      return a = (r ? Er.cyan(ia.pointer) + " " : "  ") + a, e.description && (o = ` - ${e.description}`, (a.length + u.length + o.length >=
      this.out.columns || e.description.split(/\r?\n/).length > 1) && (o = `
` + RA(e.description, {
        margin: 3,
        width: this.out.columns
      }))), a + " " + u + Er.gray(o || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(km.hide) : this.out.write(Im(this.outputText, this.out.columns)), super.render();
      let e = AA(this.select, this.choices.length, this.limit), r = e.startIndex, i = e.endIndex;
      if (this.outputText = [ra.symbol(this.done, this.aborted, this.exited), Er.bold(this.msg), ra.delimiter(this.completing), this.done &&
      this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" "), !this.
      done) {
        let n = this.suggestions.slice(r, i).map((o, a) => this.renderOption(o, this.select === a + r, a === 0 && r > 0, a + r === i - 1 && i <
        this.choices.length)).join(`
`);
        this.outputText += `
` + (n || Er.gray(this.fallback.title));
      }
      this.out.write(PA.line + km.to(0) + this.outputText);
    }
  };
  $m.exports = sa;
});

// ../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var jm = d((Zq, Lm) => {
  "use strict";
  var it = Q(), TA = ee(), kA = TA.cursor, IA = ta(), oa = qe(), Nm = oa.clear, Mm = oa.style, zt = oa.figures, na = class extends IA {
    static {
      s(this, "AutocompleteMultiselectPrompt");
    }
    constructor(e = {}) {
      e.overrideRender = !0, super(e), this.inputValue = "", this.clear = Nm("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let e = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((i) => this.inputValue ? !!(typeof i.title == "string" && i.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof i.value == "string" && i.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((i) => i === e);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let e = this.filteredOptions[this.cursor];
      if (e.selected)
        e.selected = !1, this.render();
      else {
        if (e.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        e.selected = !0, this.render();
      }
    }
    handleInputChange(e) {
      this.inputValue = this.inputValue + e, this.updateFilteredOptions();
    }
    _(e, r) {
      e === " " ? this.handleSpaceToggle() : this.handleInputChange(e);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${zt.arrowUp}/${zt.arrowDown}: Highlight option
    ${zt.arrowLeft}/${zt.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : it.gray("Enter something to filter")}
`;
    }
    renderOption(e, r, i) {
      let n;
      return r.disabled ? n = e === i ? it.gray().underline(r.title) : it.strikethrough().gray(r.title) : n = e === i ? it.cyan().underline(
      r.title) : r.title, (r.selected ? it.green(zt.radioOn) : zt.radioOff) + "  " + n;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let e = [it.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && e.push(it.yellow(this.warn)), e.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(kA.hide), super.render();
      let e = [Mm.symbol(this.done, this.aborted), it.bold(this.msg), Mm.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (e += it.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), e += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + e), this.clear = Nm(e, this.out.columns);
    }
  };
  Lm.exports = na;
});

// ../node_modules/prompts/dist/elements/confirm.js
var Ym = d((t$, Vm) => {
  "use strict";
  var Hm = Q(), DA = et(), Gm = qe(), Bm = Gm.style, qA = Gm.clear, Um = ee(), $A = Um.erase, Wm = Um.cursor, aa = class extends DA {
    static {
      s(this, "ConfirmPrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.value = e.initial, this.initialValue = !!e.initial, this.yesMsg = e.yes || "yes", this.yesOption =
      e.yesOption || "(Y/n)", this.noMsg = e.no || "no", this.noOption = e.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(e, r) {
      return e.toLowerCase() === "y" ? (this.value = !0, this.submit()) : e.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(Wm.hide) : this.out.write(qA(this.outputText, this.out.columns)), super.render(), this.
      outputText = [Bm.symbol(this.done, this.aborted), Hm.bold(this.msg), Bm.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.
      noMsg : Hm.gray(this.initialValue ? this.yesOption : this.noOption)].join(" "), this.out.write($A.line + Wm.to(0) + this.outputText));
    }
  };
  Vm.exports = aa;
});

// ../node_modules/prompts/dist/elements/index.js
var Xm = d((i$, Km) => {
  "use strict";
  Km.exports = {
    TextPrompt: qp(),
    SelectPrompt: Mp(),
    TogglePrompt: Gp(),
    DatePrompt: bm(),
    NumberPrompt: Rm(),
    MultiselectPrompt: ta(),
    AutocompletePrompt: Fm(),
    AutocompleteMultiselectPrompt: jm(),
    ConfirmPrompt: Ym()
  };
});

// ../node_modules/prompts/dist/prompts.js
var Jm = d((zm) => {
  "use strict";
  var ye = zm, FA = Xm(), ji = /* @__PURE__ */ s((t) => t, "noop");
  function We(t, e, r = {}) {
    return new Promise((i, n) => {
      let o = new FA[t](e), a = r.onAbort || ji, u = r.onSubmit || ji, c = r.onExit || ji;
      o.on("state", e.onState || ji), o.on("submit", (h) => i(u(h))), o.on("exit", (h) => i(c(h))), o.on("abort", (h) => n(a(h)));
    });
  }
  s(We, "toPrompt");
  ye.text = (t) => We("TextPrompt", t);
  ye.password = (t) => (t.style = "password", ye.text(t));
  ye.invisible = (t) => (t.style = "invisible", ye.text(t));
  ye.number = (t) => We("NumberPrompt", t);
  ye.date = (t) => We("DatePrompt", t);
  ye.confirm = (t) => We("ConfirmPrompt", t);
  ye.list = (t) => {
    let e = t.separator || ",";
    return We("TextPrompt", t, {
      onSubmit: /* @__PURE__ */ s((r) => r.split(e).map((i) => i.trim()), "onSubmit")
    });
  };
  ye.toggle = (t) => We("TogglePrompt", t);
  ye.select = (t) => We("SelectPrompt", t);
  ye.multiselect = (t) => {
    t.choices = [].concat(t.choices || []);
    let e = /* @__PURE__ */ s((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return We("MultiselectPrompt", t, {
      onAbort: e,
      onSubmit: e
    });
  };
  ye.autocompleteMultiselect = (t) => {
    t.choices = [].concat(t.choices || []);
    let e = /* @__PURE__ */ s((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return We("AutocompleteMultiselectPrompt", t, {
      onAbort: e,
      onSubmit: e
    });
  };
  var NA = /* @__PURE__ */ s((t, e) => Promise.resolve(e.filter((r) => r.title.slice(0, t.length).toLowerCase() === t.toLowerCase())), "byTi\
tle");
  ye.autocomplete = (t) => (t.suggest = t.suggest || NA, t.choices = [].concat(t.choices || []), We("AutocompletePrompt", t));
});

// ../node_modules/prompts/dist/index.js
var ng = d((o$, sg) => {
  "use strict";
  function Qm(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(t);
      e && (i = i.filter(function(n) {
        return Object.getOwnPropertyDescriptor(t, n).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  s(Qm, "ownKeys");
  function Zm(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e] != null ? arguments[e] : {};
      e % 2 ? Qm(Object(r), !0).forEach(function(i) {
        MA(t, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Qm(Object(r)).forEach(function(i) {
        Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return t;
  }
  s(Zm, "_objectSpread");
  function MA(t, e, r) {
    return e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
  }
  s(MA, "_defineProperty");
  function LA(t, e) {
    var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (!r) {
      if (Array.isArray(t) || (r = jA(t)) || e && t && typeof t.length == "number") {
        r && (t = r);
        var i = 0, n = /* @__PURE__ */ s(function() {
        }, "F");
        return { s: n, n: /* @__PURE__ */ s(function() {
          return i >= t.length ? { done: !0 } : { done: !1, value: t[i++] };
        }, "n"), e: /* @__PURE__ */ s(function(h) {
          throw h;
        }, "e"), f: n };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var o = !0, a = !1, u;
    return { s: /* @__PURE__ */ s(function() {
      r = r.call(t);
    }, "s"), n: /* @__PURE__ */ s(function() {
      var h = r.next();
      return o = h.done, h;
    }, "n"), e: /* @__PURE__ */ s(function(h) {
      a = !0, u = h;
    }, "e"), f: /* @__PURE__ */ s(function() {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (a) throw u;
      }
    }, "f") };
  }
  s(LA, "_createForOfIteratorHelper");
  function jA(t, e) {
    if (t) {
      if (typeof t == "string") return eg(t, e);
      var r = Object.prototype.toString.call(t).slice(8, -1);
      if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return eg(t, e);
    }
  }
  s(jA, "_unsupportedIterableToArray");
  function eg(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var r = 0, i = new Array(e); r < e; r++) i[r] = t[r];
    return i;
  }
  s(eg, "_arrayLikeToArray");
  function tg(t, e, r, i, n, o, a) {
    try {
      var u = t[o](a), c = u.value;
    } catch (h) {
      r(h);
      return;
    }
    u.done ? e(c) : Promise.resolve(c).then(i, n);
  }
  s(tg, "asyncGeneratorStep");
  function rg(t) {
    return function() {
      var e = this, r = arguments;
      return new Promise(function(i, n) {
        var o = t.apply(e, r);
        function a(c) {
          tg(o, i, n, a, u, "next", c);
        }
        s(a, "_next");
        function u(c) {
          tg(o, i, n, a, u, "throw", c);
        }
        s(u, "_throw"), a(void 0);
      });
    };
  }
  s(rg, "_asyncToGenerator");
  var ua = Jm(), HA = ["suggest", "format", "onState", "validate", "onRender", "type"], ig = /* @__PURE__ */ s(() => {
  }, "noop");
  function St() {
    return ca.apply(this, arguments);
  }
  s(St, "prompt");
  function ca() {
    return ca = rg(function* (t = [], {
      onSubmit: e = ig,
      onCancel: r = ig
    } = {}) {
      let i = {}, n = St._override || {};
      t = [].concat(t);
      let o, a, u, c, h, l, p = /* @__PURE__ */ function() {
        var _ = rg(function* (P, q, R = !1) {
          if (!(!R && P.validate && P.validate(q) !== !0))
            return P.format ? yield P.format(q, i) : q;
        });
        return /* @__PURE__ */ s(function(q, R) {
          return _.apply(this, arguments);
        }, "getFormattedAnswer");
      }();
      var f = LA(t), b;
      try {
        for (f.s(); !(b = f.n()).done; ) {
          a = b.value;
          var m = a;
          if (c = m.name, h = m.type, typeof h == "function" && (h = yield h(o, Zm({}, i), a), a.type = h), !!h) {
            for (let _ in a) {
              if (HA.includes(_)) continue;
              let P = a[_];
              a[_] = typeof P == "function" ? yield P(o, Zm({}, i), l) : P;
            }
            if (l = a, typeof a.message != "string")
              throw new Error("prompt message is required");
            var w = a;
            if (c = w.name, h = w.type, ua[h] === void 0)
              throw new Error(`prompt type (${h}) is not defined`);
            if (n[a.name] !== void 0 && (o = yield p(a, n[a.name]), o !== void 0)) {
              i[c] = o;
              continue;
            }
            try {
              o = St._injected ? BA(St._injected, a.initial) : yield ua[h](a), i[c] = o = yield p(a, o, !0), u = yield e(a, o, i);
            } catch {
              u = !(yield r(a, i));
            }
            if (u) return i;
          }
        }
      } catch (_) {
        f.e(_);
      } finally {
        f.f();
      }
      return i;
    }), ca.apply(this, arguments);
  }
  s(ca, "_prompt");
  function BA(t, e) {
    let r = t.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? e : r;
  }
  s(BA, "getInjectedAnswer");
  function WA(t) {
    St._injected = (St._injected || []).concat(t);
  }
  s(WA, "inject");
  function GA(t) {
    St._override = Object.assign({}, t);
  }
  s(GA, "override");
  sg.exports = Object.assign(St, {
    prompt: St,
    prompts: ua,
    inject: WA,
    override: GA
  });
});

// ../node_modules/prompts/lib/util/action.js
var ag = d((u$, og) => {
  "use strict";
  og.exports = (t, e) => {
    if (!(t.meta && t.name !== "escape")) {
      if (t.ctrl) {
        if (t.name === "a") return "first";
        if (t.name === "c" || t.name === "d") return "abort";
        if (t.name === "e") return "last";
        if (t.name === "g") return "reset";
      }
      if (e) {
        if (t.name === "j") return "down";
        if (t.name === "k") return "up";
      }
      return t.name === "return" || t.name === "enter" ? "submit" : t.name === "backspace" ? "delete" : t.name === "delete" ? "deleteForward" :
      t.name === "abort" ? "abort" : t.name === "escape" ? "exit" : t.name === "tab" ? "next" : t.name === "pagedown" ? "nextPage" : t.name ===
      "pageup" ? "prevPage" : t.name === "home" ? "home" : t.name === "end" ? "end" : t.name === "up" ? "up" : t.name === "down" ? "down" : t.
      name === "right" ? "right" : t.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/lib/util/strip.js
var Hi = d((c$, ug) => {
  "use strict";
  ug.exports = (t) => {
    let e = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|"), r = new RegExp(e, "g");
    return typeof t == "string" ? t.replace(r, "") : t;
  };
});

// ../node_modules/prompts/lib/util/clear.js
var hg = d((l$, lg) => {
  "use strict";
  var UA = Hi(), { erase: cg, cursor: VA } = ee(), YA = /* @__PURE__ */ s((t) => [...UA(t)].length, "width");
  lg.exports = function(t, e) {
    if (!e) return cg.line + VA.to(0);
    let r = 0, i = t.split(/\r?\n/);
    for (let n of i)
      r += 1 + Math.floor(Math.max(YA(n) - 1, 0) / e);
    return cg.lines(r);
  };
});

// ../node_modules/prompts/lib/util/figures.js
var la = d((f$, fg) => {
  "use strict";
  var Rr = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, KA = {
    arrowUp: Rr.arrowUp,
    arrowDown: Rr.arrowDown,
    arrowLeft: Rr.arrowLeft,
    arrowRight: Rr.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, XA = process.platform === "win32" ? KA : Rr;
  fg.exports = XA;
});

// ../node_modules/prompts/lib/util/style.js
var pg = d((d$, dg) => {
  "use strict";
  var Jt = Q(), Tt = la(), ha = Object.freeze({
    password: { scale: 1, render: /* @__PURE__ */ s((t) => "*".repeat(t.length), "render") },
    emoji: { scale: 2, render: /* @__PURE__ */ s((t) => "\u{1F603}".repeat(t.length), "render") },
    invisible: { scale: 0, render: /* @__PURE__ */ s((t) => "", "render") },
    default: { scale: 1, render: /* @__PURE__ */ s((t) => `${t}`, "render") }
  }), zA = /* @__PURE__ */ s((t) => ha[t] || ha.default, "render"), Ar = Object.freeze({
    aborted: Jt.red(Tt.cross),
    done: Jt.green(Tt.tick),
    exited: Jt.yellow(Tt.cross),
    default: Jt.cyan("?")
  }), JA = /* @__PURE__ */ s((t, e, r) => e ? Ar.aborted : r ? Ar.exited : t ? Ar.done : Ar.default, "symbol"), QA = /* @__PURE__ */ s((t) => Jt.
  gray(t ? Tt.ellipsis : Tt.pointerSmall), "delimiter"), ZA = /* @__PURE__ */ s((t, e) => Jt.gray(t ? e ? Tt.pointerSmall : "+" : Tt.line), "\
item");
  dg.exports = {
    styles: ha,
    render: zA,
    symbols: Ar,
    symbol: JA,
    delimiter: QA,
    item: ZA
  };
});

// ../node_modules/prompts/lib/util/lines.js
var gg = d((m$, mg) => {
  "use strict";
  var eO = Hi();
  mg.exports = function(t, e) {
    let r = String(eO(t) || "").split(/\r?\n/);
    return e ? r.map((i) => Math.ceil(i.length / e)).reduce((i, n) => i + n) : r.length;
  };
});

// ../node_modules/prompts/lib/util/wrap.js
var Sg = d((g$, yg) => {
  "use strict";
  yg.exports = (t, e = {}) => {
    let r = Number.isSafeInteger(parseInt(e.margin)) ? new Array(parseInt(e.margin)).fill(" ").join("") : e.margin || "", i = e.width;
    return (t || "").split(/\r?\n/g).map((n) => n.split(/\s+/g).reduce((o, a) => (a.length + r.length >= i || o[o.length - 1].length + a.length +
    1 < i ? o[o.length - 1] += ` ${a}` : o.push(`${r}${a}`), o), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/lib/util/entriesToDisplay.js
var wg = d((y$, bg) => {
  "use strict";
  bg.exports = (t, e, r) => {
    r = r || e;
    let i = Math.min(e - r, t - Math.floor(r / 2));
    i < 0 && (i = 0);
    let n = Math.min(i + r, e);
    return { startIndex: i, endIndex: n };
  };
});

// ../node_modules/prompts/lib/util/index.js
var $e = d((S$, vg) => {
  "use strict";
  vg.exports = {
    action: ag(),
    clear: hg(),
    style: pg(),
    strip: Hi(),
    figures: la(),
    lines: gg(),
    wrap: Sg(),
    entriesToDisplay: wg()
  };
});

// ../node_modules/prompts/lib/elements/prompt.js
var st = d((b$, xg) => {
  "use strict";
  var _g = A("readline"), { action: tO } = $e(), rO = A("events"), { beep: iO, cursor: sO } = ee(), nO = Q(), fa = class extends rO {
    static {
      s(this, "Prompt");
    }
    constructor(e = {}) {
      super(), this.firstRender = !0, this.in = e.stdin || process.stdin, this.out = e.stdout || process.stdout, this.onRender = (e.onRender ||
      (() => {
      })).bind(this);
      let r = _g.createInterface({ input: this.in, escapeCodeTimeout: 50 });
      _g.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let i = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, n = /* @__PURE__ */ s((o, a) => {
        let u = tO(a, i);
        u === !1 ? this._ && this._(o, a) : typeof this[u] == "function" ? this[u](a) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(sO.show), this.in.removeListener("keypress", n), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", n);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(iO);
    }
    render() {
      this.onRender(nO), this.firstRender && (this.firstRender = !1);
    }
  };
  xg.exports = fa;
});

// ../node_modules/prompts/lib/elements/text.js
var Pg = d((v$, Eg) => {
  var Bi = Q(), oO = st(), { erase: aO, cursor: Or } = ee(), { style: da, clear: pa, lines: uO, figures: cO } = $e(), ma = class extends oO {
    static {
      s(this, "TextPrompt");
    }
    constructor(e = {}) {
      super(e), this.transform = da.render(e.style), this.scale = this.transform.scale, this.msg = e.message, this.initial = e.initial || "",
      this.validator = e.validate || (() => !0), this.value = "", this.errorMsg = e.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = pa("", this.out.columns), this.render();
    }
    set value(e) {
      !e && this.initial ? (this.placeholder = !0, this.rendered = Bi.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(e)), this._value = e, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    async validate() {
      let e = await this.validator(this.value);
      typeof e == "string" && (this.errorMsg = e, e = !1), this.error = !e;
    }
    async submit() {
      if (this.value = this.value || this.initial, this.cursorOffset = 0, this.cursor = this.rendered.length, await this.validate(), this.error) {
        this.red = !0, this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(e) {
      this.placeholder || (this.cursor = this.cursor + e, this.cursorOffset += e);
    }
    _(e, r) {
      let i = this.value.slice(0, this.cursor), n = this.value.slice(this.cursor);
      this.value = `${i}${e}${n}`, this.red = !1, this.cursor = this.placeholder ? 0 : i.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let e = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${e}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let e = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${e}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Or.down(uO(this.outputError, this.out.columns) - 1) + pa(this.
      outputError, this.out.columns)), this.out.write(pa(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        da.symbol(this.done, this.aborted),
        Bi.bold(this.msg),
        da.delimiter(this.done),
        this.red ? Bi.red(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((e, r, i) => e + `
${i ? " " : cO.pointerSmall} ${Bi.red().italic(r)}`, "")), this.out.write(aO.line + Or.to(0) + this.outputText + Or.save + this.outputError +
      Or.restore + Or.move(this.cursorOffset, 0)));
    }
  };
  Eg.exports = ma;
});

// ../node_modules/prompts/lib/elements/select.js
var Cg = d((x$, Og) => {
  "use strict";
  var nt = Q(), lO = st(), { style: Rg, clear: Ag, figures: Wi, wrap: hO, entriesToDisplay: fO } = $e(), { cursor: dO } = ee(), ga = class extends lO {
    static {
      s(this, "SelectPrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.hint = e.hint || "- Use arrow-keys. Return to submit.", this.warn = e.warn || "- This option is d\
isabled", this.cursor = e.initial || 0, this.choices = e.choices.map((r, i) => (typeof r == "string" && (r = { title: r, value: i }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? i : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = e.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = Ag("", this.out.
      columns), this.render();
    }
    moveCursor(e) {
      this.cursor = e, this.value = this.choices[e].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(e, r) {
      if (e === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(dO.hide) : this.out.write(Ag(this.outputText, this.out.columns)), super.render();
      let { startIndex: e, endIndex: r } = fO(this.cursor, this.choices.length, this.optionsPerPage);
      if (this.outputText = [
        Rg.symbol(this.done, this.aborted),
        nt.bold(this.msg),
        Rg.delimiter(!1),
        this.done ? this.selection.title : this.selection.disabled ? nt.yellow(this.warn) : nt.gray(this.hint)
      ].join(" "), !this.done) {
        this.outputText += `
`;
        for (let i = e; i < r; i++) {
          let n, o, a = "", u = this.choices[i];
          i === e && e > 0 ? o = Wi.arrowUp : i === r - 1 && r < this.choices.length ? o = Wi.arrowDown : o = " ", u.disabled ? (n = this.cursor ===
          i ? nt.gray().underline(u.title) : nt.strikethrough().gray(u.title), o = (this.cursor === i ? nt.bold().gray(Wi.pointer) + " " : "\
  ") + o) : (n = this.cursor === i ? nt.cyan().underline(u.title) : u.title, o = (this.cursor === i ? nt.cyan(Wi.pointer) + " " : "  ") + o,
          u.description && this.cursor === i && (a = ` - ${u.description}`, (o.length + n.length + a.length >= this.out.columns || u.description.
          split(/\r?\n/).length > 1) && (a = `
` + hO(u.description, { margin: 3, width: this.out.columns })))), this.outputText += `${o} ${n}${nt.gray(a)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  Og.exports = ga;
});

// ../node_modules/prompts/lib/elements/toggle.js
var Dg = d((P$, Ig) => {
  var Gi = Q(), pO = st(), { style: Tg, clear: mO } = $e(), { cursor: kg, erase: gO } = ee(), ya = class extends pO {
    static {
      s(this, "TogglePrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.value = !!e.initial, this.active = e.active || "on", this.inactive = e.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(e, r) {
      if (e === " ")
        this.value = !this.value;
      else if (e === "1")
        this.value = !0;
      else if (e === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(kg.hide) : this.out.write(mO(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        Tg.symbol(this.done, this.aborted),
        Gi.bold(this.msg),
        Tg.delimiter(this.done),
        this.value ? this.inactive : Gi.cyan().underline(this.inactive),
        Gi.gray("/"),
        this.value ? Gi.cyan().underline(this.active) : this.active
      ].join(" "), this.out.write(gO.line + kg.to(0) + this.outputText));
    }
  };
  Ig.exports = ya;
});

// ../node_modules/prompts/lib/dateparts/datepart.js
var Ge = d((A$, qg) => {
  "use strict";
  var Sa = class t {
    static {
      s(this, "DatePart");
    }
    constructor({ token: e, date: r, parts: i, locales: n }) {
      this.token = e, this.date = r || /* @__PURE__ */ new Date(), this.parts = i || [this], this.locales = n || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let e = this.parts.indexOf(this);
      return this.parts.find((r, i) => i > e && r instanceof t);
    }
    setTo(e) {
    }
    prev() {
      let e = [].concat(this.parts).reverse(), r = e.indexOf(this);
      return e.find((i, n) => n > r && i instanceof t);
    }
    toString() {
      return String(this.date);
    }
  };
  qg.exports = Sa;
});

// ../node_modules/prompts/lib/dateparts/meridiem.js
var Fg = d((C$, $g) => {
  "use strict";
  var yO = Ge(), ba = class extends yO {
    static {
      s(this, "Meridiem");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let e = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? e.toUpperCase() : e;
    }
  };
  $g.exports = ba;
});

// ../node_modules/prompts/lib/dateparts/day.js
var Mg = d((k$, Ng) => {
  "use strict";
  var SO = Ge(), bO = /* @__PURE__ */ s((t) => (t = t % 10, t === 1 ? "st" : t === 2 ? "nd" : t === 3 ? "rd" : "th"), "pos"), wa = class extends SO {
    static {
      s(this, "Day");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(e) {
      this.date.setDate(parseInt(e.substr(-2)));
    }
    toString() {
      let e = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(e).padStart(2, "0") : this.token === "Do" ? e + bO(e) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : e;
    }
  };
  Ng.exports = wa;
});

// ../node_modules/prompts/lib/dateparts/hours.js
var jg = d((D$, Lg) => {
  "use strict";
  var wO = Ge(), va = class extends wO {
    static {
      s(this, "Hours");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(e) {
      this.date.setHours(parseInt(e.substr(-2)));
    }
    toString() {
      let e = this.date.getHours();
      return /h/.test(this.token) && (e = e % 12 || 12), this.token.length > 1 ? String(e).padStart(2, "0") : e;
    }
  };
  Lg.exports = va;
});

// ../node_modules/prompts/lib/dateparts/milliseconds.js
var Bg = d(($$, Hg) => {
  "use strict";
  var vO = Ge(), _a = class extends vO {
    static {
      s(this, "Milliseconds");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(e) {
      this.date.setMilliseconds(parseInt(e.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  Hg.exports = _a;
});

// ../node_modules/prompts/lib/dateparts/minutes.js
var Gg = d((N$, Wg) => {
  "use strict";
  var _O = Ge(), xa = class extends _O {
    static {
      s(this, "Minutes");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(e) {
      this.date.setMinutes(parseInt(e.substr(-2)));
    }
    toString() {
      let e = this.date.getMinutes();
      return this.token.length > 1 ? String(e).padStart(2, "0") : e;
    }
  };
  Wg.exports = xa;
});

// ../node_modules/prompts/lib/dateparts/month.js
var Vg = d((L$, Ug) => {
  "use strict";
  var xO = Ge(), Ea = class extends xO {
    static {
      s(this, "Month");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(e) {
      e = parseInt(e.substr(-2)) - 1, this.date.setMonth(e < 0 ? 0 : e);
    }
    toString() {
      let e = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(e + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[e] : r === 4 ? this.locales.months[e] : String(e +
      1);
    }
  };
  Ug.exports = Ea;
});

// ../node_modules/prompts/lib/dateparts/seconds.js
var Kg = d((H$, Yg) => {
  "use strict";
  var EO = Ge(), Pa = class extends EO {
    static {
      s(this, "Seconds");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(e) {
      this.date.setSeconds(parseInt(e.substr(-2)));
    }
    toString() {
      let e = this.date.getSeconds();
      return this.token.length > 1 ? String(e).padStart(2, "0") : e;
    }
  };
  Yg.exports = Pa;
});

// ../node_modules/prompts/lib/dateparts/year.js
var zg = d((W$, Xg) => {
  "use strict";
  var PO = Ge(), Ra = class extends PO {
    static {
      s(this, "Year");
    }
    constructor(e = {}) {
      super(e);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(e) {
      this.date.setFullYear(e.substr(-4));
    }
    toString() {
      let e = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? e.substr(-2) : e;
    }
  };
  Xg.exports = Ra;
});

// ../node_modules/prompts/lib/dateparts/index.js
var Qg = d((U$, Jg) => {
  "use strict";
  Jg.exports = {
    DatePart: Ge(),
    Meridiem: Fg(),
    Day: Mg(),
    Hours: jg(),
    Milliseconds: Bg(),
    Minutes: Gg(),
    Month: Vg(),
    Seconds: Kg(),
    Year: zg()
  };
});

// ../node_modules/prompts/lib/elements/date.js
var ny = d((V$, sy) => {
  "use strict";
  var Aa = Q(), RO = st(), { style: Zg, clear: ey, figures: AO } = $e(), { erase: OO, cursor: ty } = ee(), { DatePart: ry, Meridiem: CO, Day: TO,
  Hours: kO, Milliseconds: IO, Minutes: DO, Month: qO, Seconds: $O, Year: FO } = Qg(), NO = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g,
  iy = {
    1: ({ token: t }) => t.replace(/\\(.)/g, "$1"),
    2: (t) => new TO(t),
    // Day // TODO
    3: (t) => new qO(t),
    // Month
    4: (t) => new FO(t),
    // Year
    5: (t) => new CO(t),
    // AM/PM // TODO (special)
    6: (t) => new kO(t),
    // Hours
    7: (t) => new DO(t),
    // Minutes
    8: (t) => new $O(t),
    // Seconds
    9: (t) => new IO(t)
    // Fractional seconds
  }, MO = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, Oa = class extends RO {
    static {
      s(this, "DatePrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(MO, e.locales), this._date = e.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = e.error || "Please Enter A Valid Value", this.validator = e.validate || (() => !0), this.mask =
      e.mask || "YYYY-MM-DD HH:mm:ss", this.clear = ey("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(e) {
      e && this._date.setTime(e.getTime());
    }
    set mask(e) {
      let r;
      for (this.parts = []; r = NO.exec(e); ) {
        let n = r.shift(), o = r.findIndex((a) => a != null);
        this.parts.push(o in iy ? iy[o]({ token: r[o] || n, date: this.date, parts: this.parts, locales: this.locales }) : r[o] || n);
      }
      let i = this.parts.reduce((n, o) => (typeof o == "string" && typeof n[n.length - 1] == "string" ? n[n.length - 1] += o : n.push(o), n),
      []);
      this.parts.splice(0), this.parts.push(...i), this.reset();
    }
    moveCursor(e) {
      this.typed = "", this.cursor = e, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((e) => e instanceof ry)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    async validate() {
      let e = await this.validator(this.value);
      typeof e == "string" && (this.errorMsg = e, e = !1), this.error = !e;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let e = this.parts[this.cursor].prev();
      if (e == null) return this.bell();
      this.moveCursor(this.parts.indexOf(e)), this.render();
    }
    right() {
      let e = this.parts[this.cursor].next();
      if (e == null) return this.bell();
      this.moveCursor(this.parts.indexOf(e)), this.render();
    }
    next() {
      let e = this.parts[this.cursor].next();
      this.moveCursor(e ? this.parts.indexOf(e) : this.parts.findIndex((r) => r instanceof ry)), this.render();
    }
    _(e) {
      /\d/.test(e) && (this.typed += e, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(ty.hide) : this.out.write(ey(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        Zg.symbol(this.done, this.aborted),
        Aa.bold(this.msg),
        Zg.delimiter(!1),
        this.parts.reduce((e, r, i) => e.concat(i === this.cursor && !this.done ? Aa.cyan().underline(r.toString()) : r), []).join("")
      ].join(" "), this.error && (this.outputText += this.errorMsg.split(`
`).reduce(
        (e, r, i) => e + `
${i ? " " : AO.pointerSmall} ${Aa.red().italic(r)}`,
        ""
      )), this.out.write(OO.line + ty.to(0) + this.outputText));
    }
  };
  sy.exports = Oa;
});

// ../node_modules/prompts/lib/elements/number.js
var cy = d((K$, uy) => {
  var Ui = Q(), LO = st(), { cursor: Vi, erase: jO } = ee(), { style: Ca, figures: HO, clear: oy, lines: BO } = $e(), WO = /[0-9]/, Ta = /* @__PURE__ */ s(
  (t) => t !== void 0, "isDef"), ay = /* @__PURE__ */ s((t, e) => {
    let r = Math.pow(10, e);
    return Math.round(t * r) / r;
  }, "round"), ka = class extends LO {
    static {
      s(this, "NumberPrompt");
    }
    constructor(e = {}) {
      super(e), this.transform = Ca.render(e.style), this.msg = e.message, this.initial = Ta(e.initial) ? e.initial : "", this.float = !!e.float,
      this.round = e.round || 2, this.inc = e.increment || 1, this.min = Ta(e.min) ? e.min : -1 / 0, this.max = Ta(e.max) ? e.max : 1 / 0, this.
      errorMsg = e.error || "Please Enter A Valid Value", this.validator = e.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(e) {
      !e && e !== 0 ? (this.placeholder = !0, this.rendered = Ui.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${ay(e, this.round)}`), this._value = ay(e, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(e) {
      return this.float ? parseFloat(e) : parseInt(e);
    }
    valid(e) {
      return e === "-" || e === "." && this.float || WO.test(e);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let e = this.value;
      this.value = e !== "" ? e : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    async validate() {
      let e = await this.validator(this.value);
      typeof e == "string" && (this.errorMsg = e, e = !1), this.error = !e;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      let e = this.value;
      this.value = e !== "" ? e : this.initial, this.done = !0, this.aborted = !1, this.error = !1, this.fire(), this.render(), this.out.write(
      `
`), this.close();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let e = this.value.toString();
      if (e.length === 0) return this.bell();
      this.value = this.parse(e = e.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(e, r) {
      if (!this.valid(e)) return this.bell();
      let i = Date.now();
      if (i - this.lastHit > 1e3 && (this.typed = ""), this.typed += e, this.lastHit = i, this.color = "cyan", e === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Vi.down(BO(this.outputError, this.out.columns) - 1) + oy(this.
      outputError, this.out.columns)), this.out.write(oy(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        Ca.symbol(this.done, this.aborted),
        Ui.bold(this.msg),
        Ca.delimiter(this.done),
        !this.done || !this.done && !this.placeholder ? Ui[this.color]().underline(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((e, r, i) => e + `
${i ? " " : HO.pointerSmall} ${Ui.red().italic(r)}`, "")), this.out.write(jO.line + Vi.to(0) + this.outputText + Vi.save + this.outputError +
      Vi.restore));
    }
  };
  uy.exports = ka;
});

// ../node_modules/prompts/lib/elements/multiselect.js
var Da = d((z$, fy) => {
  "use strict";
  var Ue = Q(), { cursor: GO } = ee(), UO = st(), { clear: ly, figures: bt, style: hy, wrap: VO, entriesToDisplay: YO } = $e(), Ia = class extends UO {
    static {
      s(this, "MultiselectPrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.cursor = e.cursor || 0, this.scrollIndex = e.cursor || 0, this.hint = e.hint || "", this.warn = e.
      warn || "- This option is disabled -", this.minSelected = e.min, this.showMinError = !1, this.maxChoices = e.max, this.instructions = e.
      instructions, this.optionsPerPage = e.optionsPerPage || 10, this.value = e.choices.map((r, i) => (typeof r == "string" && (r = { title: r,
      value: i }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? i : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = ly("", this.out.columns), e.overrideRender || this.render();
    }
    reset() {
      this.value.map((e) => !e.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((e) => e.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let e = this.value.filter((r) => r.selected);
      this.minSelected && e.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let e = this.value[this.cursor];
      if (e.selected)
        e.selected = !1, this.render();
      else {
        if (e.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        e.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let e = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = e), this.render();
    }
    _(e, r) {
      if (e === " ")
        this.handleSpaceToggle();
      else if (e === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${bt.arrowUp}/${bt.arrowDown}: Highlight option
    ${bt.arrowLeft}/${bt.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(e, r, i, n) {
      let o = (r.selected ? Ue.green(bt.radioOn) : bt.radioOff) + " " + n + " ", a, u;
      return r.disabled ? a = e === i ? Ue.gray().underline(r.title) : Ue.strikethrough().gray(r.title) : (a = e === i ? Ue.cyan().underline(
      r.title) : r.title, e === i && r.description && (u = ` - ${r.description}`, (o.length + a.length + u.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (u = `
` + VO(r.description, { margin: o.length, width: this.out.columns })))), o + a + Ue.gray(u || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(e) {
      if (e.length === 0)
        return Ue.red("No matches for this query.");
      let { startIndex: r, endIndex: i } = YO(this.cursor, e.length, this.optionsPerPage), n, o = [];
      for (let a = r; a < i; a++)
        a === r && r > 0 ? n = bt.arrowUp : a === i - 1 && i < e.length ? n = bt.arrowDown : n = " ", o.push(this.renderOption(this.cursor, e[a],
        a, n));
      return `
` + o.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(e) {
      return this.done ? "" : this.paginateOptions(e);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let e = [Ue.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && e.push(Ue.yellow(this.warn)), e.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(GO.hide), super.render();
      let e = [
        hy.symbol(this.done, this.aborted),
        Ue.bold(this.msg),
        hy.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (e += Ue.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), e += this.renderOptions(
      this.value), this.out.write(this.clear + e), this.clear = ly(e, this.out.columns);
    }
  };
  fy.exports = Ia;
});

// ../node_modules/prompts/lib/elements/autocomplete.js
var yy = d((Q$, gy) => {
  "use strict";
  var Cr = Q(), KO = st(), { erase: XO, cursor: dy } = ee(), { style: qa, clear: py, figures: $a, wrap: zO, entriesToDisplay: JO } = $e(), my = /* @__PURE__ */ s(
  (t, e) => t[e] && (t[e].value || t[e].title || t[e]), "getVal"), QO = /* @__PURE__ */ s((t, e) => t[e] && (t[e].title || t[e].value || t[e]),
  "getTitle"), ZO = /* @__PURE__ */ s((t, e) => {
    let r = t.findIndex((i) => i.value === e || i.title === e);
    return r > -1 ? r : void 0;
  }, "getIndex"), Fa = class extends KO {
    static {
      s(this, "AutocompletePrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.suggest = e.suggest, this.choices = e.choices, this.initial = typeof e.initial == "number" ? e.initial :
      ZO(e.choices, e.initial), this.select = this.initial || e.cursor || 0, this.i18n = { noMatches: e.noMatches || "no matches found" }, this.
      fallback = e.fallback || this.initial, this.clearFirst = e.clearFirst || !1, this.suggestions = [], this.input = "", this.limit = e.limit ||
      10, this.cursor = 0, this.transform = qa.render(e.style), this.scale = this.transform.scale, this.render = this.render.bind(this), this.
      complete = this.complete.bind(this), this.clear = py("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(e) {
      this._fb = Number.isSafeInteger(parseInt(e)) ? parseInt(e) : e;
    }
    get fallback() {
      let e;
      return typeof this._fb == "number" ? e = this.choices[this._fb] : typeof this._fb == "string" && (e = { title: this._fb }), e || this.
      _fb || { title: this.i18n.noMatches };
    }
    moveSelect(e) {
      this.select = e, this.suggestions.length > 0 ? this.value = my(this.suggestions, e) : this.value = this.fallback.value, this.fire();
    }
    async complete(e) {
      let r = this.completing = this.suggest(this.input, this.choices), i = await r;
      if (this.completing !== r) return;
      this.suggestions = i.map((o, a, u) => ({ title: QO(u, a), value: my(u, a), description: o.description })), this.completing = !1;
      let n = Math.max(i.length - 1, 0);
      this.moveSelect(Math.min(n, this.select)), e && e();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(e, r) {
      let i = this.input.slice(0, this.cursor), n = this.input.slice(this.cursor);
      this.input = `${i}${e}${n}`, this.cursor = i.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let e = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${e}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let e = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${e}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(e, r, i, n) {
      let o, a = i ? $a.arrowUp : n ? $a.arrowDown : " ", u = r ? Cr.cyan().underline(e.title) : e.title;
      return a = (r ? Cr.cyan($a.pointer) + " " : "  ") + a, e.description && (o = ` - ${e.description}`, (a.length + u.length + o.length >=
      this.out.columns || e.description.split(/\r?\n/).length > 1) && (o = `
` + zO(e.description, { margin: 3, width: this.out.columns }))), a + " " + u + Cr.gray(o || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(dy.hide) : this.out.write(py(this.outputText, this.out.columns)), super.render();
      let { startIndex: e, endIndex: r } = JO(this.select, this.choices.length, this.limit);
      if (this.outputText = [
        qa.symbol(this.done, this.aborted, this.exited),
        Cr.bold(this.msg),
        qa.delimiter(this.completing),
        this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
      ].join(" "), !this.done) {
        let i = this.suggestions.slice(e, r).map((n, o) => this.renderOption(
          n,
          this.select === o + e,
          o === 0 && e > 0,
          o + e === r - 1 && r < this.choices.length
        )).join(`
`);
        this.outputText += `
` + (i || Cr.gray(this.fallback.title));
      }
      this.out.write(XO.line + dy.to(0) + this.outputText);
    }
  };
  gy.exports = Fa;
});

// ../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var vy = d((eF, wy) => {
  "use strict";
  var ot = Q(), { cursor: e0 } = ee(), t0 = Da(), { clear: Sy, style: by, figures: Qt } = $e(), Na = class extends t0 {
    static {
      s(this, "AutocompleteMultiselectPrompt");
    }
    constructor(e = {}) {
      e.overrideRender = !0, super(e), this.inputValue = "", this.clear = Sy("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((e) => e.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let e = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((i) => this.inputValue ? !!(typeof i.title == "string" && i.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof i.value == "string" && i.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((i) => i === e);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let e = this.filteredOptions[this.cursor];
      if (e.selected)
        e.selected = !1, this.render();
      else {
        if (e.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        e.selected = !0, this.render();
      }
    }
    handleInputChange(e) {
      this.inputValue = this.inputValue + e, this.updateFilteredOptions();
    }
    _(e, r) {
      e === " " ? this.handleSpaceToggle() : this.handleInputChange(e);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Qt.arrowUp}/${Qt.arrowDown}: Highlight option
    ${Qt.arrowLeft}/${Qt.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : ot.gray("Enter something to filter")}
`;
    }
    renderOption(e, r, i) {
      let n;
      return r.disabled ? n = e === i ? ot.gray().underline(r.title) : ot.strikethrough().gray(r.title) : n = e === i ? ot.cyan().underline(
      r.title) : r.title, (r.selected ? ot.green(Qt.radioOn) : Qt.radioOff) + "  " + n;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let e = [ot.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && e.push(ot.yellow(this.warn)), e.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(e0.hide), super.render();
      let e = [
        by.symbol(this.done, this.aborted),
        ot.bold(this.msg),
        by.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (e += ot.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), e += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + e), this.clear = Sy(e, this.out.columns);
    }
  };
  wy.exports = Na;
});

// ../node_modules/prompts/lib/elements/confirm.js
var Ry = d((rF, Py) => {
  var _y = Q(), r0 = st(), { style: xy, clear: i0 } = $e(), { erase: s0, cursor: Ey } = ee(), Ma = class extends r0 {
    static {
      s(this, "ConfirmPrompt");
    }
    constructor(e = {}) {
      super(e), this.msg = e.message, this.value = e.initial, this.initialValue = !!e.initial, this.yesMsg = e.yes || "yes", this.yesOption =
      e.yesOption || "(Y/n)", this.noMsg = e.no || "no", this.noOption = e.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(e, r) {
      return e.toLowerCase() === "y" ? (this.value = !0, this.submit()) : e.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(Ey.hide) : this.out.write(i0(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        xy.symbol(this.done, this.aborted),
        _y.bold(this.msg),
        xy.delimiter(this.done),
        this.done ? this.value ? this.yesMsg : this.noMsg : _y.gray(this.initialValue ? this.yesOption : this.noOption)
      ].join(" "), this.out.write(s0.line + Ey.to(0) + this.outputText));
    }
  };
  Py.exports = Ma;
});

// ../node_modules/prompts/lib/elements/index.js
var Oy = d((sF, Ay) => {
  "use strict";
  Ay.exports = {
    TextPrompt: Pg(),
    SelectPrompt: Cg(),
    TogglePrompt: Dg(),
    DatePrompt: ny(),
    NumberPrompt: cy(),
    MultiselectPrompt: Da(),
    AutocompletePrompt: yy(),
    AutocompleteMultiselectPrompt: vy(),
    ConfirmPrompt: Ry()
  };
});

// ../node_modules/prompts/lib/prompts.js
var Ty = d((Cy) => {
  "use strict";
  var Se = Cy, n0 = Oy(), Yi = /* @__PURE__ */ s((t) => t, "noop");
  function Ve(t, e, r = {}) {
    return new Promise((i, n) => {
      let o = new n0[t](e), a = r.onAbort || Yi, u = r.onSubmit || Yi, c = r.onExit || Yi;
      o.on("state", e.onState || Yi), o.on("submit", (h) => i(u(h))), o.on("exit", (h) => i(c(h))), o.on("abort", (h) => n(a(h)));
    });
  }
  s(Ve, "toPrompt");
  Se.text = (t) => Ve("TextPrompt", t);
  Se.password = (t) => (t.style = "password", Se.text(t));
  Se.invisible = (t) => (t.style = "invisible", Se.text(t));
  Se.number = (t) => Ve("NumberPrompt", t);
  Se.date = (t) => Ve("DatePrompt", t);
  Se.confirm = (t) => Ve("ConfirmPrompt", t);
  Se.list = (t) => {
    let e = t.separator || ",";
    return Ve("TextPrompt", t, {
      onSubmit: /* @__PURE__ */ s((r) => r.split(e).map((i) => i.trim()), "onSubmit")
    });
  };
  Se.toggle = (t) => Ve("TogglePrompt", t);
  Se.select = (t) => Ve("SelectPrompt", t);
  Se.multiselect = (t) => {
    t.choices = [].concat(t.choices || []);
    let e = /* @__PURE__ */ s((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return Ve("MultiselectPrompt", t, {
      onAbort: e,
      onSubmit: e
    });
  };
  Se.autocompleteMultiselect = (t) => {
    t.choices = [].concat(t.choices || []);
    let e = /* @__PURE__ */ s((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return Ve("AutocompleteMultiselectPrompt", t, {
      onAbort: e,
      onSubmit: e
    });
  };
  var o0 = /* @__PURE__ */ s((t, e) => Promise.resolve(
    e.filter((r) => r.title.slice(0, t.length).toLowerCase() === t.toLowerCase())
  ), "byTitle");
  Se.autocomplete = (t) => (t.suggest = t.suggest || o0, t.choices = [].concat(t.choices || []), Ve("AutocompletePrompt", t));
});

// ../node_modules/prompts/lib/index.js
var Dy = d((aF, Iy) => {
  "use strict";
  var La = Ty(), a0 = ["suggest", "format", "onState", "validate", "onRender", "type"], ky = /* @__PURE__ */ s(() => {
  }, "noop");
  async function wt(t = [], { onSubmit: e = ky, onCancel: r = ky } = {}) {
    let i = {}, n = wt._override || {};
    t = [].concat(t);
    let o, a, u, c, h, l, p = /* @__PURE__ */ s(async (f, b, m = !1) => {
      if (!(!m && f.validate && f.validate(b) !== !0))
        return f.format ? await f.format(b, i) : b;
    }, "getFormattedAnswer");
    for (a of t)
      if ({ name: c, type: h } = a, typeof h == "function" && (h = await h(o, { ...i }, a), a.type = h), !!h) {
        for (let f in a) {
          if (a0.includes(f)) continue;
          let b = a[f];
          a[f] = typeof b == "function" ? await b(o, { ...i }, l) : b;
        }
        if (l = a, typeof a.message != "string")
          throw new Error("prompt message is required");
        if ({ name: c, type: h } = a, La[h] === void 0)
          throw new Error(`prompt type (${h}) is not defined`);
        if (n[a.name] !== void 0 && (o = await p(a, n[a.name]), o !== void 0)) {
          i[c] = o;
          continue;
        }
        try {
          o = wt._injected ? u0(wt._injected, a.initial) : await La[h](a), i[c] = o = await p(a, o, !0), u = await e(a, o, i);
        } catch {
          u = !await r(a, i);
        }
        if (u) return i;
      }
    return i;
  }
  s(wt, "prompt");
  function u0(t, e) {
    let r = t.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? e : r;
  }
  s(u0, "getInjectedAnswer");
  function c0(t) {
    wt._injected = (wt._injected || []).concat(t);
  }
  s(c0, "inject");
  function l0(t) {
    wt._override = Object.assign({}, t);
  }
  s(l0, "override");
  Iy.exports = Object.assign(wt, { prompt: wt, prompts: La, inject: c0, override: l0 });
});

// ../node_modules/prompts/index.js
var $y = d((cF, qy) => {
  function h0(t) {
    t = (Array.isArray(t) ? t : t.split(".")).map(Number);
    let e = 0, r = process.versions.node.split(".").map(Number);
    for (; e < t.length; e++) {
      if (r[e] > t[e]) return !1;
      if (t[e] > r[e]) return !0;
    }
    return !1;
  }
  s(h0, "isNodeLT");
  qy.exports = h0("8.6.0") ? ng() : Dy();
});

// src/core-server/presets/common-preset.ts
var Zt = Oe(Vr(), 1), Uy = Oe(ur(), 1);
import { dirname as Ki, isAbsolute as P0, join as Tr } from "node:path";
import {
  getDirectoryFromWorkingDir as R0,
  getPreviewBodyTemplate as A0,
  getPreviewHeadTemplate as O0,
  loadEnvs as C0,
  removeAddon as Wy
} from "@storybook/core/common";
import { telemetry as T0 } from "@storybook/core/telemetry";
import { readCsf as k0 } from "@storybook/core/csf-tools";
import { logger as I0 } from "@storybook/core/node-logger";

// src/core-server/server-channel/create-new-story-channel.ts
import { existsSync as hw } from "node:fs";
import { writeFile as fw } from "node:fs/promises";
import { relative as Zc } from "node:path";
import { getStoryId as dw } from "@storybook/core/common";
import { telemetry as ds } from "@storybook/core/telemetry";
import {
  CREATE_NEW_STORYFILE_REQUEST as pw,
  CREATE_NEW_STORYFILE_RESPONSE as ps
} from "@storybook/core/core-events";

// src/core-server/utils/get-new-story-file.ts
import { existsSync as Kr } from "node:fs";
import { basename as zc, dirname as Xc, extname as Jc, join as Et } from "node:path";
import {
  extractProperRendererNameFromFramework as aw,
  getFrameworkName as uw,
  getProjectRoot as cw,
  rendererPackages as lw
} from "@storybook/core/common";

// src/core-server/utils/new-story-templates/javascript.ts
var Uc = Oe(ur(), 1);

// src/core-server/utils/get-component-variable-name.ts
var Yr = /* @__PURE__ */ s(async (t) => (await Promise.resolve().then(() => (Gc(), Wc))).default(t.replace(/^[^a-zA-Z_$]*/, ""), { pascalCase: !0 }).
replace(/[^a-zA-Z_$]+/, ""), "getComponentVariableName");

// src/core-server/utils/new-story-templates/javascript.ts
async function Vc(t) {
  let e = t.componentIsDefaultExport ? await Yr(t.basenameWithoutExtension) : t.componentExportName, r = t.componentIsDefaultExport ? `impor\
t ${e} from './${t.basenameWithoutExtension}';` : `import { ${e} } from './${t.basenameWithoutExtension}';`;
  return Uc.dedent`
  ${r}

  const meta = {
    component: ${e},
  };
  
  export default meta;
  
  export const ${t.exportedStoryName} = {};
  `;
}
s(Vc, "getJavaScriptTemplateForNewStoryFile");

// src/core-server/utils/new-story-templates/typescript.ts
var Yc = Oe(ur(), 1);
async function Kc(t) {
  let e = t.componentIsDefaultExport ? await Yr(t.basenameWithoutExtension) : t.componentExportName, r = t.componentIsDefaultExport ? `impor\
t ${e} from './${t.basenameWithoutExtension}'` : `import { ${e} } from './${t.basenameWithoutExtension}'`;
  return Yc.dedent`
  import type { Meta, StoryObj } from '${t.rendererPackage}';

  ${r};

  const meta = {
    component: ${e},
  } satisfies Meta<typeof ${e}>;

  export default meta;

  type Story = StoryObj<typeof meta>;

  export const ${t.exportedStoryName}: Story = {};
  `;
}
s(Kc, "getTypeScriptTemplateForNewStoryFile");

// src/core-server/utils/get-new-story-file.ts
async function Qc({
  componentFilePath: t,
  componentExportName: e,
  componentIsDefaultExport: r,
  componentExportCount: i
}, n) {
  let o = cw(), a = await uw(n), u = await aw(a), c = Object.entries(lw).find(
    ([, I]) => I === u
  )?.[0], h = zc(t), l = Jc(t), p = h.replace(l, ""), f = Xc(t), { storyFileName: b, isTypescript: m, storyFileExtension: w } = hs(t), _ = `${b}\
.${w}`, P = `${p}.${e}.stories.${w}`, q = "Default", R = m && c ? await Kc({
    basenameWithoutExtension: p,
    componentExportName: e,
    componentIsDefaultExport: r,
    rendererPackage: c,
    exportedStoryName: q
  }) : await Vc({
    basenameWithoutExtension: p,
    componentExportName: e,
    componentIsDefaultExport: r,
    exportedStoryName: q
  });
  return { storyFilePath: fs(Et(o, f), b) && i > 1 ? Et(o, f, P) : Et(o, f, _), exportedStoryName: q, storyFileContent: R, dirname: Xc };
}
s(Qc, "getNewStoryFile");
var hs = /* @__PURE__ */ s((t) => {
  let e = /\.(ts|tsx|mts|cts)$/.test(t), r = zc(t), i = Jc(t), n = r.replace(i, ""), o = e ? "tsx" : "jsx";
  return {
    storyFileName: `${n}.stories`,
    storyFileExtension: o,
    isTypescript: e
  };
}, "getStoryMetadata"), fs = /* @__PURE__ */ s((t, e) => Kr(Et(t, `${e}.ts`)) || Kr(Et(t, `${e}.tsx`)) || Kr(Et(t, `${e}.js`)) || Kr(Et(t, `${e}\
.jsx`)), "doesStoryFileExist");

// src/core-server/server-channel/create-new-story-channel.ts
function el(t, e, r) {
  return t.on(
    pw,
    async (i) => {
      try {
        let { storyFilePath: n, exportedStoryName: o, storyFileContent: a } = await Qc(
          i.payload,
          e
        ), u = Zc(process.cwd(), n), { storyId: c, kind: h } = await dw({ storyFilePath: n, exportedStoryName: o }, e);
        if (hw(n)) {
          t.emit(ps, {
            success: !1,
            id: i.id,
            payload: {
              type: "STORY_FILE_EXISTS",
              kind: h
            },
            error: `A story file already exists at ${u}`
          }), r.disableTelemetry || ds("create-new-story-file", {
            success: !1,
            error: "STORY_FILE_EXISTS"
          });
          return;
        }
        await fw(n, a, "utf-8"), t.emit(ps, {
          success: !0,
          id: i.id,
          payload: {
            storyId: c,
            storyFilePath: Zc(process.cwd(), n),
            exportedStoryName: o
          },
          error: null
        }), r.disableTelemetry || ds("create-new-story-file", {
          success: !0
        });
      } catch (n) {
        t.emit(ps, {
          success: !1,
          id: i.id,
          error: n?.message
        }), r.disableTelemetry || await ds("create-new-story-file", {
          success: !1,
          error: n
        });
      }
    }
  ), t;
}
s(el, "initCreateNewStoryChannel");

// src/core-server/server-channel/file-search-channel.ts
import { readFile as bP } from "node:fs/promises";
import { dirname as wP, join as vo } from "node:path";
import {
  extractProperRendererNameFromFramework as vP,
  getFrameworkName as _P,
  getProjectRoot as xP
} from "@storybook/core/common";
import { telemetry as _o } from "@storybook/core/telemetry";
import {
  FILE_COMPONENT_SEARCH_REQUEST as EP,
  FILE_COMPONENT_SEARCH_RESPONSE as qd
} from "@storybook/core/core-events";

// src/core-server/utils/parser/generic-parser.ts
import { parser as mw, types as Te } from "@storybook/core/babel";
var Xr = class {
  static {
    s(this, "GenericParser");
  }
  /**
   * Parse the content of a file and return the exports
   *
   * @param content The content of the file
   * @returns The exports of the file
   */
  async parse(e) {
    let r = mw.parse(e, {
      allowImportExportEverywhere: !0,
      allowAwaitOutsideFunction: !0,
      allowNewTargetOutsideFunction: !0,
      allowReturnOutsideFunction: !0,
      allowUndeclaredExports: !0,
      plugins: [
        // Language features
        "typescript",
        "jsx",
        // Latest ECMAScript features
        "asyncGenerators",
        "bigInt",
        "classProperties",
        "classPrivateProperties",
        "classPrivateMethods",
        "classStaticBlock",
        "dynamicImport",
        "exportNamespaceFrom",
        "logicalAssignment",
        "moduleStringNames",
        "nullishCoalescingOperator",
        "numericSeparator",
        "objectRestSpread",
        "optionalCatchBinding",
        "optionalChaining",
        "privateIn",
        "regexpUnicodeSets",
        "topLevelAwait",
        // ECMAScript proposals
        "asyncDoExpressions",
        "decimal",
        "decorators",
        "decoratorAutoAccessors",
        "deferredImportEvaluation",
        "destructuringPrivate",
        "doExpressions",
        "explicitResourceManagement",
        "exportDefaultFrom",
        "functionBind",
        "functionSent",
        "importAttributes",
        "importReflection",
        "moduleBlocks",
        "partialApplication",
        "recordAndTuple",
        "sourcePhaseImports",
        "throwExpressions"
      ]
    }), i = [];
    return r.program.body.forEach(/* @__PURE__ */ s(function(o) {
      Te.isExportNamedDeclaration(o) ? (Te.isFunctionDeclaration(o.declaration) && Te.isIdentifier(o.declaration.id) && i.push({
        name: o.declaration.id.name,
        default: !1
      }), Te.isClassDeclaration(o.declaration) && Te.isIdentifier(o.declaration.id) && i.push({
        name: o.declaration.id.name,
        default: !1
      }), o.declaration === null && o.specifiers.length > 0 && o.specifiers.forEach((a) => {
        Te.isExportSpecifier(a) && Te.isIdentifier(a.exported) && i.push({
          name: a.exported.name,
          default: !1
        });
      }), Te.isVariableDeclaration(o.declaration) && o.declaration.declarations.forEach((a) => {
        Te.isVariableDeclarator(a) && Te.isIdentifier(a.id) && i.push({
          name: a.id.name,
          default: !1
        });
      })) : Te.isExportDefaultDeclaration(o) && i.push({
        name: "default",
        default: !0
      });
    }, "traverse")), { exports: i };
  }
};

// src/core-server/utils/parser/index.ts
function tl(t) {
  switch (t) {
    default:
      return new Xr();
  }
}
s(tl, "getParser");

// src/core-server/utils/search-files.ts
var yP = ["js", "mjs", "cjs", "jsx", "mts", "ts", "tsx", "cts"], SP = [
  "**/node_modules/**",
  "**/*.spec.*",
  "**/*.test.*",
  "**/*.stories.*",
  "**/storybook-static/**"
];
async function Dd({
  searchQuery: t,
  cwd: e,
  ignoredFiles: r = SP,
  fileExtensions: i = yP
}) {
  let { globby: n, isDynamicPattern: o } = await Promise.resolve().then(() => (Id(), kd)), a = o(t, { cwd: e }), c = /(\.[a-z]+)$/i.test(t),
  h = `{${i.join(",")}}`, l = a ? t : c ? [`**/*${t}*`, `**/*${t}*/**`] : [
    `**/*${t}*.${h}`,
    `**/*${t}*/**/*.${h}`
  ];
  return (await n(l, {
    ignore: r,
    gitignore: !0,
    caseSensitiveMatch: !1,
    cwd: e,
    objectMode: !0
  })).map((f) => f.path).filter((f) => i.some((b) => f.endsWith(`.${b}`)));
}
s(Dd, "searchFiles");

// src/core-server/server-channel/file-search-channel.ts
async function $d(t, e, r) {
  return t.on(
    EP,
    async (i) => {
      let n = i.id;
      try {
        if (!n)
          return;
        let o = await _P(e), a = await vP(
          o
        ), u = xP(), h = (await Dd({
          searchQuery: n,
          cwd: u
        })).map(async (l) => {
          let p = tl(a);
          try {
            let f = await bP(vo(u, l), "utf-8"), { storyFileName: b } = hs(vo(u, l)), m = wP(l), w = fs(vo(u, m), b), _ = await p.parse(f);
            return {
              filepath: l,
              exportedComponents: _.exports,
              storyFileExists: w
            };
          } catch (f) {
            return r.disableTelemetry || _o("create-new-story-file-search", {
              success: !1,
              error: `Could not parse file: ${f}`
            }), {
              filepath: l,
              storyFileExists: !1,
              exportedComponents: null
            };
          }
        });
        r.disableTelemetry || _o("create-new-story-file-search", {
          success: !0,
          payload: {
            fileCount: h.length
          }
        }), t.emit(qd, {
          success: !0,
          id: n,
          payload: {
            files: await Promise.all(h)
          },
          error: null
        });
      } catch (o) {
        t.emit(qd, {
          success: !1,
          id: n ?? "",
          error: `An error occurred while searching for components in the project.
${o?.message}`
        }), r.disableTelemetry || _o("create-new-story-file-search", {
          success: !1,
          error: `An error occured while searching for components: ${o}`
        });
      }
    }
  ), t;
}
s($d, "initFileSearchChannel");

// src/core-server/utils/constants.ts
import { dirname as PP, join as RP } from "node:path";
var Fd = [
  {
    from: RP(PP(A.resolve("@storybook/core/package.json")), "assets", "browser"),
    to: "/sb-common-assets"
  }
];

// src/core-server/utils/save-story/save-story.ts
import { writeFile as CP } from "node:fs/promises";
import { basename as TP, join as kP } from "node:path";
import { formatFileContent as IP } from "@storybook/core/common";
import { isExampleStoryId as DP, telemetry as jd } from "@storybook/core/telemetry";
import { storyNameFromExport as Hd, toId as qP } from "@storybook/csf";
import {
  SAVE_STORY_REQUEST as $P,
  SAVE_STORY_RESPONSE as Bd,
  STORY_RENDERED as Wd
} from "@storybook/core/core-events";
import { printCsf as FP, readCsf as NP } from "@storybook/core/csf-tools";
import { logger as MP } from "@storybook/core/node-logger";

// src/core-server/utils/save-story/duplicate-story-with-new-name.ts
import { types as gr, traverse as Nd } from "@storybook/core/babel";

// src/core-server/utils/save-story/utils.ts
var Pe = class extends Error {
  static {
    s(this, "SaveStoryError");
  }
};

// src/core-server/utils/save-story/duplicate-story-with-new-name.ts
var Md = /* @__PURE__ */ s((t, e, r) => {
  let i = t._storyExports[e], n = gr.cloneNode(i);
  if (!n)
    throw new Pe("cannot clone Node");
  let o = !1;
  if (Nd(n, {
    Identifier(a) {
      o || a.node.name === e && (o = !0, a.node.name = r);
    },
    ObjectProperty(a) {
      let u = a.get("key");
      u.isIdentifier() && u.node.name === "args" && a.remove();
    },
    noScope: !0
  }), gr.isArrowFunctionExpression(n.init) || gr.isCallExpression(n.init))
    throw new Pe("Creating a new story based on a CSF2 story is not supported");
  return Nd(t._ast, {
    Program(a) {
      a.pushContainer(
        "body",
        gr.exportNamedDeclaration(gr.variableDeclaration("const", [n]))
      );
    }
  }), n;
}, "duplicateStoryWithNewName");

// src/core-server/utils/save-story/update-args-in-csf-file.ts
import { types as z, traverse as OP } from "@storybook/core/babel";

// src/core-server/utils/save-story/valueToAST.ts
import { parser as AP, types as Ze } from "@storybook/core/babel";
function Ci(t) {
  if (t === null)
    return Ze.nullLiteral();
  switch (typeof t) {
    case "function":
      return AP.parse(t.toString(), {
        allowReturnOutsideFunction: !0,
        allowSuperOutsideMethod: !0
      }).program.body[0]?.expression;
    case "number":
      return Ze.numericLiteral(t);
    case "string":
      return Ze.stringLiteral(t);
    case "boolean":
      return Ze.booleanLiteral(t);
    case "undefined":
      return Ze.identifier("undefined");
    default:
      return Array.isArray(t) ? Ze.arrayExpression(t.map(Ci)) : Ze.objectExpression(
        Object.keys(t).filter((r) => typeof t[r] < "u").map((r) => {
          let i = t[r];
          return Ze.objectProperty(Ze.stringLiteral(r), Ci(i));
        })
      );
  }
}
s(Ci, "valueToAST");

// src/core-server/utils/save-story/update-args-in-csf-file.ts
var Ld = /* @__PURE__ */ s(async (t, e) => {
  let r = !1, i = Object.fromEntries(
    Object.entries(e).map(([n, o]) => [n, Ci(o)])
  );
  if (z.isArrowFunctionExpression(t) || z.isCallExpression(t))
    throw new Pe("Updating a CSF2 story is not supported");
  if (z.isObjectExpression(t)) {
    let n = t.properties, o = n.find((a) => {
      if (z.isObjectProperty(a)) {
        let u = a.key;
        return z.isIdentifier(u) && u.name === "args";
      }
      return !1;
    });
    if (o) {
      if (z.isObjectProperty(o)) {
        let a = o.value;
        if (z.isObjectExpression(a)) {
          a.properties.forEach((c) => {
            if (z.isObjectProperty(c)) {
              let h = c.key;
              z.isIdentifier(h) && h.name in i && (c.value = i[h.name], delete i[h.name]);
            }
          });
          let u = Object.entries(i);
          Object.keys(i).length && u.forEach(([c, h]) => {
            a.properties.push(z.objectProperty(z.identifier(c), h));
          });
        }
      }
    } else
      n.unshift(
        z.objectProperty(
          z.identifier("args"),
          z.objectExpression(
            Object.entries(i).map(([a, u]) => z.objectProperty(z.identifier(a), u))
          )
        )
      );
    return;
  }
  OP(t, {
    ObjectExpression(n) {
      if (r)
        return;
      r = !0;
      let a = n.get("properties").find((u) => {
        if (u.isObjectProperty()) {
          let c = u.get("key");
          return c.isIdentifier() && c.node.name === "args";
        }
        return !1;
      });
      if (a) {
        if (a.isObjectProperty()) {
          let u = a.get("value");
          if (u.isObjectExpression()) {
            u.traverse({
              ObjectProperty(h) {
                let l = h.get("key");
                l.isIdentifier() && l.node.name in i && (h.get("value").replaceWith(i[l.node.name]), delete i[l.node.name]);
              },
              noScope: !0
            });
            let c = Object.entries(i);
            Object.keys(i).length && c.forEach(([h, l]) => {
              u.pushContainer("properties", z.objectProperty(z.identifier(h), l));
            });
          }
        }
      } else
        n.unshiftContainer(
          "properties",
          z.objectProperty(
            z.identifier("args"),
            z.objectExpression(
              Object.entries(i).map(([u, c]) => z.objectProperty(z.identifier(u), c))
            )
          )
        );
    },
    noScope: !0
  });
}, "updateArgsInCsfFile");

// src/core-server/utils/save-story/save-story.ts
var LP = /* @__PURE__ */ s((t) => JSON.parse(t, (e, r) => r === "__sb_empty_function_arg__" ? () => {
} : r), "parseArgs"), jP = /* @__PURE__ */ s((t, e) => {
  let r = "([\\s\\S])", i = "(\\r\\n|\\r|\\n)", n = i + "};" + i, o = new RegExp(
    // Looks for an export by the given name, considers the first closing brace on its own line
    // to be the end of the story definition.
    `^(?<before>${r}*)(?<story>export const ${e} =${r}+?${n})(?<after>${r}*)$`
  ), { before: a, story: u, after: c } = t.match(o)?.groups || {};
  return u ? a + u.replaceAll(/(\r\n|\r|\n)(\r\n|\r|\n)([ \t]*[a-z0-9_]+): /gi, "$2$3:") + c : t;
}, "removeExtraNewlines");
function Gd(t, e, r) {
  t.on($P, async ({ id: i, payload: n }) => {
    let { csfId: o, importPath: a, args: u, name: c } = n, h, l, p, f, b;
    try {
      p = TP(a), f = kP(process.cwd(), a);
      let m = await NP(f, {
        makeTitle: /* @__PURE__ */ s((H) => H || "myTitle", "makeTitle")
      }), w = m.parse(), _ = Object.entries(w._stories), [P, q] = o.split("--");
      l = c && Hd(c), h = l && qP(P, l);
      let [R] = _.find(([H, $]) => $.id.endsWith(`--${q}`)) || [];
      if (!R)
        throw new Pe("Source story not found.");
      if (c && m.getStoryExport(c))
        throw new Pe("Story already exists.");
      b = Hd(R), await Ld(
        c ? Md(w, R, c) : m.getStoryExport(R),
        u ? LP(u) : {}
      );
      let te = await IP(
        f,
        jP(FP(m).code, c || R)
      );
      await Promise.all([
        new Promise((H) => {
          t.on(Wd, H), setTimeout(() => H(t.off(Wd, H)), 3e3);
        }),
        CP(f, te)
      ]), t.emit(Bd, {
        id: i,
        success: !0,
        payload: {
          csfId: o,
          newStoryId: h,
          newStoryName: l,
          newStoryExportName: c,
          sourceFileContent: te,
          sourceFileName: p,
          sourceStoryName: b,
          sourceStoryExportName: R
        },
        error: null
      });
      let I = DP(h ?? o);
      !r.disableTelemetry && !I && await jd("save-story", {
        action: c ? "createStory" : "updateStory",
        success: !0
      });
    } catch (m) {
      t.emit(Bd, {
        id: i,
        success: !1,
        error: m instanceof Pe ? m.message : "Unknown error"
      }), MP.error(
        `Error writing to ${f}:
${m.stack || m.message || m.toString()}`
      ), !r.disableTelemetry && !(m instanceof Pe) && await jd("save-story", {
        action: c ? "createStory" : "updateStory",
        success: !1,
        error: m
      });
    }
  });
}
s(Gd, "initializeSaveStory");

// src/core-server/utils/server-statics.ts
import { basename as UD, isAbsolute as rR, posix as iR, resolve as sR, sep as nR, win32 as oR } from "node:path";
import { getDirectoryFromWorkingDir as YD } from "@storybook/core/common";
import { logger as XD } from "@storybook/core/node-logger";

// node_modules/chalk/source/vendor/ansi-styles/index.js
var Ud = /* @__PURE__ */ s((t = 0) => (e) => `\x1B[${e + t}m`, "wrapAnsi16"), Vd = /* @__PURE__ */ s((t = 0) => (e) => `\x1B[${38 + t};5;${e}\
m`, "wrapAnsi256"), Yd = /* @__PURE__ */ s((t = 0) => (e, r, i) => `\x1B[${38 + t};2;${e};${r};${i}m`, "wrapAnsi16m"), Y = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, AD = Object.keys(Y.modifier), HP = Object.keys(Y.color), BP = Object.keys(Y.bgColor), OD = [...HP, ...BP];
function WP() {
  let t = /* @__PURE__ */ new Map();
  for (let [e, r] of Object.entries(Y)) {
    for (let [i, n] of Object.entries(r))
      Y[i] = {
        open: `\x1B[${n[0]}m`,
        close: `\x1B[${n[1]}m`
      }, r[i] = Y[i], t.set(n[0], n[1]);
    Object.defineProperty(Y, e, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(Y, "codes", {
    value: t,
    enumerable: !1
  }), Y.color.close = "\x1B[39m", Y.bgColor.close = "\x1B[49m", Y.color.ansi = Ud(), Y.color.ansi256 = Vd(), Y.color.ansi16m = Yd(), Y.bgColor.
  ansi = Ud(10), Y.bgColor.ansi256 = Vd(10), Y.bgColor.ansi16m = Yd(10), Object.defineProperties(Y, {
    rgbToAnsi256: {
      value(e, r, i) {
        return e === r && r === i ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 *
        Math.round(r / 255 * 5) + Math.round(i / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(e) {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(e.toString(16));
        if (!r)
          return [0, 0, 0];
        let [i] = r;
        i.length === 3 && (i = [...i].map((o) => o + o).join(""));
        let n = Number.parseInt(i, 16);
        return [
          /* eslint-disable no-bitwise */
          n >> 16 & 255,
          n >> 8 & 255,
          n & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ s((e) => Y.rgbToAnsi256(...Y.hexToRgb(e)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(e) {
        if (e < 8)
          return 30 + e;
        if (e < 16)
          return 90 + (e - 8);
        let r, i, n;
        if (e >= 232)
          r = ((e - 232) * 10 + 8) / 255, i = r, n = r;
        else {
          e -= 16;
          let u = e % 36;
          r = Math.floor(e / 36) / 5, i = Math.floor(u / 6) / 5, n = u % 6 / 5;
        }
        let o = Math.max(r, i, n) * 2;
        if (o === 0)
          return 30;
        let a = 30 + (Math.round(n) << 2 | Math.round(i) << 1 | Math.round(r));
        return o === 2 && (a += 60), a;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ s((e, r, i) => Y.ansi256ToAnsi(Y.rgbToAnsi256(e, r, i)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ s((e) => Y.ansi256ToAnsi(Y.hexToAnsi256(e)), "value"),
      enumerable: !1
    }
  }), Y;
}
s(WP, "assembleStyles");
var GP = WP(), De = GP;

// node_modules/chalk/source/vendor/supports-color/index.js
import xo from "node:process";
import UP from "node:os";
import Kd from "node:tty";
function Re(t, e = globalThis.Deno ? globalThis.Deno.args : xo.argv) {
  let r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", i = e.indexOf(r + t), n = e.indexOf("--");
  return i !== -1 && (n === -1 || i < n);
}
s(Re, "hasFlag");
var { env: J } = xo, Ti;
Re("no-color") || Re("no-colors") || Re("color=false") || Re("color=never") ? Ti = 0 : (Re("color") || Re("colors") || Re("color=true") || Re(
"color=always")) && (Ti = 1);
function VP() {
  if ("FORCE_COLOR" in J)
    return J.FORCE_COLOR === "true" ? 1 : J.FORCE_COLOR === "false" ? 0 : J.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(J.FORCE_COLOR,
    10), 3);
}
s(VP, "envForceColor");
function YP(t) {
  return t === 0 ? !1 : {
    level: t,
    hasBasic: !0,
    has256: t >= 2,
    has16m: t >= 3
  };
}
s(YP, "translateLevel");
function KP(t, { streamIsTTY: e, sniffFlags: r = !0 } = {}) {
  let i = VP();
  i !== void 0 && (Ti = i);
  let n = r ? Ti : i;
  if (n === 0)
    return 0;
  if (r) {
    if (Re("color=16m") || Re("color=full") || Re("color=truecolor"))
      return 3;
    if (Re("color=256"))
      return 2;
  }
  if ("TF_BUILD" in J && "AGENT_NAME" in J)
    return 1;
  if (t && !e && n === void 0)
    return 0;
  let o = n || 0;
  if (J.TERM === "dumb")
    return o;
  if (xo.platform === "win32") {
    let a = UP.release().split(".");
    return Number(a[0]) >= 10 && Number(a[2]) >= 10586 ? Number(a[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in J)
    return "GITHUB_ACTIONS" in J || "GITEA_ACTIONS" in J ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((a) => a in
    J) || J.CI_NAME === "codeship" ? 1 : o;
  if ("TEAMCITY_VERSION" in J)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(J.TEAMCITY_VERSION) ? 1 : 0;
  if (J.COLORTERM === "truecolor" || J.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in J) {
    let a = Number.parseInt((J.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (J.TERM_PROGRAM) {
      case "iTerm.app":
        return a >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(J.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(J.TERM) || "COLORTERM" in J ?
  1 : o;
}
s(KP, "_supportsColor");
function Xd(t, e = {}) {
  let r = KP(t, {
    streamIsTTY: t && t.isTTY,
    ...e
  });
  return YP(r);
}
s(Xd, "createSupportsColor");
var XP = {
  stdout: Xd({ isTTY: Kd.isatty(1) }),
  stderr: Xd({ isTTY: Kd.isatty(2) })
}, zd = XP;

// node_modules/chalk/source/utilities.js
function Jd(t, e, r) {
  let i = t.indexOf(e);
  if (i === -1)
    return t;
  let n = e.length, o = 0, a = "";
  do
    a += t.slice(o, i) + e + r, o = i + n, i = t.indexOf(e, o);
  while (i !== -1);
  return a += t.slice(o), a;
}
s(Jd, "stringReplaceAll");
function Qd(t, e, r, i) {
  let n = 0, o = "";
  do {
    let a = t[i - 1] === "\r";
    o += t.slice(n, a ? i - 1 : i) + e + (a ? `\r
` : `
`) + r, n = i + 1, i = t.indexOf(`
`, n);
  } while (i !== -1);
  return o += t.slice(n), o;
}
s(Qd, "stringEncaseCRLFWithFirstIndex");

// node_modules/chalk/source/index.js
var { stdout: Zd, stderr: ep } = zd, Eo = Symbol("GENERATOR"), Yt = Symbol("STYLER"), yr = Symbol("IS_EMPTY"), tp = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], Kt = /* @__PURE__ */ Object.create(null), zP = /* @__PURE__ */ s((t, e = {}) => {
  if (e.level && !(Number.isInteger(e.level) && e.level >= 0 && e.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let r = Zd ? Zd.level : 0;
  t.level = e.level === void 0 ? r : e.level;
}, "applyOptions");
var JP = /* @__PURE__ */ s((t) => {
  let e = /* @__PURE__ */ s((...r) => r.join(" "), "chalk");
  return zP(e, t), Object.setPrototypeOf(e, Sr.prototype), e;
}, "chalkFactory");
function Sr(t) {
  return JP(t);
}
s(Sr, "createChalk");
Object.setPrototypeOf(Sr.prototype, Function.prototype);
for (let [t, e] of Object.entries(De))
  Kt[t] = {
    get() {
      let r = ki(this, Ro(e.open, e.close, this[Yt]), this[yr]);
      return Object.defineProperty(this, t, { value: r }), r;
    }
  };
Kt.visible = {
  get() {
    let t = ki(this, this[Yt], !0);
    return Object.defineProperty(this, "visible", { value: t }), t;
  }
};
var Po = /* @__PURE__ */ s((t, e, r, ...i) => t === "rgb" ? e === "ansi16m" ? De[r].ansi16m(...i) : e === "ansi256" ? De[r].ansi256(De.rgbToAnsi256(
...i)) : De[r].ansi(De.rgbToAnsi(...i)) : t === "hex" ? Po("rgb", e, r, ...De.hexToRgb(...i)) : De[r][t](...i), "getModelAnsi"), QP = ["rgb",
"hex", "ansi256"];
for (let t of QP) {
  Kt[t] = {
    get() {
      let { level: r } = this;
      return function(...i) {
        let n = Ro(Po(t, tp[r], "color", ...i), De.color.close, this[Yt]);
        return ki(this, n, this[yr]);
      };
    }
  };
  let e = "bg" + t[0].toUpperCase() + t.slice(1);
  Kt[e] = {
    get() {
      let { level: r } = this;
      return function(...i) {
        let n = Ro(Po(t, tp[r], "bgColor", ...i), De.bgColor.close, this[Yt]);
        return ki(this, n, this[yr]);
      };
    }
  };
}
var ZP = Object.defineProperties(() => {
}, {
  ...Kt,
  level: {
    enumerable: !0,
    get() {
      return this[Eo].level;
    },
    set(t) {
      this[Eo].level = t;
    }
  }
}), Ro = /* @__PURE__ */ s((t, e, r) => {
  let i, n;
  return r === void 0 ? (i = t, n = e) : (i = r.openAll + t, n = e + r.closeAll), {
    open: t,
    close: e,
    openAll: i,
    closeAll: n,
    parent: r
  };
}, "createStyler"), ki = /* @__PURE__ */ s((t, e, r) => {
  let i = /* @__PURE__ */ s((...n) => eR(i, n.length === 1 ? "" + n[0] : n.join(" ")), "builder");
  return Object.setPrototypeOf(i, ZP), i[Eo] = t, i[Yt] = e, i[yr] = r, i;
}, "createBuilder"), eR = /* @__PURE__ */ s((t, e) => {
  if (t.level <= 0 || !e)
    return t[yr] ? "" : e;
  let r = t[Yt];
  if (r === void 0)
    return e;
  let { openAll: i, closeAll: n } = r;
  if (e.includes("\x1B"))
    for (; r !== void 0; )
      e = Jd(e, r.close, r.open), r = r.parent;
  let o = e.indexOf(`
`);
  return o !== -1 && (e = Qd(e, n, i, o)), i + e + n;
}, "applyStyle");
Object.defineProperties(Sr.prototype, Kt);
var tR = Sr(), HD = Sr({ level: ep ? ep.level : 0 });
var rp = tR;

// src/core-server/utils/server-statics.ts
var ip = Oe(Vr(), 1), sp = Oe(ur(), 1);
import QD from "express";
var np = /* @__PURE__ */ s(async (t) => {
  let e = t.lastIndexOf(":"), i = oR.isAbsolute(t) && e === 1, n = e !== -1 && !i ? e : t.length, a = (t.substring(n + 1) || "/").split(nR).
  join(iR.sep), u = t.substring(0, n), c = rR(u) ? u : `./${u}`, h = sR(c), l = a.replace(/^\/?/, "./"), p = l.substring(1);
  if (!await (0, ip.pathExists)(h))
    throw new Error(
      sp.dedent`
        Failed to load static files, no such directory: ${rp.cyan(h)}
        Make sure this directory exists.
      `
    );
  return { staticDir: c, staticPath: h, targetDir: l, targetEndpoint: p };
}, "parseStaticDir");

// src/core-server/utils/whats-new.ts
var Hy = Oe(Vr(), 1);
import { findConfigFile as Ny } from "@storybook/core/common";
import { telemetry as S0 } from "@storybook/core/telemetry";
import {
  REQUEST_WHATS_NEW_DATA as b0,
  RESULT_WHATS_NEW_DATA as My,
  SET_WHATS_NEW_CACHE as w0,
  TELEMETRY_ERROR as v0,
  TOGGLE_WHATS_NEW_NOTIFICATIONS as _0
} from "@storybook/core/core-events";
import { printConfig as x0, readConfig as Ly } from "@storybook/core/csf-tools";
import { logger as jy } from "@storybook/core/node-logger";

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var aR = process.env.NODE_ENV === "production", Ao = "Invariant failed";
function Oo(t, e) {
  if (!t) {
    if (aR)
      throw new Error(Ao);
    var r = typeof e == "function" ? e() : e, i = r ? "".concat(Ao, ": ").concat(r) : Ao;
    throw new Error(i);
  }
}
s(Oo, "invariant");

// src/core-server/withTelemetry.ts
var Fy = Oe($y(), 1);
import { cache as ja, loadAllPresets as f0 } from "@storybook/core/common";
import { getPrecedingUpgrade as d0, oneWayHash as p0, telemetry as m0 } from "@storybook/core/telemetry";
import { logger as pF } from "@storybook/core/node-logger";
var g0 = /* @__PURE__ */ s(async () => {
  if (process.env.CI)
    return;
  let { enableCrashReports: t } = await (0, Fy.default)({
    type: "confirm",
    name: "enableCrashReports",
    message: "Would you like to help improve Storybook by sending anonymous crash reports?",
    initial: !0
  });
  return await ja.set("enableCrashReports", t), t;
}, "promptCrashReports");
async function y0({
  cliOptions: t,
  presetOptions: e,
  skipPrompt: r
}) {
  if (t.disableTelemetry)
    return "none";
  if (!e)
    return "full";
  let n = await (await f0(e)).apply("core");
  if (n?.enableCrashReports !== void 0)
    return n.enableCrashReports ? "full" : "error";
  if (n?.disableTelemetry)
    return "none";
  let o = await ja.get("enableCrashReports") ?? await ja.get("enableCrashreports");
  if (o !== void 0)
    return o ? "full" : "error";
  if (r)
    return "error";
  let a = await g0();
  return a !== void 0 ? a ? "full" : "error" : "full";
}
s(y0, "getErrorLevel");
async function Ha(t, e, r) {
  try {
    let i = "error";
    try {
      i = await y0(r);
    } catch {
    }
    if (i !== "none") {
      let n = await d0(), o = t, a;
      "message" in o ? a = o.message ? p0(o.message) : "EMPTY_MESSAGE" : a = "NO_MESSAGE";
      let { code: u, name: c, category: h } = o;
      await m0(
        "error",
        {
          code: u,
          name: c,
          category: h,
          eventType: e,
          precedingUpgrade: n,
          error: i === "full" ? o : void 0,
          errorHash: a,
          // if we ever end up sending a non-error instance, we'd like to know
          isErrorInstance: o instanceof Error
        },
        {
          immediate: !0,
          configDir: r.cliOptions.configDir || r.presetOptions?.configDir,
          enableCrashReports: i === "full"
        }
      );
    }
  } catch {
  }
}
s(Ha, "sendTelemetryError");

// src/core-server/utils/whats-new.ts
var Ba = "whats-new-cache", E0 = "https://storybook.js.org/whats-new/v1";
function By(t, e, r) {
  t.on(w0, async (i) => {
    let n = await e.cache.get(Ba).catch((o) => (jy.verbose(o), {}));
    await e.cache.set(Ba, { ...n, ...i });
  }), t.on(b0, async () => {
    try {
      let i = await fetch(E0).then(async (h) => {
        if (h.ok)
          return h.json();
        throw h;
      }), n = Ny("main", e.configDir);
      if (!n)
        throw new Error(`unable to find storybook main file in ${e.configDir}`);
      let a = (await Ly(n)).getFieldValue([
        "core",
        "disableWhatsNewNotifications"
      ]), u = await e.cache.get(Ba) ?? {}, c = {
        ...i,
        status: "SUCCESS",
        postIsRead: i.url === u.lastReadPost,
        showNotification: i.url !== u.lastDismissedPost && i.url !== u.lastReadPost,
        disableWhatsNewNotifications: a
      };
      t.emit(My, { data: c });
    } catch (i) {
      jy.verbose(i instanceof Error ? i.message : String(i)), t.emit(My, {
        data: { status: "ERROR" }
      });
    }
  }), t.on(
    _0,
    async ({ disableWhatsNewNotifications: i }) => {
      let n = r.disableTelemetry !== !0;
      try {
        let o = Ny("main", e.configDir);
        Oo(o, `unable to find storybook main file in ${e.configDir}`);
        let a = await Ly(o);
        a.setFieldValue(["core", "disableWhatsNewNotifications"], i), await Hy.default.writeFile(o, x0(a).code), n && await S0("core-config",
        { disableWhatsNewNotifications: i });
      } catch (o) {
        Oo(o instanceof Error), n && await Ha(o, "core-config", {
          cliOptions: e,
          presetOptions: { ...e, corePresets: [], overridePresets: [] },
          skipPrompt: !0
        });
      }
    }
  ), t.on(v0, async (i) => {
    r.disableTelemetry !== !0 && await Ha(i, "browser", {
      cliOptions: e,
      presetOptions: { ...e, corePresets: [], overridePresets: [] },
      skipPrompt: !0
    });
  });
}
s(By, "initializeWhatsNew");

// src/core-server/presets/common-preset.ts
var D0 = /* @__PURE__ */ s((t, e = {}) => Object.entries(e).reduce((r, [i, n]) => r.replace(new RegExp(`%${i}%`, "g"), n), t), "interpolate"),
Gy = Tr(
  Ki(A.resolve("@storybook/core/package.json")),
  "/assets/browser/favicon.svg"
), NF = /* @__PURE__ */ s(async (t = []) => [
  ...Fd,
  ...t
], "staticDirs"), MF = /* @__PURE__ */ s(async (t, e) => {
  if (t)
    return t;
  let r = await e.presets.apply("staticDirs"), i = r ? r.map((n) => typeof n == "string" ? n : `${n.from}:${n.to}`) : [];
  if (i && i.length > 0) {
    let o = (await Promise.all(
      i.map(async (a) => {
        let u = [], c = r && !P0(a) ? R0({
          configDir: e.configDir,
          workingDir: process.cwd(),
          directory: a
        }) : a, { staticPath: h, targetEndpoint: l } = await np(c);
        if (l === "/") {
          let f = Tr(h, "favicon.svg");
          await (0, Zt.pathExists)(f) && u.push(f);
        }
        if (l === "/") {
          let f = Tr(h, "favicon.ico");
          await (0, Zt.pathExists)(f) && u.push(f);
        }
        return u;
      })
    )).reduce((a, u) => a.concat(u), []);
    return o.length > 1 && I0.warn(Uy.dedent`
        Looks like multiple favicons were detected. Using the first one.

        ${o.join(", ")}
        `), o[0] || Gy;
  }
  return Gy;
}, "favicon"), LF = /* @__PURE__ */ s(async (t, e) => {
  let { presets: r } = e, i = await r.apply("babelDefault", {}, e) ?? {};
  return {
    ...i,
    // This override makes sure that we will never transpile babel further down then the browsers that storybook supports.
    // This is needed to support the mount property of the context described here:
    // https://storybook.js.org/docs/writing-tests/interaction-testing#run-code-before-each-test
    overrides: [
      ...i?.overrides ?? [],
      {
        include: /\.(story|stories)\.[cm]?[jt]sx?$/,
        presets: [
          [
            "@babel/preset-env",
            {
              bugfixes: !0,
              targets: {
                // This is the same browser supports that we use to bundle our manager and preview code.
                chrome: 100,
                safari: 15,
                firefox: 91
              }
            }
          ]
        ]
      }
    ]
  };
}, "babel"), jF = /* @__PURE__ */ s((t, e) => t || e.packageJson?.name || !1, "title"), HF = /* @__PURE__ */ s((t, e) => t || e.loglevel || "\
info", "logLevel"), BF = /* @__PURE__ */ s(async (t, { configDir: e, presets: r }) => {
  let i = await r.apply("env");
  return O0(e, i);
}, "previewHead"), WF = /* @__PURE__ */ s(async () => C0({ production: !0 }).raw, "env"), GF = /* @__PURE__ */ s(async (t, { configDir: e, presets: r }) => {
  let i = await r.apply("env");
  return A0(e, i);
}, "previewBody"), UF = /* @__PURE__ */ s(() => ({
  check: !1,
  // 'react-docgen' faster than `react-docgen-typescript` but produces lower quality results
  reactDocgen: "react-docgen",
  reactDocgenTypescriptOptions: {
    shouldExtractLiteralValuesFromEnum: !0,
    shouldRemoveUndefinedFromOptional: !0,
    propFilter: /* @__PURE__ */ s((t) => t.parent ? !/node_modules/.test(t.parent.fileName) : !0, "propFilter"),
    // NOTE: this default cannot be changed
    savePropValueAsString: !0
  }
}), "typescript"), q0 = /* @__PURE__ */ s((t) => {
  if (t !== void 0) {
    if (t.toUpperCase() === "FALSE")
      return !1;
    if (t.toUpperCase() === "TRUE" || typeof t == "string")
      return !0;
  }
}, "optionalEnvToBoolean"), VF = /* @__PURE__ */ s((t, e) => {
  let r = Wy;
  return e.disableTelemetry || (r = /* @__PURE__ */ s(async (i, n) => (await T0("remove", { addon: i, source: "api" }), Wy(i, n)), "removeAd\
don")), { ...t, removeAddon: r };
}, "experimental_serverAPI"), YF = /* @__PURE__ */ s(async (t, e) => ({
  ...t,
  disableTelemetry: e.disableTelemetry === !0 || e.test === !0,
  enableCrashReports: e.enableCrashReports || q0(process.env.STORYBOOK_ENABLE_CRASH_REPORTS)
}), "core"), KF = /* @__PURE__ */ s(async (t) => ({
  ...t,
  argTypeTargetsV7: !0,
  legacyDecoratorFileOrder: !1,
  disallowImplicitActionsInRenderV8: !0
}), "features"), $0 = {
  test: /(stories|story)\.(m?js|ts)x?$/,
  createIndex: /* @__PURE__ */ s(async (t, e) => (await k0(t, e)).parse().indexInputs, "createIndex")
}, XF = /* @__PURE__ */ s((t) => [$0].concat(t || []), "experimental_indexers"), zF = /* @__PURE__ */ s(async (t, e) => {
  let r = await e.presets.apply("framework");
  return typeof r == "string" ? {} : typeof r > "u" ? null : r.options;
}, "frameworkOptions"), JF = /* @__PURE__ */ s((t, { docs: e }) => t && e !== void 0 ? {
  ...t,
  docsMode: e
} : t, "docs"), QF = /* @__PURE__ */ s(async (t, e) => {
  let r = Tr(e.configDir, "manager-head.html");
  if (await (0, Zt.pathExists)(r)) {
    let i = (0, Zt.readFile)(r, "utf-8"), n = e.presets.apply("env");
    return D0(await i, await n);
  }
  return "";
}, "managerHead"), ZF = /* @__PURE__ */ s(async (t, e) => {
  let r = await e.presets.apply("core");
  return By(t, e, r), Gd(t, e, r), $d(t, e, r), el(t, e, r), t;
}, "experimental_serverChannel"), eN = /* @__PURE__ */ s(async (t) => {
  try {
    return {
      ...t,
      react: Ki(A.resolve("react/package.json")),
      reactDom: Ki(A.resolve("react-dom/package.json"))
    };
  } catch {
    return t;
  }
}, "resolvedReact"), tN = /* @__PURE__ */ s(async (t) => ({
  ...t,
  "dev-only": { excludeFromDocsStories: !0 },
  "docs-only": { excludeFromSidebar: !0 },
  "test-only": { excludeFromSidebar: !0, excludeFromDocsStories: !0 }
}), "tags"), rN = /* @__PURE__ */ s(async (t, e) => [
  Tr(
    Ki(A.resolve("@storybook/core/package.json")),
    "dist/core-server/presets/common-manager.js"
  ),
  ...t || []
], "managerEntries");
export {
  LF as babel,
  YF as core,
  $0 as csfIndexer,
  JF as docs,
  WF as env,
  XF as experimental_indexers,
  VF as experimental_serverAPI,
  ZF as experimental_serverChannel,
  MF as favicon,
  KF as features,
  zF as frameworkOptions,
  HF as logLevel,
  rN as managerEntries,
  QF as managerHead,
  GF as previewBody,
  BF as previewHead,
  eN as resolvedReact,
  NF as staticDirs,
  tN as tags,
  jF as title,
  UF as typescript
};
