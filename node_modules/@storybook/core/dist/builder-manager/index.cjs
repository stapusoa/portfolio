"use strict";
var ji = Object.create;
var we = Object.defineProperty;
var qi = Object.getOwnPropertyDescriptor;
var Di = Object.getOwnPropertyNames;
var Ti = Object.getPrototypeOf, Li = Object.prototype.hasOwnProperty;
var a = (e, r) => we(e, "name", { value: r, configurable: !0 });
var Ni = (e, r) => () => (e && (r = e(e = 0)), r);
var S = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports), Ft = (e, r) => {
  for (var t in r)
    we(e, t, { get: r[t], enumerable: !0 });
}, kt = (e, r, t, n) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let i of Di(r))
      !Li.call(e, i) && i !== t && we(e, i, { get: () => r[i], enumerable: !(n = qi(r, i)) || n.enumerable });
  return e;
};
var B = (e, r, t) => (t = e != null ? ji(Ti(e)) : {}, kt(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  r || !e || !e.__esModule ? we(t, "default", { value: e, enumerable: !0 }) : t,
  e
)), jt = (e) => kt(we({}, "__esModule", { value: !0 }), e);

// ../node_modules/tslib/tslib.es6.mjs
var er = {};
Ft(er, {
  __addDisposableResource: () => Qt,
  __assign: () => qe,
  __asyncDelegator: () => Ut,
  __asyncGenerator: () => Bt,
  __asyncValues: () => Gt,
  __await: () => le,
  __awaiter: () => It,
  __classPrivateFieldGet: () => Yt,
  __classPrivateFieldIn: () => Xt,
  __classPrivateFieldSet: () => Kt,
  __createBinding: () => Te,
  __decorate: () => Nt,
  __disposeResources: () => Zt,
  __esDecorate: () => Ii,
  __exportStar: () => Mt,
  __extends: () => Tt,
  __generator: () => At,
  __importDefault: () => zt,
  __importStar: () => Vt,
  __makeTemplateObject: () => Ht,
  __metadata: () => Ct,
  __param: () => Rt,
  __propKey: () => Mi,
  __read: () => Ze,
  __rest: () => Lt,
  __runInitializers: () => Ai,
  __setFunctionName: () => $i,
  __spread: () => $t,
  __spreadArray: () => Jt,
  __spreadArrays: () => Wt,
  __values: () => De,
  default: () => Bi
});
function Tt(e, r) {
  if (typeof r != "function" && r !== null)
    throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
  Qe(e, r);
  function t() {
    this.constructor = e;
  }
  a(t, "__"), e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
}
function Lt(e, r) {
  var t = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && r.indexOf(n) < 0 && (t[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
      r.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (t[n[i]] = e[n[i]]);
  return t;
}
function Nt(e, r, t, n) {
  var i = arguments.length, o = i < 3 ? r : n === null ? n = Object.getOwnPropertyDescriptor(r, t) : n, s;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(e, r, t, n);
  else for (var u = e.length - 1; u >= 0; u--) (s = e[u]) && (o = (i < 3 ? s(o) : i > 3 ? s(r, t, o) : s(r, t)) || o);
  return i > 3 && o && Object.defineProperty(r, t, o), o;
}
function Rt(e, r) {
  return function(t, n) {
    r(t, n, e);
  };
}
function Ii(e, r, t, n, i, o) {
  function s(v) {
    if (v !== void 0 && typeof v != "function") throw new TypeError("Function expected");
    return v;
  }
  a(s, "accept");
  for (var u = n.kind, y = u === "getter" ? "get" : u === "setter" ? "set" : "value", f = !r && e ? n.static ? e : e.prototype : null, c = r ||
  (f ? Object.getOwnPropertyDescriptor(f, n.name) : {}), d, l = !1, m = t.length - 1; m >= 0; m--) {
    var p = {};
    for (var h in n) p[h] = h === "access" ? {} : n[h];
    for (var h in n.access) p.access[h] = n.access[h];
    p.addInitializer = function(v) {
      if (l) throw new TypeError("Cannot add initializers after decoration has completed");
      o.push(s(v || null));
    };
    var w = (0, t[m])(u === "accessor" ? { get: c.get, set: c.set } : c[y], p);
    if (u === "accessor") {
      if (w === void 0) continue;
      if (w === null || typeof w != "object") throw new TypeError("Object expected");
      (d = s(w.get)) && (c.get = d), (d = s(w.set)) && (c.set = d), (d = s(w.init)) && i.unshift(d);
    } else (d = s(w)) && (u === "field" ? i.unshift(d) : c[y] = d);
  }
  f && Object.defineProperty(f, n.name, c), l = !0;
}
function Ai(e, r, t) {
  for (var n = arguments.length > 2, i = 0; i < r.length; i++)
    t = n ? r[i].call(e, t) : r[i].call(e);
  return n ? t : void 0;
}
function Mi(e) {
  return typeof e == "symbol" ? e : "".concat(e);
}
function $i(e, r, t) {
  return typeof r == "symbol" && (r = r.description ? "[".concat(r.description, "]") : ""), Object.defineProperty(e, "name", { configurable: !0,
  value: t ? "".concat(t, " ", r) : r });
}
function Ct(e, r) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, r);
}
function It(e, r, t, n) {
  function i(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return a(i, "adopt"), new (t || (t = Promise))(function(o, s) {
    function u(c) {
      try {
        f(n.next(c));
      } catch (d) {
        s(d);
      }
    }
    a(u, "fulfilled");
    function y(c) {
      try {
        f(n.throw(c));
      } catch (d) {
        s(d);
      }
    }
    a(y, "rejected");
    function f(c) {
      c.done ? o(c.value) : i(c.value).then(u, y);
    }
    a(f, "step"), f((n = n.apply(e, r || [])).next());
  });
}
function At(e, r) {
  var t = { label: 0, sent: /* @__PURE__ */ a(function() {
    if (o[0] & 1) throw o[1];
    return o[1];
  }, "sent"), trys: [], ops: [] }, n, i, o, s;
  return s = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function u(f) {
    return function(c) {
      return y([f, c]);
    };
  }
  function y(f) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; s && (s = 0, f[0] && (t = 0)), t; ) try {
      if (n = 1, i && (o = f[0] & 2 ? i.return : f[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, f[1])).done)
       return o;
      switch (i = 0, o && (f = [f[0] & 2, o.value]), f[0]) {
        case 0:
        case 1:
          o = f;
          break;
        case 4:
          return t.label++, { value: f[1], done: !1 };
        case 5:
          t.label++, i = f[1], f = [0];
          continue;
        case 7:
          f = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (o = t.trys, !(o = o.length > 0 && o[o.length - 1]) && (f[0] === 6 || f[0] === 2)) {
            t = 0;
            continue;
          }
          if (f[0] === 3 && (!o || f[1] > o[0] && f[1] < o[3])) {
            t.label = f[1];
            break;
          }
          if (f[0] === 6 && t.label < o[1]) {
            t.label = o[1], o = f;
            break;
          }
          if (o && t.label < o[2]) {
            t.label = o[2], t.ops.push(f);
            break;
          }
          o[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      f = r.call(e, t);
    } catch (c) {
      f = [6, c], i = 0;
    } finally {
      n = o = 0;
    }
    if (f[0] & 5) throw f[1];
    return { value: f[0] ? f[1] : void 0, done: !0 };
  }
}
function Mt(e, r) {
  for (var t in e) t !== "default" && !Object.prototype.hasOwnProperty.call(r, t) && Te(r, e, t);
}
function De(e) {
  var r = typeof Symbol == "function" && Symbol.iterator, t = r && e[r], n = 0;
  if (t) return t.call(e);
  if (e && typeof e.length == "number") return {
    next: /* @__PURE__ */ a(function() {
      return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e };
    }, "next")
  };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Ze(e, r) {
  var t = typeof Symbol == "function" && e[Symbol.iterator];
  if (!t) return e;
  var n = t.call(e), i, o = [], s;
  try {
    for (; (r === void 0 || r-- > 0) && !(i = n.next()).done; ) o.push(i.value);
  } catch (u) {
    s = { error: u };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (s) throw s.error;
    }
  }
  return o;
}
function $t() {
  for (var e = [], r = 0; r < arguments.length; r++)
    e = e.concat(Ze(arguments[r]));
  return e;
}
function Wt() {
  for (var e = 0, r = 0, t = arguments.length; r < t; r++) e += arguments[r].length;
  for (var n = Array(e), i = 0, r = 0; r < t; r++)
    for (var o = arguments[r], s = 0, u = o.length; s < u; s++, i++)
      n[i] = o[s];
  return n;
}
function Jt(e, r, t) {
  if (t || arguments.length === 2) for (var n = 0, i = r.length, o; n < i; n++)
    (o || !(n in r)) && (o || (o = Array.prototype.slice.call(r, 0, n)), o[n] = r[n]);
  return e.concat(o || Array.prototype.slice.call(r));
}
function le(e) {
  return this instanceof le ? (this.v = e, this) : new le(e);
}
function Bt(e, r, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(e, r || []), i, o = [];
  return i = {}, s("next"), s("throw"), s("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function s(l) {
    n[l] && (i[l] = function(m) {
      return new Promise(function(p, h) {
        o.push([l, m, p, h]) > 1 || u(l, m);
      });
    });
  }
  function u(l, m) {
    try {
      y(n[l](m));
    } catch (p) {
      d(o[0][3], p);
    }
  }
  function y(l) {
    l.value instanceof le ? Promise.resolve(l.value.v).then(f, c) : d(o[0][2], l);
  }
  function f(l) {
    u("next", l);
  }
  function c(l) {
    u("throw", l);
  }
  function d(l, m) {
    l(m), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
}
function Ut(e) {
  var r, t;
  return r = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), r[Symbol.iterator] = function() {
    return this;
  }, r;
  function n(i, o) {
    r[i] = e[i] ? function(s) {
      return (t = !t) ? { value: le(e[i](s)), done: !1 } : o ? o(s) : s;
    } : o;
  }
}
function Gt(e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = e[Symbol.asyncIterator], t;
  return r ? r.call(e) : (e = typeof De == "function" ? De(e) : e[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] =
  function() {
    return this;
  }, t);
  function n(o) {
    t[o] = e[o] && function(s) {
      return new Promise(function(u, y) {
        s = e[o](s), i(u, y, s.done, s.value);
      });
    };
  }
  function i(o, s, u, y) {
    Promise.resolve(y).then(function(f) {
      o({ value: f, done: u });
    }, s);
  }
}
function Ht(e, r) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
}
function Vt(e) {
  if (e && e.__esModule) return e;
  var r = {};
  if (e != null) for (var t in e) t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && Te(r, e, t);
  return Wi(r, e), r;
}
function zt(e) {
  return e && e.__esModule ? e : { default: e };
}
function Yt(e, r, t, n) {
  if (t === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
  if (typeof r == "function" ? e !== r || !n : !r.has(e)) throw new TypeError("Cannot read private member from an object whose class did not\
 declare it");
  return t === "m" ? n : t === "a" ? n.call(e) : n ? n.value : r.get(e);
}
function Kt(e, r, t, n, i) {
  if (n === "m") throw new TypeError("Private method is not writable");
  if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter");
  if (typeof r == "function" ? e !== r || !i : !r.has(e)) throw new TypeError("Cannot write private member to an object whose class did not \
declare it");
  return n === "a" ? i.call(e, t) : i ? i.value = t : r.set(e, t), t;
}
function Xt(e, r) {
  if (r === null || typeof r != "object" && typeof r != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof e == "function" ? r === e : e.has(r);
}
function Qt(e, r, t) {
  if (r != null) {
    if (typeof r != "object" && typeof r != "function") throw new TypeError("Object expected.");
    var n;
    if (t) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      n = r[Symbol.asyncDispose];
    }
    if (n === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      n = r[Symbol.dispose];
    }
    if (typeof n != "function") throw new TypeError("Object not disposable.");
    e.stack.push({ value: r, dispose: n, async: t });
  } else t && e.stack.push({ async: !0 });
  return r;
}
function Zt(e) {
  function r(n) {
    e.error = e.hasError ? new Ji(n, e.error, "An error was suppressed during disposal.") : n, e.hasError = !0;
  }
  a(r, "fail");
  function t() {
    for (; e.stack.length; ) {
      var n = e.stack.pop();
      try {
        var i = n.dispose && n.dispose.call(n.value);
        if (n.async) return Promise.resolve(i).then(t, function(o) {
          return r(o), t();
        });
      } catch (o) {
        r(o);
      }
    }
    if (e.hasError) throw e.error;
  }
  return a(t, "next"), t();
}
var Qe, qe, Te, Wi, Ji, Bi, tr = Ni(() => {
  Qe = /* @__PURE__ */ a(function(e, r) {
    return Qe = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
      t.__proto__ = n;
    } || function(t, n) {
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }, Qe(e, r);
  }, "extendStatics");
  a(Tt, "__extends");
  qe = /* @__PURE__ */ a(function() {
    return qe = Object.assign || /* @__PURE__ */ a(function(r) {
      for (var t, n = 1, i = arguments.length; n < i; n++) {
        t = arguments[n];
        for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o]);
      }
      return r;
    }, "__assign"), qe.apply(this, arguments);
  }, "__assign");
  a(Lt, "__rest");
  a(Nt, "__decorate");
  a(Rt, "__param");
  a(Ii, "__esDecorate");
  a(Ai, "__runInitializers");
  a(Mi, "__propKey");
  a($i, "__setFunctionName");
  a(Ct, "__metadata");
  a(It, "__awaiter");
  a(At, "__generator");
  Te = Object.create ? function(e, r, t, n) {
    n === void 0 && (n = t);
    var i = Object.getOwnPropertyDescriptor(r, t);
    (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: /* @__PURE__ */ a(function() {
      return r[t];
    }, "get") }), Object.defineProperty(e, n, i);
  } : function(e, r, t, n) {
    n === void 0 && (n = t), e[n] = r[t];
  };
  a(Mt, "__exportStar");
  a(De, "__values");
  a(Ze, "__read");
  a($t, "__spread");
  a(Wt, "__spreadArrays");
  a(Jt, "__spreadArray");
  a(le, "__await");
  a(Bt, "__asyncGenerator");
  a(Ut, "__asyncDelegator");
  a(Gt, "__asyncValues");
  a(Ht, "__makeTemplateObject");
  Wi = Object.create ? function(e, r) {
    Object.defineProperty(e, "default", { enumerable: !0, value: r });
  } : function(e, r) {
    e.default = r;
  };
  a(Vt, "__importStar");
  a(zt, "__importDefault");
  a(Yt, "__classPrivateFieldGet");
  a(Kt, "__classPrivateFieldSet");
  a(Xt, "__classPrivateFieldIn");
  a(Qt, "__addDisposableResource");
  Ji = typeof SuppressedError == "function" ? SuppressedError : function(e, r, t) {
    var n = new Error(t);
    return n.name = "SuppressedError", n.error = e, n.suppressed = r, n;
  };
  a(Zt, "__disposeResources");
  Bi = {
    __extends: Tt,
    __assign: qe,
    __rest: Lt,
    __decorate: Nt,
    __param: Rt,
    __metadata: Ct,
    __awaiter: It,
    __generator: At,
    __createBinding: Te,
    __exportStar: Mt,
    __values: De,
    __read: Ze,
    __spread: $t,
    __spreadArrays: Wt,
    __spreadArray: Jt,
    __await: le,
    __asyncGenerator: Bt,
    __asyncDelegator: Ut,
    __asyncValues: Gt,
    __makeTemplateObject: Ht,
    __importStar: Vt,
    __importDefault: zt,
    __classPrivateFieldGet: Yt,
    __classPrivateFieldSet: Kt,
    __classPrivateFieldIn: Xt,
    __addDisposableResource: Qt,
    __disposeResources: Zt
  };
});

// ../node_modules/@yarnpkg/esbuild-plugin-pnp/lib/index.js
var nr = S((Le) => {
  "use strict";
  Object.defineProperty(Le, "__esModule", { value: !0 });
  Le.pnpPlugin = void 0;
  var rr = (tr(), jt(er)), Ui = rr.__importStar(require("fs")), Gi = rr.__importDefault(require("path")), Hi = /()/, Vi = [".tsx", ".ts", ".\
jsx", ".mjs", ".cjs", ".js", ".css", ".json"];
  function zi(e) {
    return e.map((r) => {
      let t = r.indexOf("*");
      return t !== -1 ? { prefix: r.slice(0, t), suffix: r.slice(t + 1) } : r;
    });
  }
  a(zi, "parseExternals");
  function Yi(e, r) {
    for (let t of r)
      if (typeof t == "object") {
        if (e.length >= t.prefix.length + t.suffix.length && e.startsWith(t.prefix) && e.endsWith(t.suffix))
          return !0;
      } else if (e === t || !t.startsWith("/") && !t.startsWith("./") && !t.startsWith("../") && t !== "." && t !== ".." && e.startsWith(`${t}\
/`))
        return !0;
    return !1;
  }
  a(Yi, "isExternal");
  async function Ki(e) {
    return {
      contents: await Ui.promises.readFile(e.path),
      loader: "default",
      // For regular imports in the `file` namespace, resolveDir is the directory the
      // file being resolved lives in. For all other virtual modules, this defaults to
      // empty string: ""
      // A sensible value for pnp imports is the same as the `file` namespace, as pnp
      // still resolves to files on disk (in the cache).
      resolveDir: Gi.default.dirname(e.path)
    };
  }
  a(Ki, "defaultOnLoad");
  async function Xi(e, { resolvedPath: r, error: t, watchFiles: n }) {
    let i = t ? [{ text: t.message }] : [], o;
    switch (e.kind) {
      case "require-call":
      case "require-resolve":
      case "dynamic-import":
        o = { warnings: i };
        break;
      default:
        o = { errors: i };
        break;
    }
    return r !== null ? { namespace: "pnp", path: r, watchFiles: n } : { external: !0, ...o, watchFiles: n };
  }
  a(Xi, "defaultOnResolve");
  function Qi({ baseDir: e = process.cwd(), extensions: r = Vi, filter: t = Hi, onResolve: n = Xi, onLoad: i = Ki } = {}) {
    return {
      name: "@yarnpkg/esbuild-plugin-pnp",
      setup(o) {
        var s, u;
        let { findPnpApi: y } = require("module");
        if (typeof y > "u")
          return;
        let f = zi((s = o.initialOptions.external) !== null && s !== void 0 ? s : []), c = (u = o.initialOptions.platform) !== null && u !==
        void 0 ? u : "browser", d = c === "node", l = new Set(o.initialOptions.conditions);
        l.add("default"), (c === "browser" || c === "node") && l.add(c);
        let m = new Set(l);
        m.add("import");
        let p = new Set(l);
        p.add("require"), o.onResolve({ filter: t }, (h) => {
          var w, v;
          if (Yi(h.path, f))
            return { external: !0 };
          let O = l;
          h.kind === "dynamic-import" || h.kind === "import-statement" ? O = m : (h.kind === "require-call" || h.kind === "require-resolve") &&
          (O = p);
          let x = h.resolveDir ? `${h.resolveDir}/` : h.importer ? h.importer : `${e}/`, T = y(x);
          if (!T)
            return;
          let W = null, K;
          try {
            W = T.resolveRequest(h.path, x, {
              conditions: O,
              considerBuiltins: d,
              extensions: r
            });
          } catch (ne) {
            K = ne;
          }
          let Z = [T.resolveRequest("pnpapi", null)];
          if (W) {
            let ne = T.findPackageLocator(W);
            if (ne) {
              let g = T.getPackageInformation(ne);
              g?.linkType === "SOFT" && Z.push((v = (w = T.resolveVirtual) === null || w === void 0 ? void 0 : w.call(T, W)) !== null && v !==
              void 0 ? v : W);
            }
          }
          return n(h, { resolvedPath: W, error: K, watchFiles: Z });
        }), o.onLoad !== null && o.onLoad({ filter: t }, i);
      }
    };
  }
  a(Qi, "pnpPlugin");
  Le.pnpPlugin = Qi;
});

// ../node_modules/esbuild-plugin-alias/index.js
var or = S((Ys, ir) => {
  ir.exports = (e) => {
    let r = Object.keys(e), t = new RegExp(`^(${r.map((n) => Zi(n)).join("|")})$`);
    return {
      name: "alias",
      setup(n) {
        n.onResolve({ filter: t }, (i) => ({
          path: e[i.path]
        }));
      }
    };
  };
  function Zi(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  a(Zi, "escapeRegExp");
});

// ../node_modules/universalify/index.js
var R = S((et) => {
  "use strict";
  et.fromCallback = function(e) {
    return Object.defineProperty(function(...r) {
      if (typeof r[r.length - 1] == "function") e.apply(this, r);
      else
        return new Promise((t, n) => {
          e.call(
            this,
            ...r,
            (i, o) => i != null ? n(i) : t(o)
          );
        });
    }, "name", { value: e.name });
  };
  et.fromPromise = function(e) {
    return Object.defineProperty(function(...r) {
      let t = r[r.length - 1];
      if (typeof t != "function") return e.apply(this, r);
      e.apply(this, r.slice(0, -1)).then((n) => t(null, n), t);
    }, "name", { value: e.name });
  };
});

// ../node_modules/graceful-fs/polyfills.js
var sr = S((Qs, ar) => {
  var ie = require("constants"), eo = process.cwd, Ne = null, to = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return Ne || (Ne = eo.call(process)), Ne;
  };
  try {
    process.cwd();
  } catch {
  }
  typeof process.chdir == "function" && (tt = process.chdir, process.chdir = function(e) {
    Ne = null, tt.call(process, e);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, tt));
  var tt;
  ar.exports = ro;
  function ro(e) {
    ie.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && r(e), e.lutimes || t(e), e.chown = o(e.chown), e.fchown =
    o(e.fchown), e.lchown = o(e.lchown), e.chmod = n(e.chmod), e.fchmod = n(e.fchmod), e.lchmod = n(e.lchmod), e.chownSync = s(e.chownSync),
    e.fchownSync = s(e.fchownSync), e.lchownSync = s(e.lchownSync), e.chmodSync = i(e.chmodSync), e.fchmodSync = i(e.fchmodSync), e.lchmodSync =
    i(e.lchmodSync), e.stat = u(e.stat), e.fstat = u(e.fstat), e.lstat = u(e.lstat), e.statSync = y(e.statSync), e.fstatSync = y(e.fstatSync),
    e.lstatSync = y(e.lstatSync), e.chmod && !e.lchmod && (e.lchmod = function(c, d, l) {
      l && process.nextTick(l);
    }, e.lchmodSync = function() {
    }), e.chown && !e.lchown && (e.lchown = function(c, d, l, m) {
      m && process.nextTick(m);
    }, e.lchownSync = function() {
    }), to === "win32" && (e.rename = typeof e.rename != "function" ? e.rename : function(c) {
      function d(l, m, p) {
        var h = Date.now(), w = 0;
        c(l, m, /* @__PURE__ */ a(function v(O) {
          if (O && (O.code === "EACCES" || O.code === "EPERM" || O.code === "EBUSY") && Date.now() - h < 6e4) {
            setTimeout(function() {
              e.stat(m, function(x, T) {
                x && x.code === "ENOENT" ? c(l, m, v) : p(O);
              });
            }, w), w < 100 && (w += 10);
            return;
          }
          p && p(O);
        }, "CB"));
      }
      return a(d, "rename"), Object.setPrototypeOf && Object.setPrototypeOf(d, c), d;
    }(e.rename)), e.read = typeof e.read != "function" ? e.read : function(c) {
      function d(l, m, p, h, w, v) {
        var O;
        if (v && typeof v == "function") {
          var x = 0;
          O = /* @__PURE__ */ a(function(T, W, K) {
            if (T && T.code === "EAGAIN" && x < 10)
              return x++, c.call(e, l, m, p, h, w, O);
            v.apply(this, arguments);
          }, "callback");
        }
        return c.call(e, l, m, p, h, w, O);
      }
      return a(d, "read"), Object.setPrototypeOf && Object.setPrototypeOf(d, c), d;
    }(e.read), e.readSync = typeof e.readSync != "function" ? e.readSync : /* @__PURE__ */ function(c) {
      return function(d, l, m, p, h) {
        for (var w = 0; ; )
          try {
            return c.call(e, d, l, m, p, h);
          } catch (v) {
            if (v.code === "EAGAIN" && w < 10) {
              w++;
              continue;
            }
            throw v;
          }
      };
    }(e.readSync);
    function r(c) {
      c.lchmod = function(d, l, m) {
        c.open(
          d,
          ie.O_WRONLY | ie.O_SYMLINK,
          l,
          function(p, h) {
            if (p) {
              m && m(p);
              return;
            }
            c.fchmod(h, l, function(w) {
              c.close(h, function(v) {
                m && m(w || v);
              });
            });
          }
        );
      }, c.lchmodSync = function(d, l) {
        var m = c.openSync(d, ie.O_WRONLY | ie.O_SYMLINK, l), p = !0, h;
        try {
          h = c.fchmodSync(m, l), p = !1;
        } finally {
          if (p)
            try {
              c.closeSync(m);
            } catch {
            }
          else
            c.closeSync(m);
        }
        return h;
      };
    }
    a(r, "patchLchmod");
    function t(c) {
      ie.hasOwnProperty("O_SYMLINK") && c.futimes ? (c.lutimes = function(d, l, m, p) {
        c.open(d, ie.O_SYMLINK, function(h, w) {
          if (h) {
            p && p(h);
            return;
          }
          c.futimes(w, l, m, function(v) {
            c.close(w, function(O) {
              p && p(v || O);
            });
          });
        });
      }, c.lutimesSync = function(d, l, m) {
        var p = c.openSync(d, ie.O_SYMLINK), h, w = !0;
        try {
          h = c.futimesSync(p, l, m), w = !1;
        } finally {
          if (w)
            try {
              c.closeSync(p);
            } catch {
            }
          else
            c.closeSync(p);
        }
        return h;
      }) : c.futimes && (c.lutimes = function(d, l, m, p) {
        p && process.nextTick(p);
      }, c.lutimesSync = function() {
      });
    }
    a(t, "patchLutimes");
    function n(c) {
      return c && function(d, l, m) {
        return c.call(e, d, l, function(p) {
          f(p) && (p = null), m && m.apply(this, arguments);
        });
      };
    }
    a(n, "chmodFix");
    function i(c) {
      return c && function(d, l) {
        try {
          return c.call(e, d, l);
        } catch (m) {
          if (!f(m)) throw m;
        }
      };
    }
    a(i, "chmodFixSync");
    function o(c) {
      return c && function(d, l, m, p) {
        return c.call(e, d, l, m, function(h) {
          f(h) && (h = null), p && p.apply(this, arguments);
        });
      };
    }
    a(o, "chownFix");
    function s(c) {
      return c && function(d, l, m) {
        try {
          return c.call(e, d, l, m);
        } catch (p) {
          if (!f(p)) throw p;
        }
      };
    }
    a(s, "chownFixSync");
    function u(c) {
      return c && function(d, l, m) {
        typeof l == "function" && (m = l, l = null);
        function p(h, w) {
          w && (w.uid < 0 && (w.uid += 4294967296), w.gid < 0 && (w.gid += 4294967296)), m && m.apply(this, arguments);
        }
        return a(p, "callback"), l ? c.call(e, d, l, p) : c.call(e, d, p);
      };
    }
    a(u, "statFix");
    function y(c) {
      return c && function(d, l) {
        var m = l ? c.call(e, d, l) : c.call(e, d);
        return m && (m.uid < 0 && (m.uid += 4294967296), m.gid < 0 && (m.gid += 4294967296)), m;
      };
    }
    a(y, "statFixSync");
    function f(c) {
      if (!c || c.code === "ENOSYS")
        return !0;
      var d = !process.getuid || process.getuid() !== 0;
      return !!(d && (c.code === "EINVAL" || c.code === "EPERM"));
    }
    a(f, "chownErOk");
  }
  a(ro, "patch");
});

// ../node_modules/graceful-fs/legacy-streams.js
var lr = S((ec, ur) => {
  var cr = require("stream").Stream;
  ur.exports = no;
  function no(e) {
    return {
      ReadStream: r,
      WriteStream: t
    };
    function r(n, i) {
      if (!(this instanceof r)) return new r(n, i);
      cr.call(this);
      var o = this;
      this.path = n, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, i =
      i || {};
      for (var s = Object.keys(i), u = 0, y = s.length; u < y; u++) {
        var f = s[u];
        this[f] = i[f];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          o._read();
        });
        return;
      }
      e.open(this.path, this.flags, this.mode, function(c, d) {
        if (c) {
          o.emit("error", c), o.readable = !1;
          return;
        }
        o.fd = d, o.emit("open", d), o._read();
      });
    }
    function t(n, i) {
      if (!(this instanceof t)) return new t(n, i);
      cr.call(this), this.path = n, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten =
      0, i = i || {};
      for (var o = Object.keys(i), s = 0, u = o.length; s < u; s++) {
        var y = o[s];
        this[y] = i[y];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.
      mode, void 0]), this.flush());
    }
  }
  a(no, "legacy");
});

// ../node_modules/graceful-fs/clone.js
var pr = S((rc, fr) => {
  "use strict";
  fr.exports = oo;
  var io = Object.getPrototypeOf || function(e) {
    return e.__proto__;
  };
  function oo(e) {
    if (e === null || typeof e != "object")
      return e;
    if (e instanceof Object)
      var r = { __proto__: io(e) };
    else
      var r = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(e).forEach(function(t) {
      Object.defineProperty(r, t, Object.getOwnPropertyDescriptor(e, t));
    }), r;
  }
  a(oo, "clone");
});

// ../node_modules/graceful-fs/graceful-fs.js
var pe = S((ic, it) => {
  var j = require("fs"), ao = sr(), so = lr(), co = pr(), Re = require("util"), $, Ie;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? ($ = Symbol.for("graceful-fs.queue"), Ie = Symbol.for("graceful-fs.previo\
us")) : ($ = "___graceful-fs.queue", Ie = "___graceful-fs.previous");
  function uo() {
  }
  a(uo, "noop");
  function yr(e, r) {
    Object.defineProperty(e, $, {
      get: /* @__PURE__ */ a(function() {
        return r;
      }, "get")
    });
  }
  a(yr, "publishQueue");
  var ce = uo;
  Re.debuglog ? ce = Re.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (ce = /* @__PURE__ */ a(function() {
    var e = Re.format.apply(Re, arguments);
    e = "GFS4: " + e.split(/\n/).join(`
GFS4: `), console.error(e);
  }, "debug"));
  j[$] || (mr = global[$] || [], yr(j, mr), j.close = function(e) {
    function r(t, n) {
      return e.call(j, t, function(i) {
        i || dr(), typeof n == "function" && n.apply(this, arguments);
      });
    }
    return a(r, "close"), Object.defineProperty(r, Ie, {
      value: e
    }), r;
  }(j.close), j.closeSync = function(e) {
    function r(t) {
      e.apply(j, arguments), dr();
    }
    return a(r, "closeSync"), Object.defineProperty(r, Ie, {
      value: e
    }), r;
  }(j.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    ce(j[$]), require("assert").equal(j[$].length, 0);
  }));
  var mr;
  global[$] || yr(global, j[$]);
  it.exports = rt(co(j));
  process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !j.__patched && (it.exports = rt(j), j.__patched = !0);
  function rt(e) {
    ao(e), e.gracefulify = rt, e.createReadStream = W, e.createWriteStream = K;
    var r = e.readFile;
    e.readFile = t;
    function t(g, _, b) {
      return typeof _ == "function" && (b = _, _ = null), I(g, _, b);
      function I(A, N, k, q) {
        return r(A, N, function(P) {
          P && (P.code === "EMFILE" || P.code === "ENFILE") ? fe([I, [A, N, k], P, q || Date.now(), Date.now()]) : typeof k == "function" &&
          k.apply(this, arguments);
        });
      }
      a(I, "go$readFile");
    }
    a(t, "readFile");
    var n = e.writeFile;
    e.writeFile = i;
    function i(g, _, b, I) {
      return typeof b == "function" && (I = b, b = null), A(g, _, b, I);
      function A(N, k, q, P, M) {
        return n(N, k, q, function(F) {
          F && (F.code === "EMFILE" || F.code === "ENFILE") ? fe([A, [N, k, q, P], F, M || Date.now(), Date.now()]) : typeof P == "function" &&
          P.apply(this, arguments);
        });
      }
      a(A, "go$writeFile");
    }
    a(i, "writeFile");
    var o = e.appendFile;
    o && (e.appendFile = s);
    function s(g, _, b, I) {
      return typeof b == "function" && (I = b, b = null), A(g, _, b, I);
      function A(N, k, q, P, M) {
        return o(N, k, q, function(F) {
          F && (F.code === "EMFILE" || F.code === "ENFILE") ? fe([A, [N, k, q, P], F, M || Date.now(), Date.now()]) : typeof P == "function" &&
          P.apply(this, arguments);
        });
      }
      a(A, "go$appendFile");
    }
    a(s, "appendFile");
    var u = e.copyFile;
    u && (e.copyFile = y);
    function y(g, _, b, I) {
      return typeof b == "function" && (I = b, b = 0), A(g, _, b, I);
      function A(N, k, q, P, M) {
        return u(N, k, q, function(F) {
          F && (F.code === "EMFILE" || F.code === "ENFILE") ? fe([A, [N, k, q, P], F, M || Date.now(), Date.now()]) : typeof P == "function" &&
          P.apply(this, arguments);
        });
      }
      a(A, "go$copyFile");
    }
    a(y, "copyFile");
    var f = e.readdir;
    e.readdir = d;
    var c = /^v[0-5]\./;
    function d(g, _, b) {
      typeof _ == "function" && (b = _, _ = null);
      var I = c.test(process.version) ? /* @__PURE__ */ a(function(k, q, P, M) {
        return f(k, A(
          k,
          q,
          P,
          M
        ));
      }, "go$readdir") : /* @__PURE__ */ a(function(k, q, P, M) {
        return f(k, q, A(
          k,
          q,
          P,
          M
        ));
      }, "go$readdir");
      return I(g, _, b);
      function A(N, k, q, P) {
        return function(M, F) {
          M && (M.code === "EMFILE" || M.code === "ENFILE") ? fe([
            I,
            [N, k, q],
            M,
            P || Date.now(),
            Date.now()
          ]) : (F && F.sort && F.sort(), typeof q == "function" && q.call(this, M, F));
        };
      }
    }
    if (a(d, "readdir"), process.version.substr(0, 4) === "v0.8") {
      var l = so(e);
      v = l.ReadStream, x = l.WriteStream;
    }
    var m = e.ReadStream;
    m && (v.prototype = Object.create(m.prototype), v.prototype.open = O);
    var p = e.WriteStream;
    p && (x.prototype = Object.create(p.prototype), x.prototype.open = T), Object.defineProperty(e, "ReadStream", {
      get: /* @__PURE__ */ a(function() {
        return v;
      }, "get"),
      set: /* @__PURE__ */ a(function(g) {
        v = g;
      }, "set"),
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e, "WriteStream", {
      get: /* @__PURE__ */ a(function() {
        return x;
      }, "get"),
      set: /* @__PURE__ */ a(function(g) {
        x = g;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var h = v;
    Object.defineProperty(e, "FileReadStream", {
      get: /* @__PURE__ */ a(function() {
        return h;
      }, "get"),
      set: /* @__PURE__ */ a(function(g) {
        h = g;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var w = x;
    Object.defineProperty(e, "FileWriteStream", {
      get: /* @__PURE__ */ a(function() {
        return w;
      }, "get"),
      set: /* @__PURE__ */ a(function(g) {
        w = g;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    function v(g, _) {
      return this instanceof v ? (m.apply(this, arguments), this) : v.apply(Object.create(v.prototype), arguments);
    }
    a(v, "ReadStream");
    function O() {
      var g = this;
      ne(g.path, g.flags, g.mode, function(_, b) {
        _ ? (g.autoClose && g.destroy(), g.emit("error", _)) : (g.fd = b, g.emit("open", b), g.read());
      });
    }
    a(O, "ReadStream$open");
    function x(g, _) {
      return this instanceof x ? (p.apply(this, arguments), this) : x.apply(Object.create(x.prototype), arguments);
    }
    a(x, "WriteStream");
    function T() {
      var g = this;
      ne(g.path, g.flags, g.mode, function(_, b) {
        _ ? (g.destroy(), g.emit("error", _)) : (g.fd = b, g.emit("open", b));
      });
    }
    a(T, "WriteStream$open");
    function W(g, _) {
      return new e.ReadStream(g, _);
    }
    a(W, "createReadStream");
    function K(g, _) {
      return new e.WriteStream(g, _);
    }
    a(K, "createWriteStream");
    var Z = e.open;
    e.open = ne;
    function ne(g, _, b, I) {
      return typeof b == "function" && (I = b, b = null), A(g, _, b, I);
      function A(N, k, q, P, M) {
        return Z(N, k, q, function(F, qs) {
          F && (F.code === "EMFILE" || F.code === "ENFILE") ? fe([A, [N, k, q, P], F, M || Date.now(), Date.now()]) : typeof P == "function" &&
          P.apply(this, arguments);
        });
      }
      a(A, "go$open");
    }
    return a(ne, "open"), e;
  }
  a(rt, "patch");
  function fe(e) {
    ce("ENQUEUE", e[0].name, e[1]), j[$].push(e), nt();
  }
  a(fe, "enqueue");
  var Ce;
  function dr() {
    for (var e = Date.now(), r = 0; r < j[$].length; ++r)
      j[$][r].length > 2 && (j[$][r][3] = e, j[$][r][4] = e);
    nt();
  }
  a(dr, "resetQueue");
  function nt() {
    if (clearTimeout(Ce), Ce = void 0, j[$].length !== 0) {
      var e = j[$].shift(), r = e[0], t = e[1], n = e[2], i = e[3], o = e[4];
      if (i === void 0)
        ce("RETRY", r.name, t), r.apply(null, t);
      else if (Date.now() - i >= 6e4) {
        ce("TIMEOUT", r.name, t);
        var s = t.pop();
        typeof s == "function" && s.call(null, n);
      } else {
        var u = Date.now() - o, y = Math.max(o - i, 1), f = Math.min(y * 1.2, 100);
        u >= f ? (ce("RETRY", r.name, t), r.apply(null, t.concat([i]))) : j[$].push(e);
      }
      Ce === void 0 && (Ce = setTimeout(nt, 0));
    }
  }
  a(nt, "retry");
});

// ../node_modules/fs-extra/lib/fs/index.js
var G = S((ee) => {
  "use strict";
  var hr = R().fromCallback, U = pe(), lo = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((e) => typeof U[e] == "function");
  Object.assign(ee, U);
  lo.forEach((e) => {
    ee[e] = hr(U[e]);
  });
  ee.exists = function(e, r) {
    return typeof r == "function" ? U.exists(e, r) : new Promise((t) => U.exists(e, t));
  };
  ee.read = function(e, r, t, n, i, o) {
    return typeof o == "function" ? U.read(e, r, t, n, i, o) : new Promise((s, u) => {
      U.read(e, r, t, n, i, (y, f, c) => {
        if (y) return u(y);
        s({ bytesRead: f, buffer: c });
      });
    });
  };
  ee.write = function(e, r, ...t) {
    return typeof t[t.length - 1] == "function" ? U.write(e, r, ...t) : new Promise((n, i) => {
      U.write(e, r, ...t, (o, s, u) => {
        if (o) return i(o);
        n({ bytesWritten: s, buffer: u });
      });
    });
  };
  ee.readv = function(e, r, ...t) {
    return typeof t[t.length - 1] == "function" ? U.readv(e, r, ...t) : new Promise((n, i) => {
      U.readv(e, r, ...t, (o, s, u) => {
        if (o) return i(o);
        n({ bytesRead: s, buffers: u });
      });
    });
  };
  ee.writev = function(e, r, ...t) {
    return typeof t[t.length - 1] == "function" ? U.writev(e, r, ...t) : new Promise((n, i) => {
      U.writev(e, r, ...t, (o, s, u) => {
        if (o) return i(o);
        n({ bytesWritten: s, buffers: u });
      });
    });
  };
  typeof U.realpath.native == "function" ? ee.realpath.native = hr(U.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
});

// ../node_modules/fs-extra/lib/mkdirs/utils.js
var gr = S((sc, wr) => {
  "use strict";
  var fo = require("path");
  wr.exports.checkPath = /* @__PURE__ */ a(function(r) {
    if (process.platform === "win32" && /[<>:"|?*]/.test(r.replace(fo.parse(r).root, ""))) {
      let n = new Error(`Path contains invalid characters: ${r}`);
      throw n.code = "EINVAL", n;
    }
  }, "checkPath");
});

// ../node_modules/fs-extra/lib/mkdirs/make-dir.js
var Er = S((uc, ot) => {
  "use strict";
  var vr = G(), { checkPath: Sr } = gr(), br = /* @__PURE__ */ a((e) => {
    let r = { mode: 511 };
    return typeof e == "number" ? e : { ...r, ...e }.mode;
  }, "getMode");
  ot.exports.makeDir = async (e, r) => (Sr(e), vr.mkdir(e, {
    mode: br(r),
    recursive: !0
  }));
  ot.exports.makeDirSync = (e, r) => (Sr(e), vr.mkdirSync(e, {
    mode: br(r),
    recursive: !0
  }));
});

// ../node_modules/fs-extra/lib/mkdirs/index.js
var X = S((fc, _r) => {
  "use strict";
  var po = R().fromPromise, { makeDir: mo, makeDirSync: at } = Er(), st = po(mo);
  _r.exports = {
    mkdirs: st,
    mkdirsSync: at,
    // alias
    mkdirp: st,
    mkdirpSync: at,
    ensureDir: st,
    ensureDirSync: at
  };
});

// ../node_modules/fs-extra/lib/path-exists/index.js
var oe = S((pc, Or) => {
  "use strict";
  var yo = R().fromPromise, xr = G();
  function ho(e) {
    return xr.access(e).then(() => !0).catch(() => !1);
  }
  a(ho, "pathExists");
  Or.exports = {
    pathExists: yo(ho),
    pathExistsSync: xr.existsSync
  };
});

// ../node_modules/fs-extra/lib/util/utimes.js
var ct = S((dc, Pr) => {
  "use strict";
  var me = G(), wo = R().fromPromise;
  async function go(e, r, t) {
    let n = await me.open(e, "r+"), i = null;
    try {
      await me.futimes(n, r, t);
    } finally {
      try {
        await me.close(n);
      } catch (o) {
        i = o;
      }
    }
    if (i)
      throw i;
  }
  a(go, "utimesMillis");
  function vo(e, r, t) {
    let n = me.openSync(e, "r+");
    return me.futimesSync(n, r, t), me.closeSync(n);
  }
  a(vo, "utimesMillisSync");
  Pr.exports = {
    utimesMillis: wo(go),
    utimesMillisSync: vo
  };
});

// ../node_modules/fs-extra/lib/util/stat.js
var ue = S((hc, qr) => {
  "use strict";
  var de = G(), C = require("path"), Fr = R().fromPromise;
  function So(e, r, t) {
    let n = t.dereference ? (i) => de.stat(i, { bigint: !0 }) : (i) => de.lstat(i, { bigint: !0 });
    return Promise.all([
      n(e),
      n(r).catch((i) => {
        if (i.code === "ENOENT") return null;
        throw i;
      })
    ]).then(([i, o]) => ({ srcStat: i, destStat: o }));
  }
  a(So, "getStats");
  function bo(e, r, t) {
    let n, i = t.dereference ? (s) => de.statSync(s, { bigint: !0 }) : (s) => de.lstatSync(s, { bigint: !0 }), o = i(e);
    try {
      n = i(r);
    } catch (s) {
      if (s.code === "ENOENT") return { srcStat: o, destStat: null };
      throw s;
    }
    return { srcStat: o, destStat: n };
  }
  a(bo, "getStatsSync");
  async function Eo(e, r, t, n) {
    let { srcStat: i, destStat: o } = await So(e, r, n);
    if (o) {
      if (ge(i, o)) {
        let s = C.basename(e), u = C.basename(r);
        if (t === "move" && s !== u && s.toLowerCase() === u.toLowerCase())
          return { srcStat: i, destStat: o, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (i.isDirectory() && !o.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${r}' with directory '${e}'.`);
      if (!i.isDirectory() && o.isDirectory())
        throw new Error(`Cannot overwrite directory '${r}' with non-directory '${e}'.`);
    }
    if (i.isDirectory() && ut(e, r))
      throw new Error(Ae(e, r, t));
    return { srcStat: i, destStat: o };
  }
  a(Eo, "checkPaths");
  function _o(e, r, t, n) {
    let { srcStat: i, destStat: o } = bo(e, r, n);
    if (o) {
      if (ge(i, o)) {
        let s = C.basename(e), u = C.basename(r);
        if (t === "move" && s !== u && s.toLowerCase() === u.toLowerCase())
          return { srcStat: i, destStat: o, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (i.isDirectory() && !o.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${r}' with directory '${e}'.`);
      if (!i.isDirectory() && o.isDirectory())
        throw new Error(`Cannot overwrite directory '${r}' with non-directory '${e}'.`);
    }
    if (i.isDirectory() && ut(e, r))
      throw new Error(Ae(e, r, t));
    return { srcStat: i, destStat: o };
  }
  a(_o, "checkPathsSync");
  async function kr(e, r, t, n) {
    let i = C.resolve(C.dirname(e)), o = C.resolve(C.dirname(t));
    if (o === i || o === C.parse(o).root) return;
    let s;
    try {
      s = await de.stat(o, { bigint: !0 });
    } catch (u) {
      if (u.code === "ENOENT") return;
      throw u;
    }
    if (ge(r, s))
      throw new Error(Ae(e, t, n));
    return kr(e, r, o, n);
  }
  a(kr, "checkParentPaths");
  function jr(e, r, t, n) {
    let i = C.resolve(C.dirname(e)), o = C.resolve(C.dirname(t));
    if (o === i || o === C.parse(o).root) return;
    let s;
    try {
      s = de.statSync(o, { bigint: !0 });
    } catch (u) {
      if (u.code === "ENOENT") return;
      throw u;
    }
    if (ge(r, s))
      throw new Error(Ae(e, t, n));
    return jr(e, r, o, n);
  }
  a(jr, "checkParentPathsSync");
  function ge(e, r) {
    return r.ino && r.dev && r.ino === e.ino && r.dev === e.dev;
  }
  a(ge, "areIdentical");
  function ut(e, r) {
    let t = C.resolve(e).split(C.sep).filter((i) => i), n = C.resolve(r).split(C.sep).filter((i) => i);
    return t.every((i, o) => n[o] === i);
  }
  a(ut, "isSrcSubdir");
  function Ae(e, r, t) {
    return `Cannot ${t} '${e}' to a subdirectory of itself, '${r}'.`;
  }
  a(Ae, "errMsg");
  qr.exports = {
    // checkPaths
    checkPaths: Fr(Eo),
    checkPathsSync: _o,
    // checkParent
    checkParentPaths: Fr(kr),
    checkParentPathsSync: jr,
    // Misc
    isSrcSubdir: ut,
    areIdentical: ge
  };
});

// ../node_modules/fs-extra/lib/copy/copy.js
var Rr = S((gc, Nr) => {
  "use strict";
  var J = G(), ve = require("path"), { mkdirs: xo } = X(), { pathExists: Oo } = oe(), { utimesMillis: Po } = ct(), Se = ue();
  async function Fo(e, r, t = {}) {
    typeof t == "function" && (t = { filter: t }), t.clobber = "clobber" in t ? !!t.clobber : !0, t.overwrite = "overwrite" in t ? !!t.overwrite :
    t.clobber, t.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0001"
    );
    let { srcStat: n, destStat: i } = await Se.checkPaths(e, r, "copy", t);
    if (await Se.checkParentPaths(e, n, r, "copy"), !await Tr(e, r, t)) return;
    let s = ve.dirname(r);
    await Oo(s) || await xo(s), await Lr(i, e, r, t);
  }
  a(Fo, "copy");
  async function Tr(e, r, t) {
    return t.filter ? t.filter(e, r) : !0;
  }
  a(Tr, "runFilter");
  async function Lr(e, r, t, n) {
    let o = await (n.dereference ? J.stat : J.lstat)(r);
    if (o.isDirectory()) return Do(o, e, r, t, n);
    if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice()) return ko(o, e, r, t, n);
    if (o.isSymbolicLink()) return To(e, r, t, n);
    throw o.isSocket() ? new Error(`Cannot copy a socket file: ${r}`) : o.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${r}`) : new Error(
    `Unknown file: ${r}`);
  }
  a(Lr, "getStatsAndPerformCopy");
  async function ko(e, r, t, n, i) {
    if (!r) return Dr(e, t, n, i);
    if (i.overwrite)
      return await J.unlink(n), Dr(e, t, n, i);
    if (i.errorOnExist)
      throw new Error(`'${n}' already exists`);
  }
  a(ko, "onFile");
  async function Dr(e, r, t, n) {
    if (await J.copyFile(r, t), n.preserveTimestamps) {
      jo(e.mode) && await qo(t, e.mode);
      let i = await J.stat(r);
      await Po(t, i.atime, i.mtime);
    }
    return J.chmod(t, e.mode);
  }
  a(Dr, "copyFile");
  function jo(e) {
    return (e & 128) === 0;
  }
  a(jo, "fileIsNotWritable");
  function qo(e, r) {
    return J.chmod(e, r | 128);
  }
  a(qo, "makeFileWritable");
  async function Do(e, r, t, n, i) {
    r || await J.mkdir(n);
    let o = await J.readdir(t);
    await Promise.all(o.map(async (s) => {
      let u = ve.join(t, s), y = ve.join(n, s);
      if (!await Tr(u, y, i)) return;
      let { destStat: c } = await Se.checkPaths(u, y, "copy", i);
      return Lr(c, u, y, i);
    })), r || await J.chmod(n, e.mode);
  }
  a(Do, "onDir");
  async function To(e, r, t, n) {
    let i = await J.readlink(r);
    if (n.dereference && (i = ve.resolve(process.cwd(), i)), !e)
      return J.symlink(i, t);
    let o = null;
    try {
      o = await J.readlink(t);
    } catch (s) {
      if (s.code === "EINVAL" || s.code === "UNKNOWN") return J.symlink(i, t);
      throw s;
    }
    if (n.dereference && (o = ve.resolve(process.cwd(), o)), Se.isSrcSubdir(i, o))
      throw new Error(`Cannot copy '${i}' to a subdirectory of itself, '${o}'.`);
    if (Se.isSrcSubdir(o, i))
      throw new Error(`Cannot overwrite '${o}' with '${i}'.`);
    return await J.unlink(t), J.symlink(i, t);
  }
  a(To, "onLink");
  Nr.exports = Fo;
});

// ../node_modules/fs-extra/lib/copy/copy-sync.js
var $r = S((Sc, Mr) => {
  "use strict";
  var H = pe(), be = require("path"), Lo = X().mkdirsSync, No = ct().utimesMillisSync, Ee = ue();
  function Ro(e, r, t) {
    typeof t == "function" && (t = { filter: t }), t = t || {}, t.clobber = "clobber" in t ? !!t.clobber : !0, t.overwrite = "overwrite" in t ?
    !!t.overwrite : t.clobber, t.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0002"
    );
    let { srcStat: n, destStat: i } = Ee.checkPathsSync(e, r, "copy", t);
    if (Ee.checkParentPathsSync(e, n, r, "copy"), t.filter && !t.filter(e, r)) return;
    let o = be.dirname(r);
    return H.existsSync(o) || Lo(o), Cr(i, e, r, t);
  }
  a(Ro, "copySync");
  function Cr(e, r, t, n) {
    let o = (n.dereference ? H.statSync : H.lstatSync)(r);
    if (o.isDirectory()) return Jo(o, e, r, t, n);
    if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice()) return Co(o, e, r, t, n);
    if (o.isSymbolicLink()) return Go(e, r, t, n);
    throw o.isSocket() ? new Error(`Cannot copy a socket file: ${r}`) : o.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${r}`) : new Error(
    `Unknown file: ${r}`);
  }
  a(Cr, "getStats");
  function Co(e, r, t, n, i) {
    return r ? Io(e, t, n, i) : Ir(e, t, n, i);
  }
  a(Co, "onFile");
  function Io(e, r, t, n) {
    if (n.overwrite)
      return H.unlinkSync(t), Ir(e, r, t, n);
    if (n.errorOnExist)
      throw new Error(`'${t}' already exists`);
  }
  a(Io, "mayCopyFile");
  function Ir(e, r, t, n) {
    return H.copyFileSync(r, t), n.preserveTimestamps && Ao(e.mode, r, t), lt(t, e.mode);
  }
  a(Ir, "copyFile");
  function Ao(e, r, t) {
    return Mo(e) && $o(t, e), Wo(r, t);
  }
  a(Ao, "handleTimestamps");
  function Mo(e) {
    return (e & 128) === 0;
  }
  a(Mo, "fileIsNotWritable");
  function $o(e, r) {
    return lt(e, r | 128);
  }
  a($o, "makeFileWritable");
  function lt(e, r) {
    return H.chmodSync(e, r);
  }
  a(lt, "setDestMode");
  function Wo(e, r) {
    let t = H.statSync(e);
    return No(r, t.atime, t.mtime);
  }
  a(Wo, "setDestTimestamps");
  function Jo(e, r, t, n, i) {
    return r ? Ar(t, n, i) : Bo(e.mode, t, n, i);
  }
  a(Jo, "onDir");
  function Bo(e, r, t, n) {
    return H.mkdirSync(t), Ar(r, t, n), lt(t, e);
  }
  a(Bo, "mkDirAndCopy");
  function Ar(e, r, t) {
    H.readdirSync(e).forEach((n) => Uo(n, e, r, t));
  }
  a(Ar, "copyDir");
  function Uo(e, r, t, n) {
    let i = be.join(r, e), o = be.join(t, e);
    if (n.filter && !n.filter(i, o)) return;
    let { destStat: s } = Ee.checkPathsSync(i, o, "copy", n);
    return Cr(s, i, o, n);
  }
  a(Uo, "copyDirItem");
  function Go(e, r, t, n) {
    let i = H.readlinkSync(r);
    if (n.dereference && (i = be.resolve(process.cwd(), i)), e) {
      let o;
      try {
        o = H.readlinkSync(t);
      } catch (s) {
        if (s.code === "EINVAL" || s.code === "UNKNOWN") return H.symlinkSync(i, t);
        throw s;
      }
      if (n.dereference && (o = be.resolve(process.cwd(), o)), Ee.isSrcSubdir(i, o))
        throw new Error(`Cannot copy '${i}' to a subdirectory of itself, '${o}'.`);
      if (Ee.isSrcSubdir(o, i))
        throw new Error(`Cannot overwrite '${o}' with '${i}'.`);
      return Ho(i, t);
    } else
      return H.symlinkSync(i, t);
  }
  a(Go, "onLink");
  function Ho(e, r) {
    return H.unlinkSync(r), H.symlinkSync(e, r);
  }
  a(Ho, "copyLink");
  Mr.exports = Ro;
});

// ../node_modules/fs-extra/lib/copy/index.js
var Me = S((Ec, Wr) => {
  "use strict";
  var Vo = R().fromPromise;
  Wr.exports = {
    copy: Vo(Rr()),
    copySync: $r()
  };
});

// ../node_modules/fs-extra/lib/remove/index.js
var _e = S((_c, Br) => {
  "use strict";
  var Jr = pe(), zo = R().fromCallback;
  function Yo(e, r) {
    Jr.rm(e, { recursive: !0, force: !0 }, r);
  }
  a(Yo, "remove");
  function Ko(e) {
    Jr.rmSync(e, { recursive: !0, force: !0 });
  }
  a(Ko, "removeSync");
  Br.exports = {
    remove: zo(Yo),
    removeSync: Ko
  };
});

// ../node_modules/fs-extra/lib/empty/index.js
var Xr = S((Oc, Kr) => {
  "use strict";
  var Xo = R().fromPromise, Hr = G(), Vr = require("path"), zr = X(), Yr = _e(), Ur = Xo(/* @__PURE__ */ a(async function(r) {
    let t;
    try {
      t = await Hr.readdir(r);
    } catch {
      return zr.mkdirs(r);
    }
    return Promise.all(t.map((n) => Yr.remove(Vr.join(r, n))));
  }, "emptyDir"));
  function Gr(e) {
    let r;
    try {
      r = Hr.readdirSync(e);
    } catch {
      return zr.mkdirsSync(e);
    }
    r.forEach((t) => {
      t = Vr.join(e, t), Yr.removeSync(t);
    });
  }
  a(Gr, "emptyDirSync");
  Kr.exports = {
    emptyDirSync: Gr,
    emptydirSync: Gr,
    emptyDir: Ur,
    emptydir: Ur
  };
});

// ../node_modules/fs-extra/lib/ensure/file.js
var tn = S((Fc, en) => {
  "use strict";
  var Qo = R().fromPromise, Qr = require("path"), te = G(), Zr = X();
  async function Zo(e) {
    let r;
    try {
      r = await te.stat(e);
    } catch {
    }
    if (r && r.isFile()) return;
    let t = Qr.dirname(e), n = null;
    try {
      n = await te.stat(t);
    } catch (i) {
      if (i.code === "ENOENT") {
        await Zr.mkdirs(t), await te.writeFile(e, "");
        return;
      } else
        throw i;
    }
    n.isDirectory() ? await te.writeFile(e, "") : await te.readdir(t);
  }
  a(Zo, "createFile");
  function ea(e) {
    let r;
    try {
      r = te.statSync(e);
    } catch {
    }
    if (r && r.isFile()) return;
    let t = Qr.dirname(e);
    try {
      te.statSync(t).isDirectory() || te.readdirSync(t);
    } catch (n) {
      if (n && n.code === "ENOENT") Zr.mkdirsSync(t);
      else throw n;
    }
    te.writeFileSync(e, "");
  }
  a(ea, "createFileSync");
  en.exports = {
    createFile: Qo(Zo),
    createFileSync: ea
  };
});

// ../node_modules/fs-extra/lib/ensure/link.js
var sn = S((jc, an) => {
  "use strict";
  var ta = R().fromPromise, rn = require("path"), ae = G(), nn = X(), { pathExists: ra } = oe(), { areIdentical: on } = ue();
  async function na(e, r) {
    let t;
    try {
      t = await ae.lstat(r);
    } catch {
    }
    let n;
    try {
      n = await ae.lstat(e);
    } catch (s) {
      throw s.message = s.message.replace("lstat", "ensureLink"), s;
    }
    if (t && on(n, t)) return;
    let i = rn.dirname(r);
    await ra(i) || await nn.mkdirs(i), await ae.link(e, r);
  }
  a(na, "createLink");
  function ia(e, r) {
    let t;
    try {
      t = ae.lstatSync(r);
    } catch {
    }
    try {
      let o = ae.lstatSync(e);
      if (t && on(o, t)) return;
    } catch (o) {
      throw o.message = o.message.replace("lstat", "ensureLink"), o;
    }
    let n = rn.dirname(r);
    return ae.existsSync(n) || nn.mkdirsSync(n), ae.linkSync(e, r);
  }
  a(ia, "createLinkSync");
  an.exports = {
    createLink: ta(na),
    createLinkSync: ia
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink-paths.js
var un = S((Dc, cn) => {
  "use strict";
  var se = require("path"), xe = G(), { pathExists: oa } = oe(), aa = R().fromPromise;
  async function sa(e, r) {
    if (se.isAbsolute(e)) {
      try {
        await xe.lstat(e);
      } catch (o) {
        throw o.message = o.message.replace("lstat", "ensureSymlink"), o;
      }
      return {
        toCwd: e,
        toDst: e
      };
    }
    let t = se.dirname(r), n = se.join(t, e);
    if (await oa(n))
      return {
        toCwd: n,
        toDst: e
      };
    try {
      await xe.lstat(e);
    } catch (o) {
      throw o.message = o.message.replace("lstat", "ensureSymlink"), o;
    }
    return {
      toCwd: e,
      toDst: se.relative(t, e)
    };
  }
  a(sa, "symlinkPaths");
  function ca(e, r) {
    if (se.isAbsolute(e)) {
      if (!xe.existsSync(e)) throw new Error("absolute srcpath does not exist");
      return {
        toCwd: e,
        toDst: e
      };
    }
    let t = se.dirname(r), n = se.join(t, e);
    if (xe.existsSync(n))
      return {
        toCwd: n,
        toDst: e
      };
    if (!xe.existsSync(e)) throw new Error("relative srcpath does not exist");
    return {
      toCwd: e,
      toDst: se.relative(t, e)
    };
  }
  a(ca, "symlinkPathsSync");
  cn.exports = {
    symlinkPaths: aa(sa),
    symlinkPathsSync: ca
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink-type.js
var pn = S((Lc, fn) => {
  "use strict";
  var ln = G(), ua = R().fromPromise;
  async function la(e, r) {
    if (r) return r;
    let t;
    try {
      t = await ln.lstat(e);
    } catch {
      return "file";
    }
    return t && t.isDirectory() ? "dir" : "file";
  }
  a(la, "symlinkType");
  function fa(e, r) {
    if (r) return r;
    let t;
    try {
      t = ln.lstatSync(e);
    } catch {
      return "file";
    }
    return t && t.isDirectory() ? "dir" : "file";
  }
  a(fa, "symlinkTypeSync");
  fn.exports = {
    symlinkType: ua(la),
    symlinkTypeSync: fa
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink.js
var hn = S((Rc, yn) => {
  "use strict";
  var pa = R().fromPromise, mn = require("path"), Q = G(), { mkdirs: ma, mkdirsSync: da } = X(), { symlinkPaths: ya, symlinkPathsSync: ha } = un(),
  { symlinkType: wa, symlinkTypeSync: ga } = pn(), { pathExists: va } = oe(), { areIdentical: dn } = ue();
  async function Sa(e, r, t) {
    let n;
    try {
      n = await Q.lstat(r);
    } catch {
    }
    if (n && n.isSymbolicLink()) {
      let [u, y] = await Promise.all([
        Q.stat(e),
        Q.stat(r)
      ]);
      if (dn(u, y)) return;
    }
    let i = await ya(e, r);
    e = i.toDst;
    let o = await wa(i.toCwd, t), s = mn.dirname(r);
    return await va(s) || await ma(s), Q.symlink(e, r, o);
  }
  a(Sa, "createSymlink");
  function ba(e, r, t) {
    let n;
    try {
      n = Q.lstatSync(r);
    } catch {
    }
    if (n && n.isSymbolicLink()) {
      let u = Q.statSync(e), y = Q.statSync(r);
      if (dn(u, y)) return;
    }
    let i = ha(e, r);
    e = i.toDst, t = ga(i.toCwd, t);
    let o = mn.dirname(r);
    return Q.existsSync(o) || da(o), Q.symlinkSync(e, r, t);
  }
  a(ba, "createSymlinkSync");
  yn.exports = {
    createSymlink: pa(Sa),
    createSymlinkSync: ba
  };
});

// ../node_modules/fs-extra/lib/ensure/index.js
var xn = S((Ic, _n) => {
  "use strict";
  var { createFile: wn, createFileSync: gn } = tn(), { createLink: vn, createLinkSync: Sn } = sn(), { createSymlink: bn, createSymlinkSync: En } = hn();
  _n.exports = {
    // file
    createFile: wn,
    createFileSync: gn,
    ensureFile: wn,
    ensureFileSync: gn,
    // link
    createLink: vn,
    createLinkSync: Sn,
    ensureLink: vn,
    ensureLinkSync: Sn,
    // symlink
    createSymlink: bn,
    createSymlinkSync: En,
    ensureSymlink: bn,
    ensureSymlinkSync: En
  };
});

// ../node_modules/jsonfile/utils.js
var $e = S((Ac, On) => {
  function Ea(e, { EOL: r = `
`, finalEOL: t = !0, replacer: n = null, spaces: i } = {}) {
    let o = t ? r : "";
    return JSON.stringify(e, n, i).replace(/\n/g, r) + o;
  }
  a(Ea, "stringify");
  function _a(e) {
    return Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "");
  }
  a(_a, "stripBom");
  On.exports = { stringify: Ea, stripBom: _a };
});

// ../node_modules/jsonfile/index.js
var jn = S(($c, kn) => {
  var ye;
  try {
    ye = pe();
  } catch {
    ye = require("fs");
  }
  var We = R(), { stringify: Pn, stripBom: Fn } = $e();
  async function xa(e, r = {}) {
    typeof r == "string" && (r = { encoding: r });
    let t = r.fs || ye, n = "throws" in r ? r.throws : !0, i = await We.fromCallback(t.readFile)(e, r);
    i = Fn(i);
    let o;
    try {
      o = JSON.parse(i, r ? r.reviver : null);
    } catch (s) {
      if (n)
        throw s.message = `${e}: ${s.message}`, s;
      return null;
    }
    return o;
  }
  a(xa, "_readFile");
  var Oa = We.fromPromise(xa);
  function Pa(e, r = {}) {
    typeof r == "string" && (r = { encoding: r });
    let t = r.fs || ye, n = "throws" in r ? r.throws : !0;
    try {
      let i = t.readFileSync(e, r);
      return i = Fn(i), JSON.parse(i, r.reviver);
    } catch (i) {
      if (n)
        throw i.message = `${e}: ${i.message}`, i;
      return null;
    }
  }
  a(Pa, "readFileSync");
  async function Fa(e, r, t = {}) {
    let n = t.fs || ye, i = Pn(r, t);
    await We.fromCallback(n.writeFile)(e, i, t);
  }
  a(Fa, "_writeFile");
  var ka = We.fromPromise(Fa);
  function ja(e, r, t = {}) {
    let n = t.fs || ye, i = Pn(r, t);
    return n.writeFileSync(e, i, t);
  }
  a(ja, "writeFileSync");
  var qa = {
    readFile: Oa,
    readFileSync: Pa,
    writeFile: ka,
    writeFileSync: ja
  };
  kn.exports = qa;
});

// ../node_modules/fs-extra/lib/json/jsonfile.js
var Dn = S((Jc, qn) => {
  "use strict";
  var Je = jn();
  qn.exports = {
    // jsonfile exports
    readJson: Je.readFile,
    readJsonSync: Je.readFileSync,
    writeJson: Je.writeFile,
    writeJsonSync: Je.writeFileSync
  };
});

// ../node_modules/fs-extra/lib/output-file/index.js
var Be = S((Bc, Nn) => {
  "use strict";
  var Da = R().fromPromise, ft = G(), Tn = require("path"), Ln = X(), Ta = oe().pathExists;
  async function La(e, r, t = "utf-8") {
    let n = Tn.dirname(e);
    return await Ta(n) || await Ln.mkdirs(n), ft.writeFile(e, r, t);
  }
  a(La, "outputFile");
  function Na(e, ...r) {
    let t = Tn.dirname(e);
    ft.existsSync(t) || Ln.mkdirsSync(t), ft.writeFileSync(e, ...r);
  }
  a(Na, "outputFileSync");
  Nn.exports = {
    outputFile: Da(La),
    outputFileSync: Na
  };
});

// ../node_modules/fs-extra/lib/json/output-json.js
var Cn = S((Gc, Rn) => {
  "use strict";
  var { stringify: Ra } = $e(), { outputFile: Ca } = Be();
  async function Ia(e, r, t = {}) {
    let n = Ra(r, t);
    await Ca(e, n, t);
  }
  a(Ia, "outputJson");
  Rn.exports = Ia;
});

// ../node_modules/fs-extra/lib/json/output-json-sync.js
var An = S((Vc, In) => {
  "use strict";
  var { stringify: Aa } = $e(), { outputFileSync: Ma } = Be();
  function $a(e, r, t) {
    let n = Aa(r, t);
    Ma(e, n, t);
  }
  a($a, "outputJsonSync");
  In.exports = $a;
});

// ../node_modules/fs-extra/lib/json/index.js
var $n = S((Yc, Mn) => {
  "use strict";
  var Wa = R().fromPromise, V = Dn();
  V.outputJson = Wa(Cn());
  V.outputJsonSync = An();
  V.outputJSON = V.outputJson;
  V.outputJSONSync = V.outputJsonSync;
  V.writeJSON = V.writeJson;
  V.writeJSONSync = V.writeJsonSync;
  V.readJSON = V.readJson;
  V.readJSONSync = V.readJsonSync;
  Mn.exports = V;
});

// ../node_modules/fs-extra/lib/move/move.js
var Gn = S((Kc, Un) => {
  "use strict";
  var Ja = G(), Wn = require("path"), { copy: Ba } = Me(), { remove: Bn } = _e(), { mkdirp: Ua } = X(), { pathExists: Ga } = oe(), Jn = ue();
  async function Ha(e, r, t = {}) {
    let n = t.overwrite || t.clobber || !1, { srcStat: i, isChangingCase: o = !1 } = await Jn.checkPaths(e, r, "move", t);
    await Jn.checkParentPaths(e, i, r, "move");
    let s = Wn.dirname(r);
    return Wn.parse(s).root !== s && await Ua(s), Va(e, r, n, o);
  }
  a(Ha, "move");
  async function Va(e, r, t, n) {
    if (!n) {
      if (t)
        await Bn(r);
      else if (await Ga(r))
        throw new Error("dest already exists.");
    }
    try {
      await Ja.rename(e, r);
    } catch (i) {
      if (i.code !== "EXDEV")
        throw i;
      await za(e, r, t);
    }
  }
  a(Va, "doRename");
  async function za(e, r, t) {
    return await Ba(e, r, {
      overwrite: t,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), Bn(e);
  }
  a(za, "moveAcrossDevice");
  Un.exports = Ha;
});

// ../node_modules/fs-extra/lib/move/move-sync.js
var Kn = S((Qc, Yn) => {
  "use strict";
  var Vn = pe(), mt = require("path"), Ya = Me().copySync, zn = _e().removeSync, Ka = X().mkdirpSync, Hn = ue();
  function Xa(e, r, t) {
    t = t || {};
    let n = t.overwrite || t.clobber || !1, { srcStat: i, isChangingCase: o = !1 } = Hn.checkPathsSync(e, r, "move", t);
    return Hn.checkParentPathsSync(e, i, r, "move"), Qa(r) || Ka(mt.dirname(r)), Za(e, r, n, o);
  }
  a(Xa, "moveSync");
  function Qa(e) {
    let r = mt.dirname(e);
    return mt.parse(r).root === r;
  }
  a(Qa, "isParentRoot");
  function Za(e, r, t, n) {
    if (n) return pt(e, r, t);
    if (t)
      return zn(r), pt(e, r, t);
    if (Vn.existsSync(r)) throw new Error("dest already exists.");
    return pt(e, r, t);
  }
  a(Za, "doRename");
  function pt(e, r, t) {
    try {
      Vn.renameSync(e, r);
    } catch (n) {
      if (n.code !== "EXDEV") throw n;
      return es(e, r, t);
    }
  }
  a(pt, "rename");
  function es(e, r, t) {
    return Ya(e, r, {
      overwrite: t,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), zn(e);
  }
  a(es, "moveAcrossDevice");
  Yn.exports = Xa;
});

// ../node_modules/fs-extra/lib/move/index.js
var Qn = S((eu, Xn) => {
  "use strict";
  var ts = R().fromPromise;
  Xn.exports = {
    move: ts(Gn()),
    moveSync: Kn()
  };
});

// ../node_modules/fs-extra/lib/index.js
var Oe = S((tu, Zn) => {
  "use strict";
  Zn.exports = {
    // Export promiseified graceful-fs:
    ...G(),
    // Export extra methods:
    ...Me(),
    ...Xr(),
    ...xn(),
    ...$n(),
    ...X(),
    ...Qn(),
    ...Be(),
    ...oe(),
    ..._e()
  };
});

// ../node_modules/ejs/lib/utils.js
var ti = S((z) => {
  "use strict";
  var rs = /[|\\{}()[\]^$+*?.]/g, ns = Object.prototype.hasOwnProperty, dt = /* @__PURE__ */ a(function(e, r) {
    return ns.apply(e, [r]);
  }, "hasOwn");
  z.escapeRegExpChars = function(e) {
    return e ? String(e).replace(rs, "\\$&") : "";
  };
  var is = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&#34;",
    "'": "&#39;"
  }, os = /[&<>'"]/g;
  function as(e) {
    return is[e] || e;
  }
  a(as, "encode_char");
  var ss = `var _ENCODE_HTML_RULES = {
      "&": "&amp;"
    , "<": "&lt;"
    , ">": "&gt;"
    , '"': "&#34;"
    , "'": "&#39;"
    }
  , _MATCH_HTML = /[&<>'"]/g;
function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
};
`;
  z.escapeXML = function(e) {
    return e == null ? "" : String(e).replace(os, as);
  };
  function ei() {
    return Function.prototype.toString.call(this) + `;
` + ss;
  }
  a(ei, "escapeXMLToString");
  try {
    typeof Object.defineProperty == "function" ? Object.defineProperty(z.escapeXML, "toString", { value: ei }) : z.escapeXML.toString = ei;
  } catch {
    console.warn("Unable to set escapeXML.toString (is the Function prototype frozen?)");
  }
  z.shallowCopy = function(e, r) {
    if (r = r || {}, e != null)
      for (var t in r)
        dt(r, t) && (t === "__proto__" || t === "constructor" || (e[t] = r[t]));
    return e;
  };
  z.shallowCopyFromList = function(e, r, t) {
    if (t = t || [], r = r || {}, e != null)
      for (var n = 0; n < t.length; n++) {
        var i = t[n];
        if (typeof r[i] < "u") {
          if (!dt(r, i) || i === "__proto__" || i === "constructor")
            continue;
          e[i] = r[i];
        }
      }
    return e;
  };
  z.cache = {
    _data: {},
    set: /* @__PURE__ */ a(function(e, r) {
      this._data[e] = r;
    }, "set"),
    get: /* @__PURE__ */ a(function(e) {
      return this._data[e];
    }, "get"),
    remove: /* @__PURE__ */ a(function(e) {
      delete this._data[e];
    }, "remove"),
    reset: /* @__PURE__ */ a(function() {
      this._data = {};
    }, "reset")
  };
  z.hyphenToCamel = function(e) {
    return e.replace(/-[a-z]/g, function(r) {
      return r[1].toUpperCase();
    });
  };
  z.createNullProtoObjWherePossible = function() {
    return typeof Object.create == "function" ? function() {
      return /* @__PURE__ */ Object.create(null);
    } : { __proto__: null } instanceof Object ? function() {
      return {};
    } : function() {
      return { __proto__: null };
    };
  }();
  z.hasOwnOnlyObject = function(e) {
    var r = z.createNullProtoObjWherePossible();
    for (var t in e)
      dt(e, t) && (r[t] = e[t]);
    return r;
  };
});

// ../node_modules/ejs/package.json
var ri = S((iu, cs) => {
  cs.exports = {
    name: "ejs",
    description: "Embedded JavaScript templates",
    keywords: [
      "template",
      "engine",
      "ejs"
    ],
    version: "3.1.10",
    author: "Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)",
    license: "Apache-2.0",
    bin: {
      ejs: "./bin/cli.js"
    },
    main: "./lib/ejs.js",
    jsdelivr: "ejs.min.js",
    unpkg: "ejs.min.js",
    repository: {
      type: "git",
      url: "git://github.com/mde/ejs.git"
    },
    bugs: "https://github.com/mde/ejs/issues",
    homepage: "https://github.com/mde/ejs",
    dependencies: {
      jake: "^10.8.5"
    },
    devDependencies: {
      browserify: "^16.5.1",
      eslint: "^6.8.0",
      "git-directory-deploy": "^1.5.1",
      jsdoc: "^4.0.2",
      "lru-cache": "^4.0.1",
      mocha: "^10.2.0",
      "uglify-js": "^3.3.16"
    },
    engines: {
      node: ">=0.10.0"
    },
    scripts: {
      test: "npx jake test"
    }
  };
});

// ../node_modules/ejs/lib/ejs.js
var fi = S((E) => {
  "use strict";
  var ht = require("fs"), Pe = require("path"), D = ti(), ni = !1, us = ri().version, ls = "<", fs = ">", ps = "%", ui = "locals", ms = "ejs",
  ds = "(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)", li = [
    "delimiter",
    "scope",
    "context",
    "debug",
    "compileDebug",
    "client",
    "_with",
    "rmWhitespace",
    "strict",
    "filename",
    "async"
  ], ys = li.concat("cache"), ii = /^\uFEFF/, yt = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
  E.cache = D.cache;
  E.fileLoader = ht.readFileSync;
  E.localsName = ui;
  E.promiseImpl = new Function("return this;")().Promise;
  E.resolveInclude = function(e, r, t) {
    var n = Pe.dirname, i = Pe.extname, o = Pe.resolve, s = o(t ? r : n(r), e), u = i(e);
    return u || (s += ".ejs"), s;
  };
  function oi(e, r) {
    var t;
    if (r.some(function(n) {
      return t = E.resolveInclude(e, n, !0), ht.existsSync(t);
    }))
      return t;
  }
  a(oi, "resolvePaths");
  function hs(e, r) {
    var t, n, i = r.views, o = /^[A-Za-z]+:\\|^\//.exec(e);
    if (o && o.length)
      e = e.replace(/^\/*/, ""), Array.isArray(r.root) ? t = oi(e, r.root) : t = E.resolveInclude(e, r.root || "/", !0);
    else if (r.filename && (n = E.resolveInclude(e, r.filename), ht.existsSync(n) && (t = n)), !t && Array.isArray(i) && (t = oi(e, i)), !t &&
    typeof r.includer != "function")
      throw new Error('Could not find the include file "' + r.escapeFunction(e) + '"');
    return t;
  }
  a(hs, "getIncludePath");
  function Fe(e, r) {
    var t, n = e.filename, i = arguments.length > 1;
    if (e.cache) {
      if (!n)
        throw new Error("cache option requires a filename");
      if (t = E.cache.get(n), t)
        return t;
      i || (r = ai(n).toString().replace(ii, ""));
    } else if (!i) {
      if (!n)
        throw new Error("Internal EJS error: no file name or template provided");
      r = ai(n).toString().replace(ii, "");
    }
    return t = E.compile(r, e), e.cache && E.cache.set(n, t), t;
  }
  a(Fe, "handleCache");
  function ws(e, r, t) {
    var n;
    if (t) {
      try {
        n = Fe(e)(r);
      } catch (i) {
        return t(i);
      }
      t(null, n);
    } else {
      if (typeof E.promiseImpl == "function")
        return new E.promiseImpl(function(i, o) {
          try {
            n = Fe(e)(r), i(n);
          } catch (s) {
            o(s);
          }
        });
      throw new Error("Please provide a callback function");
    }
  }
  a(ws, "tryHandleCache");
  function ai(e) {
    return E.fileLoader(e);
  }
  a(ai, "fileLoader");
  function gs(e, r) {
    var t = D.shallowCopy(D.createNullProtoObjWherePossible(), r);
    if (t.filename = hs(e, t), typeof r.includer == "function") {
      var n = r.includer(e, t.filename);
      if (n && (n.filename && (t.filename = n.filename), n.template))
        return Fe(t, n.template);
    }
    return Fe(t);
  }
  a(gs, "includeFile");
  function si(e, r, t, n, i) {
    var o = r.split(`
`), s = Math.max(n - 3, 0), u = Math.min(o.length, n + 3), y = i(t), f = o.slice(s, u).map(function(c, d) {
      var l = d + s + 1;
      return (l == n ? " >> " : "    ") + l + "| " + c;
    }).join(`
`);
    throw e.path = y, e.message = (y || "ejs") + ":" + n + `
` + f + `

` + e.message, e;
  }
  a(si, "rethrow");
  function ci(e) {
    return e.replace(/;(\s*$)/, "$1");
  }
  a(ci, "stripSemi");
  E.compile = /* @__PURE__ */ a(function(r, t) {
    var n;
    return t && t.scope && (ni || (console.warn("`scope` option is deprecated and will be removed in EJS 3"), ni = !0), t.context || (t.context =
    t.scope), delete t.scope), n = new L(r, t), n.compile();
  }, "compile");
  E.render = function(e, r, t) {
    var n = r || D.createNullProtoObjWherePossible(), i = t || D.createNullProtoObjWherePossible();
    return arguments.length == 2 && D.shallowCopyFromList(i, n, li), Fe(i, e)(n);
  };
  E.renderFile = function() {
    var e = Array.prototype.slice.call(arguments), r = e.shift(), t, n = { filename: r }, i, o;
    return typeof arguments[arguments.length - 1] == "function" && (t = e.pop()), e.length ? (i = e.shift(), e.length ? D.shallowCopy(n, e.pop()) :
    (i.settings && (i.settings.views && (n.views = i.settings.views), i.settings["view cache"] && (n.cache = !0), o = i.settings["view optio\
ns"], o && D.shallowCopy(n, o)), D.shallowCopyFromList(n, i, ys)), n.filename = r) : i = D.createNullProtoObjWherePossible(), ws(n, i, t);
  };
  E.Template = L;
  E.clearCache = function() {
    E.cache.reset();
  };
  function L(e, r) {
    var t = D.hasOwnOnlyObject(r), n = D.createNullProtoObjWherePossible();
    this.templateText = e, this.mode = null, this.truncate = !1, this.currentLine = 1, this.source = "", n.client = t.client || !1, n.escapeFunction =
    t.escape || t.escapeFunction || D.escapeXML, n.compileDebug = t.compileDebug !== !1, n.debug = !!t.debug, n.filename = t.filename, n.openDelimiter =
    t.openDelimiter || E.openDelimiter || ls, n.closeDelimiter = t.closeDelimiter || E.closeDelimiter || fs, n.delimiter = t.delimiter || E.
    delimiter || ps, n.strict = t.strict || !1, n.context = t.context, n.cache = t.cache || !1, n.rmWhitespace = t.rmWhitespace, n.root = t.
    root, n.includer = t.includer, n.outputFunctionName = t.outputFunctionName, n.localsName = t.localsName || E.localsName || ui, n.views =
    t.views, n.async = t.async, n.destructuredLocals = t.destructuredLocals, n.legacyInclude = typeof t.legacyInclude < "u" ? !!t.legacyInclude :
    !0, n.strict ? n._with = !1 : n._with = typeof t._with < "u" ? t._with : !0, this.opts = n, this.regex = this.createRegex();
  }
  a(L, "Template");
  L.modes = {
    EVAL: "eval",
    ESCAPED: "escaped",
    RAW: "raw",
    COMMENT: "comment",
    LITERAL: "literal"
  };
  L.prototype = {
    createRegex: /* @__PURE__ */ a(function() {
      var e = ds, r = D.escapeRegExpChars(this.opts.delimiter), t = D.escapeRegExpChars(this.opts.openDelimiter), n = D.escapeRegExpChars(this.
      opts.closeDelimiter);
      return e = e.replace(/%/g, r).replace(/</g, t).replace(/>/g, n), new RegExp(e);
    }, "createRegex"),
    compile: /* @__PURE__ */ a(function() {
      var e, r, t = this.opts, n = "", i = "", o = t.escapeFunction, s, u = t.filename ? JSON.stringify(t.filename) : "undefined";
      if (!this.source) {
        if (this.generateSource(), n += `  var __output = "";
  function __append(s) { if (s !== undefined && s !== null) __output += s }
`, t.outputFunctionName) {
          if (!yt.test(t.outputFunctionName))
            throw new Error("outputFunctionName is not a valid JS identifier.");
          n += "  var " + t.outputFunctionName + ` = __append;
`;
        }
        if (t.localsName && !yt.test(t.localsName))
          throw new Error("localsName is not a valid JS identifier.");
        if (t.destructuredLocals && t.destructuredLocals.length) {
          for (var y = "  var __locals = (" + t.localsName + ` || {}),
`, f = 0; f < t.destructuredLocals.length; f++) {
            var c = t.destructuredLocals[f];
            if (!yt.test(c))
              throw new Error("destructuredLocals[" + f + "] is not a valid JS identifier.");
            f > 0 && (y += `,
  `), y += c + " = __locals." + c;
          }
          n += y + `;
`;
        }
        t._with !== !1 && (n += "  with (" + t.localsName + ` || {}) {
`, i += `  }
`), i += `  return __output;
`, this.source = n + this.source + i;
      }
      t.compileDebug ? e = `var __line = 1
  , __lines = ` + JSON.stringify(this.templateText) + `
  , __filename = ` + u + `;
try {
` + this.source + `} catch (e) {
  rethrow(e, __lines, __filename, __line, escapeFn);
}
` : e = this.source, t.client && (e = "escapeFn = escapeFn || " + o.toString() + `;
` + e, t.compileDebug && (e = "rethrow = rethrow || " + si.toString() + `;
` + e)), t.strict && (e = `"use strict";
` + e), t.debug && console.log(e), t.compileDebug && t.filename && (e = e + `
//# sourceURL=` + u + `
`);
      try {
        if (t.async)
          try {
            s = new Function("return (async function(){}).constructor;")();
          } catch (p) {
            throw p instanceof SyntaxError ? new Error("This environment does not support async/await") : p;
          }
        else
          s = Function;
        r = new s(t.localsName + ", escapeFn, include, rethrow", e);
      } catch (p) {
        throw p instanceof SyntaxError && (t.filename && (p.message += " in " + t.filename), p.message += ` while compiling ejs

`, p.message += `If the above error is not helpful, you may want to try EJS-Lint:
`, p.message += "https://github.com/RyanZim/EJS-Lint", t.async || (p.message += `
`, p.message += "Or, if you meant to create an async function, pass `async: true` as an option.")), p;
      }
      var d = t.client ? r : /* @__PURE__ */ a(function(h) {
        var w = /* @__PURE__ */ a(function(v, O) {
          var x = D.shallowCopy(D.createNullProtoObjWherePossible(), h);
          return O && (x = D.shallowCopy(x, O)), gs(v, t)(x);
        }, "include");
        return r.apply(
          t.context,
          [h || D.createNullProtoObjWherePossible(), o, w, si]
        );
      }, "anonymous");
      if (t.filename && typeof Object.defineProperty == "function") {
        var l = t.filename, m = Pe.basename(l, Pe.extname(l));
        try {
          Object.defineProperty(d, "name", {
            value: m,
            writable: !1,
            enumerable: !1,
            configurable: !0
          });
        } catch {
        }
      }
      return d;
    }, "compile"),
    generateSource: /* @__PURE__ */ a(function() {
      var e = this.opts;
      e.rmWhitespace && (this.templateText = this.templateText.replace(/[\r\n]+/g, `
`).replace(/^\s+|\s+$/gm, "")), this.templateText = this.templateText.replace(/[ \t]*<%_/gm, "<%_").replace(/_%>[ \t]*/gm, "_%>");
      var r = this, t = this.parseTemplateText(), n = this.opts.delimiter, i = this.opts.openDelimiter, o = this.opts.closeDelimiter;
      t && t.length && t.forEach(function(s, u) {
        var y;
        if (s.indexOf(i + n) === 0 && s.indexOf(i + n + n) !== 0 && (y = t[u + 2], !(y == n + o || y == "-" + n + o || y == "_" + n + o)))
          throw new Error('Could not find matching close tag for "' + s + '".');
        r.scanLine(s);
      });
    }, "generateSource"),
    parseTemplateText: /* @__PURE__ */ a(function() {
      for (var e = this.templateText, r = this.regex, t = r.exec(e), n = [], i; t; )
        i = t.index, i !== 0 && (n.push(e.substring(0, i)), e = e.slice(i)), n.push(t[0]), e = e.slice(t[0].length), t = r.exec(e);
      return e && n.push(e), n;
    }, "parseTemplateText"),
    _addOutput: /* @__PURE__ */ a(function(e) {
      if (this.truncate && (e = e.replace(/^(?:\r\n|\r|\n)/, ""), this.truncate = !1), !e)
        return e;
      e = e.replace(/\\/g, "\\\\"), e = e.replace(/\n/g, "\\n"), e = e.replace(/\r/g, "\\r"), e = e.replace(/"/g, '\\"'), this.source += '  \
  ; __append("' + e + `")
`;
    }, "_addOutput"),
    scanLine: /* @__PURE__ */ a(function(e) {
      var r = this, t = this.opts.delimiter, n = this.opts.openDelimiter, i = this.opts.closeDelimiter, o = 0;
      switch (o = e.split(`
`).length - 1, e) {
        case n + t:
        case n + t + "_":
          this.mode = L.modes.EVAL;
          break;
        case n + t + "=":
          this.mode = L.modes.ESCAPED;
          break;
        case n + t + "-":
          this.mode = L.modes.RAW;
          break;
        case n + t + "#":
          this.mode = L.modes.COMMENT;
          break;
        case n + t + t:
          this.mode = L.modes.LITERAL, this.source += '    ; __append("' + e.replace(n + t + t, n + t) + `")
`;
          break;
        case t + t + i:
          this.mode = L.modes.LITERAL, this.source += '    ; __append("' + e.replace(t + t + i, t + i) + `")
`;
          break;
        case t + i:
        case "-" + t + i:
        case "_" + t + i:
          this.mode == L.modes.LITERAL && this._addOutput(e), this.mode = null, this.truncate = e.indexOf("-") === 0 || e.indexOf("_") === 0;
          break;
        default:
          if (this.mode) {
            switch (this.mode) {
              case L.modes.EVAL:
              case L.modes.ESCAPED:
              case L.modes.RAW:
                e.lastIndexOf("//") > e.lastIndexOf(`
`) && (e += `
`);
            }
            switch (this.mode) {
              case L.modes.EVAL:
                this.source += "    ; " + e + `
`;
                break;
              case L.modes.ESCAPED:
                this.source += "    ; __append(escapeFn(" + ci(e) + `))
`;
                break;
              case L.modes.RAW:
                this.source += "    ; __append(" + ci(e) + `)
`;
                break;
              case L.modes.COMMENT:
                break;
              case L.modes.LITERAL:
                this._addOutput(e);
                break;
            }
          } else
            this._addOutput(e);
      }
      r.opts.compileDebug && o && (this.currentLine += o, this.source += "    ; __line = " + this.currentLine + `
`);
    }, "scanLine")
  };
  E.escapeXML = D.escapeXML;
  E.__express = E.renderFile;
  E.VERSION = us;
  E.name = ms;
  typeof window < "u" && (window.ejs = E);
});

// src/builder-manager/index.ts
var js = {};
Ft(js, {
  bail: () => ki,
  build: () => Ps,
  corePresets: () => Fs,
  executor: () => bt,
  getConfig: () => St,
  overridePresets: () => ks,
  start: () => Os
});
module.exports = jt(js);
var Y = require("node:path"), xi = require("@storybook/core/common"), Oi = require("@storybook/core/manager/globals-module-info"), He = require("@storybook/core/node-logger");

// ../node_modules/@fal-works/esbuild-plugin-global-externals/lib/module-info.js
var qt = /* @__PURE__ */ a((e) => {
  let {
    type: r = "esm",
    varName: t,
    namedExports: n = null,
    defaultExport: i = !0
  } = typeof e == "string" ? { varName: e } : e;
  return { type: r, varName: t, namedExports: n, defaultExport: i };
}, "normalizeModuleInfo");

// ../node_modules/@fal-works/esbuild-plugin-global-externals/lib/on-load.js
var Ri = /* @__PURE__ */ a((e) => `module.exports = ${e};`, "createCjsContents");
var Ci = /* @__PURE__ */ a((e, r, t) => {
  let n = t ? [`export default ${e};`] : [];
  if (r && r.length) {
    let i = [...new Set(r)].join(", ");
    n.push(`const { ${i} } = ${e};`), n.push(`export { ${i} };`);
  }
  return n.join(`
`);
}, "createEsmContents"), Dt = /* @__PURE__ */ a((e) => {
  let { type: r, varName: t, namedExports: n, defaultExport: i } = e;
  switch (r) {
    case "esm":
      return Ci(t, n, i);
    case "cjs":
      return Ri(t);
  }
}, "createContents");

// ../node_modules/@fal-works/esbuild-plugin-global-externals/lib/with-reg-exp.js
var Ye = "global-externals", Ke = /* @__PURE__ */ a((e) => {
  let { modulePathFilter: r, getModuleInfo: t } = e;
  return {
    name: Ye,
    setup(n) {
      n.onResolve({ filter: r }, (i) => ({
        path: i.path,
        namespace: Ye
      })), n.onLoad({ filter: /.*/, namespace: Ye }, (i) => {
        let o = i.path, s = qt(t(o));
        return { contents: Dt(s) };
      });
    }
  };
}, "globalExternalsWithRegExp");

// ../node_modules/@fal-works/esbuild-plugin-global-externals/lib/with-object.js
var Xe = /* @__PURE__ */ a((e) => {
  let r = {
    modulePathFilter: new RegExp(`^(?:${Object.keys(e).join("|")})$`),
    getModuleInfo: /* @__PURE__ */ a((t) => e[t], "getModuleInfo")
  };
  return Ke(r);
}, "globalExternals");

// src/builder-manager/index.ts
var Pi = B(nr(), 1), Fi = B(or(), 1), Pt = B(require("express"), 1), Ve = B(Oe(), 1);

// src/builder-manager/utils/data.ts
var yi = require("node:path"), hi = require("@storybook/core/common");

// src/builder-manager/utils/template.ts
var Ue = require("node:path"), pi = B(fi(), 1), mi = B(Oe(), 1);
var wt = /* @__PURE__ */ a(async (e) => (0, Ue.join)((0, Ue.dirname)(require.resolve("@storybook/core/package.json")), "assets/server", e), "\
getTemplatePath"), di = /* @__PURE__ */ a(async (e) => {
  let r = await wt(e);
  return mi.default.readFile(r, "utf8");
}, "readTemplate");
var gt = /* @__PURE__ */ a(async (e, r, t, n, i, o, s, u, y, f, c, { versionCheck: d, previewUrl: l, configType: m, ignorePreview: p }, h) => {
  let w = await r, v = await e, O = Object.entries(h).reduce(
    (x, [T, W]) => ({ ...x, [T]: JSON.stringify(W) }),
    {}
  );
  return (0, pi.render)(v, {
    title: w ? `${w} - Storybook` : "Storybook",
    files: { js: o, css: i },
    favicon: await t,
    globals: {
      FEATURES: JSON.stringify(await s, null, 2),
      REFS: JSON.stringify(await u, null, 2),
      LOGLEVEL: JSON.stringify(await y, null, 2),
      DOCS_OPTIONS: JSON.stringify(await f, null, 2),
      CONFIG_TYPE: JSON.stringify(await m, null, 2),
      // These two need to be double stringified because the UI expects a string
      VERSIONCHECK: JSON.stringify(JSON.stringify(d), null, 2),
      PREVIEW_URL: JSON.stringify(l, null, 2),
      // global preview URL
      TAGS_OPTIONS: JSON.stringify(await c, null, 2),
      ...O
    },
    head: await n || "",
    ignorePreview: p
  });
}, "renderHTML");

// src/builder-manager/utils/data.ts
var vt = /* @__PURE__ */ a(async (e) => {
  let r = (0, hi.getRefs)(e), t = e.presets.apply("favicon").then((l) => (0, yi.basename)(l)), n = e.presets.apply("features"), i = e.presets.
  apply("logLevel"), o = e.presets.apply("title"), s = e.presets.apply("docs", {}), u = e.presets.apply("tags", {}), y = di("template.ejs"),
  f = e.presets.apply("managerHead"), [c, d] = await Promise.all([
    //
    bt.get(),
    St(e)
  ]);
  return {
    refs: r,
    features: n,
    title: o,
    docsOptions: s,
    template: y,
    customHead: f,
    instance: c,
    config: d,
    logLevel: i,
    favicon: t,
    tagsOptions: u
  };
}, "getData");

// src/builder-manager/utils/files.ts
var Ge = require("node:path"), Et = B(Oe(), 1);

// ../node_modules/slash/index.js
function ke(e) {
  return e.startsWith("\\\\?\\") ? e : e.replace(/\\/g, "/");
}
a(ke, "slash");

// src/builder-manager/utils/files.ts
async function _t(e, r) {
  let t = await Promise.all(
    r?.map(async (o) => {
      let { location: s, url: u } = vs(o, e);
      return await Et.default.ensureFile(s), await Et.default.writeFile(s, o.contents), u;
    }) || []
  ), n = t.filter((o) => o.endsWith(".js"));
  return { cssFiles: t.filter((o) => o.endsWith(".css")), jsFiles: n };
}
a(_t, "readOrderedFiles");
function vs(e, r) {
  let t = e.path.replace(r, ""), n = (0, Ge.normalize)((0, Ge.join)(r, t)), i = `./sb-addons${ke(t).split("/").map(encodeURIComponent).join(
  "/")}`;
  return { location: n, url: i };
}
a(vs, "sanitizePath");

// src/builder-manager/utils/framework.ts
var gi = require("node:path"), je = require("@storybook/core/common");
var wi = /* @__PURE__ */ a((e) => {
  if (e)
    return typeof e == "string" ? e : e.name;
}, "pluckNameFromConfigProperty"), vi = /* @__PURE__ */ a((e) => e.replaceAll(gi.sep, "/"), "normalizePath"), Ss = /* @__PURE__ */ a((e) => vi(
e).match(/(@storybook\/.*)$/)?.[1], "pluckStorybookPackageFromPath"), bs = /* @__PURE__ */ a((e) => vi(e).split("node_modules/")[1] ?? e, "p\
luckThirdPartyPackageFromPath"), xt = /* @__PURE__ */ a(async (e) => {
  let r = {}, { builder: t } = await e.presets.apply("core"), n = await (0, je.getFrameworkName)(e);
  await (0, je.extractProperRendererNameFromFramework)(n) && (r.STORYBOOK_RENDERER = await (0, je.extractProperRendererNameFromFramework)(n) ??
  void 0);
  let o = wi(t);
  o && (r.STORYBOOK_BUILDER = Ss(o) ?? bs(o));
  let s = wi(await e.presets.apply("framework"));
  return s && (r.STORYBOOK_FRAMEWORK = s), r;
}, "buildFrameworkGlobalsFromOptions");

// src/builder-manager/utils/managerEntries.ts
var re = require("node:path"), bi = require("@storybook/core/common"), Ot = B(Oe(), 1);
var Si = /* @__PURE__ */ a((e) => e.replaceAll(".", "").replaceAll("@", "").replaceAll(re.sep, "-").replaceAll("/", "-").replaceAll(new RegExp(
/^(-)+/g), ""), "sanitizeBase"), Es = /* @__PURE__ */ a((e) => {
  let r = e.split(/-?node_modules-?/);
  return r[r.length - 1].replaceAll("storybook-addon-", "").replaceAll("dist-", "");
}, "sanitizeFinal");
async function Ei(e, r) {
  return Promise.all(
    e.map(async (t, n) => {
      let { name: i, dir: o } = (0, re.parse)(t), s = (0, bi.resolvePathInStorybookCache)("sb-manager", r);
      if (!s)
        throw new Error("Could not create/find cache directory");
      let u = (0, re.relative)(process.cwd(), o), y = (0, re.join)(
        s,
        Es((0, re.join)(`${Si(u)}-${n}`, `${Si(i)}-bundle.js`))
      );
      return await Ot.default.ensureFile(y), await Ot.default.writeFile(y, `import '${ke(t)}';`), y;
    })
  );
}
a(Ei, "wrapManagerEntries");

// src/builder-manager/utils/safeResolve.ts
var _i = /* @__PURE__ */ a((e) => {
  try {
    return Promise.resolve(require.resolve(e));
  } catch {
    return Promise.resolve(!1);
  }
}, "safeResolve");

// src/builder-manager/index.ts
var ze, he, St = /* @__PURE__ */ a(async (e) => {
  let [r, t, n, i] = await Promise.all([
    e.presets.apply("managerEntries", []),
    _i((0, Y.join)(e.configDir, "manager")),
    wt("addon.tsconfig.json"),
    e.presets.apply("env")
  ]), o = t ? [...r, t] : r;
  return {
    entryPoints: await Ei(o, e.cacheKey),
    outdir: (0, Y.join)(e.outputDir || "./", "sb-addons"),
    format: "iife",
    write: !1,
    ignoreAnnotations: !0,
    resolveExtensions: [".ts", ".tsx", ".mjs", ".js", ".jsx"],
    outExtension: { ".js": ".js" },
    loader: {
      ".js": "jsx",
      // media
      ".png": "dataurl",
      ".gif": "dataurl",
      ".jpg": "dataurl",
      ".jpeg": "dataurl",
      ".svg": "dataurl",
      ".webp": "dataurl",
      ".webm": "dataurl",
      ".mp3": "dataurl",
      // modern fonts
      ".woff2": "dataurl",
      // legacy font formats
      ".woff": "dataurl",
      ".eot": "dataurl",
      ".ttf": "dataurl"
    },
    target: ["chrome100", "safari15", "firefox91"],
    platform: "browser",
    bundle: !0,
    minify: !0,
    sourcemap: !1,
    conditions: ["browser", "module", "default"],
    jsxFactory: "React.createElement",
    jsxFragment: "React.Fragment",
    jsx: "transform",
    jsxImportSource: "react",
    tsconfig: n,
    legalComments: "external",
    plugins: [
      (0, Fi.default)({
        process: require.resolve("process/browser.js"),
        util: require.resolve("util/util.js"),
        assert: require.resolve("browser-assert")
      }),
      Xe(Oi.globalsModuleInfoMap),
      (0, Pi.pnpPlugin)()
    ],
    banner: {
      js: "try{"
    },
    footer: {
      js: '}catch(e){ console.error("[Storybook] One of your manager-entries failed: " + import.meta.url, e); }'
    },
    define: {
      "process.env": JSON.stringify(i),
      ...(0, xi.stringifyProcessEnvs)(i),
      global: "window",
      module: "{}"
    }
  };
}, "getConfig"), bt = {
  get: /* @__PURE__ */ a(async () => {
    let { build: e } = await import("esbuild");
    return e;
  }, "get")
}, _s = /* @__PURE__ */ a(async function* ({
  startTime: r,
  options: t,
  router: n
}) {
  t.quiet || He.logger.info("=> Starting manager..");
  let {
    config: i,
    favicon: o,
    customHead: s,
    features: u,
    instance: y,
    refs: f,
    template: c,
    title: d,
    logLevel: l,
    docsOptions: m,
    tagsOptions: p
  } = await vt(t);
  yield;
  let h = i.outdir;
  await Ve.default.remove(h), yield, ze = await y({
    ...i
  }), yield;
  let w = (0, Y.join)(
    (0, Y.dirname)(require.resolve("@storybook/core/package.json")),
    "dist",
    "manager"
  );
  n.use("/sb-addons", Pt.default.static(h, { immutable: !0, maxAge: "5m" })), n.use("/sb-manager", Pt.default.static(w, { immutable: !0, maxAge: "\
5m" }));
  let { cssFiles: v, jsFiles: O } = await _t(h, ze?.outputFiles), x = await xt(t);
  yield;
  let T = await gt(
    c,
    d,
    o,
    s,
    v,
    O,
    u,
    f,
    l,
    m,
    p,
    t,
    x
  );
  return yield, n.use("/", ({ path: W }, K, Z) => {
    W === "/" ? K.status(200).send(T) : Z();
  }), n.use("/index.html", ({ path: W }, K) => {
    K.status(200).send(T);
  }), {
    bail: ki,
    stats: {
      toJson: /* @__PURE__ */ a(() => ({}), "toJson")
    },
    totalTime: process.hrtime(r)
  };
}, "starterGeneratorFn"), xs = /* @__PURE__ */ a(async function* ({ startTime: r, options: t }) {
  if (!t.outputDir)
    throw new Error("outputDir is required");
  He.logger.info("=> Building manager..");
  let {
    config: n,
    customHead: i,
    favicon: o,
    features: s,
    instance: u,
    refs: y,
    template: f,
    title: c,
    logLevel: d,
    docsOptions: l,
    tagsOptions: m
  } = await vt(t);
  yield;
  let p = n.outdir, h = (0, Y.join)(
    (0, Y.dirname)(require.resolve("@storybook/core/package.json")),
    "dist",
    "manager"
  ), w = (0, Y.join)(t.outputDir, "sb-manager");
  ze = await u({
    ...n,
    minify: !0
  }), yield;
  let v = Ve.default.copy(h, w, {
    filter: /* @__PURE__ */ a((K) => {
      let { ext: Z } = (0, Y.parse)(K);
      return Z ? Z === ".js" : !0;
    }, "filter")
  }), { cssFiles: O, jsFiles: x } = await _t(p, ze?.outputFiles), T = await xt(t);
  yield;
  let W = await gt(
    f,
    c,
    o,
    i,
    O,
    x,
    s,
    y,
    d,
    l,
    m,
    t,
    T
  );
  return await Promise.all([
    //
    Ve.default.writeFile((0, Y.join)(t.outputDir, "index.html"), W),
    v
  ]), He.logger.trace({ message: "=> Manager built", time: process.hrtime(r) }), {
    toJson: /* @__PURE__ */ a(() => ({}), "toJson")
  };
}, "builderGeneratorFn"), ki = /* @__PURE__ */ a(async () => {
  if (he)
    try {
      await he.throw(new Error());
    } catch {
    }
}, "bail"), Os = /* @__PURE__ */ a(async (e) => {
  he = _s(e);
  let r;
  do
    r = await he.next();
  while (!r.done);
  return r.value;
}, "start"), Ps = /* @__PURE__ */ a(async (e) => {
  he = xs(e);
  let r;
  do
    r = await he.next();
  while (!r.done);
  return r.value;
}, "build"), Fs = [], ks = [];
