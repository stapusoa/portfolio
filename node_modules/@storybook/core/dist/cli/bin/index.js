import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
import { dirname as ESM_COMPAT_dirname } from 'node:path';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const __dirname = ESM_COMPAT_dirname(__filename);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var Xe = Object.create;
var G = Object.defineProperty;
var Ze = Object.getOwnPropertyDescriptor;
var et = Object.getOwnPropertyNames;
var tt = Object.getPrototypeOf, it = Object.prototype.hasOwnProperty;
var a = (r, e) => G(r, "name", { value: e, configurable: !0 }), S = /* @__PURE__ */ ((r) => typeof require < "u" ? require : typeof Proxy < "\
u" ? new Proxy(r, {
  get: (e, t) => (typeof require < "u" ? require : e)[t]
}) : r)(function(r) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + r + '" is not supported');
});
var A = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var nt = (r, e, t, i) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let n of et(e))
      !it.call(r, n) && n !== t && G(r, n, { get: () => e[n], enumerable: !(i = Ze(e, n)) || i.enumerable });
  return r;
};
var U = (r, e, t) => (t = r != null ? Xe(tt(r)) : {}, nt(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  e || !r || !r.__esModule ? G(t, "default", { value: r, enumerable: !0 }) : t,
  r
));

// ../node_modules/commander/lib/error.js
var P = A((X) => {
  var M = class extends Error {
    static {
      a(this, "CommanderError");
    }
    /**
     * Constructs the CommanderError class
     * @param {number} exitCode suggested exit code which could be used with process.exit
     * @param {string} code an id string representing the error
     * @param {string} message human-readable description of the error
     */
    constructor(e, t, i) {
      super(i), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name, this.code = t, this.exitCode = e, this.nestedError =
      void 0;
    }
  }, Q = class extends M {
    static {
      a(this, "InvalidArgumentError");
    }
    /**
     * Constructs the InvalidArgumentError class
     * @param {string} [message] explanation of why argument is invalid
     */
    constructor(e) {
      super(1, "commander.invalidArgument", e), Error.captureStackTrace(this, this.constructor), this.name = this.constructor.name;
    }
  };
  X.CommanderError = M;
  X.InvalidArgumentError = Q;
});

// ../node_modules/commander/lib/argument.js
var B = A((ee) => {
  var { InvalidArgumentError: Ot } = P(), Z = class {
    static {
      a(this, "Argument");
    }
    /**
     * Initialize a new command argument with the given name and description.
     * The default is that the argument is required, and you can explicitly
     * indicate this with <> around the name. Put [] around the name for an optional argument.
     *
     * @param {string} name
     * @param {string} [description]
     */
    constructor(e, t) {
      switch (this.description = t || "", this.variadic = !1, this.parseArg = void 0, this.defaultValue = void 0, this.defaultValueDescription =
      void 0, this.argChoices = void 0, e[0]) {
        case "<":
          this.required = !0, this._name = e.slice(1, -1);
          break;
        case "[":
          this.required = !1, this._name = e.slice(1, -1);
          break;
        default:
          this.required = !0, this._name = e;
          break;
      }
      this._name.length > 3 && this._name.slice(-3) === "..." && (this.variadic = !0, this._name = this._name.slice(0, -3));
    }
    /**
     * Return argument name.
     *
     * @return {string}
     */
    name() {
      return this._name;
    }
    /**
     * @package
     */
    _concatValue(e, t) {
      return t === this.defaultValue || !Array.isArray(t) ? [e] : t.concat(e);
    }
    /**
     * Set the default value, and optionally supply the description to be displayed in the help.
     *
     * @param {*} value
     * @param {string} [description]
     * @return {Argument}
     */
    default(e, t) {
      return this.defaultValue = e, this.defaultValueDescription = t, this;
    }
    /**
     * Set the custom handler for processing CLI command arguments into argument values.
     *
     * @param {Function} [fn]
     * @return {Argument}
     */
    argParser(e) {
      return this.parseArg = e, this;
    }
    /**
     * Only allow argument value to be one of choices.
     *
     * @param {string[]} values
     * @return {Argument}
     */
    choices(e) {
      return this.argChoices = e.slice(), this.parseArg = (t, i) => {
        if (!this.argChoices.includes(t))
          throw new Ot(
            `Allowed choices are ${this.argChoices.join(", ")}.`
          );
        return this.variadic ? this._concatValue(t, i) : t;
      }, this;
    }
    /**
     * Make argument required.
     *
     * @returns {Argument}
     */
    argRequired() {
      return this.required = !0, this;
    }
    /**
     * Make argument optional.
     *
     * @returns {Argument}
     */
    argOptional() {
      return this.required = !1, this;
    }
  };
  function Ct(r) {
    let e = r.name() + (r.variadic === !0 ? "..." : "");
    return r.required ? "<" + e + ">" : "[" + e + "]";
  }
  a(Ct, "humanReadableArgName");
  ee.Argument = Z;
  ee.humanReadableArgName = Ct;
});

// ../node_modules/commander/lib/help.js
var ie = A((ke) => {
  var { humanReadableArgName: yt } = B(), te = class {
    static {
      a(this, "Help");
    }
    constructor() {
      this.helpWidth = void 0, this.sortSubcommands = !1, this.sortOptions = !1, this.showGlobalOptions = !1;
    }
    /**
     * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
     *
     * @param {Command} cmd
     * @returns {Command[]}
     */
    visibleCommands(e) {
      let t = e.commands.filter((n) => !n._hidden), i = e._getHelpCommand();
      return i && !i._hidden && t.push(i), this.sortSubcommands && t.sort((n, s) => n.name().localeCompare(s.name())), t;
    }
    /**
     * Compare options for sort.
     *
     * @param {Option} a
     * @param {Option} b
     * @returns {number}
     */
    compareOptions(e, t) {
      let i = /* @__PURE__ */ a((n) => n.short ? n.short.replace(/^-/, "") : n.long.replace(/^--/, ""), "getSortKey");
      return i(e).localeCompare(i(t));
    }
    /**
     * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
     *
     * @param {Command} cmd
     * @returns {Option[]}
     */
    visibleOptions(e) {
      let t = e.options.filter((n) => !n.hidden), i = e._getHelpOption();
      if (i && !i.hidden) {
        let n = i.short && e._findOption(i.short), s = i.long && e._findOption(i.long);
        !n && !s ? t.push(i) : i.long && !s ? t.push(
          e.createOption(i.long, i.description)
        ) : i.short && !n && t.push(
          e.createOption(i.short, i.description)
        );
      }
      return this.sortOptions && t.sort(this.compareOptions), t;
    }
    /**
     * Get an array of the visible global options. (Not including help.)
     *
     * @param {Command} cmd
     * @returns {Option[]}
     */
    visibleGlobalOptions(e) {
      if (!this.showGlobalOptions) return [];
      let t = [];
      for (let i = e.parent; i; i = i.parent) {
        let n = i.options.filter(
          (s) => !s.hidden
        );
        t.push(...n);
      }
      return this.sortOptions && t.sort(this.compareOptions), t;
    }
    /**
     * Get an array of the arguments if any have a description.
     *
     * @param {Command} cmd
     * @returns {Argument[]}
     */
    visibleArguments(e) {
      return e._argsDescription && e.registeredArguments.forEach((t) => {
        t.description = t.description || e._argsDescription[t.name()] || "";
      }), e.registeredArguments.find((t) => t.description) ? e.registeredArguments : [];
    }
    /**
     * Get the command term to show in the list of subcommands.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    subcommandTerm(e) {
      let t = e.registeredArguments.map((i) => yt(i)).join(" ");
      return e._name + (e._aliases[0] ? "|" + e._aliases[0] : "") + (e.options.length ? " [options]" : "") + // simplistic check for non-help option
      (t ? " " + t : "");
    }
    /**
     * Get the option term to show in the list of options.
     *
     * @param {Option} option
     * @returns {string}
     */
    optionTerm(e) {
      return e.flags;
    }
    /**
     * Get the argument term to show in the list of arguments.
     *
     * @param {Argument} argument
     * @returns {string}
     */
    argumentTerm(e) {
      return e.name();
    }
    /**
     * Get the longest command term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestSubcommandTermLength(e, t) {
      return t.visibleCommands(e).reduce((i, n) => Math.max(i, t.subcommandTerm(n).length), 0);
    }
    /**
     * Get the longest option term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestOptionTermLength(e, t) {
      return t.visibleOptions(e).reduce((i, n) => Math.max(i, t.optionTerm(n).length), 0);
    }
    /**
     * Get the longest global option term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestGlobalOptionTermLength(e, t) {
      return t.visibleGlobalOptions(e).reduce((i, n) => Math.max(i, t.optionTerm(n).length), 0);
    }
    /**
     * Get the longest argument term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    longestArgumentTermLength(e, t) {
      return t.visibleArguments(e).reduce((i, n) => Math.max(i, t.argumentTerm(n).length), 0);
    }
    /**
     * Get the command usage to be displayed at the top of the built-in help.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    commandUsage(e) {
      let t = e._name;
      e._aliases[0] && (t = t + "|" + e._aliases[0]);
      let i = "";
      for (let n = e.parent; n; n = n.parent)
        i = n.name() + " " + i;
      return i + t + " " + e.usage();
    }
    /**
     * Get the description for the command.
     *
     * @param {Command} cmd
     * @returns {string}
     */
    commandDescription(e) {
      return e.description();
    }
    /**
     * Get the subcommand summary to show in the list of subcommands.
     * (Fallback to description for backwards compatibility.)
     *
     * @param {Command} cmd
     * @returns {string}
     */
    subcommandDescription(e) {
      return e.summary() || e.description();
    }
    /**
     * Get the option description to show in the list of options.
     *
     * @param {Option} option
     * @return {string}
     */
    optionDescription(e) {
      let t = [];
      return e.argChoices && t.push(
        // use stringify to match the display of the default value
        `choices: ${e.argChoices.map((i) => JSON.stringify(i)).join(", ")}`
      ), e.defaultValue !== void 0 && (e.required || e.optional || e.isBoolean() && typeof e.defaultValue == "boolean") && t.push(
        `default: ${e.defaultValueDescription || JSON.stringify(e.defaultValue)}`
      ), e.presetArg !== void 0 && e.optional && t.push(`preset: ${JSON.stringify(e.presetArg)}`), e.envVar !== void 0 && t.push(`env: ${e.envVar}`),
      t.length > 0 ? `${e.description} (${t.join(", ")})` : e.description;
    }
    /**
     * Get the argument description to show in the list of arguments.
     *
     * @param {Argument} argument
     * @return {string}
     */
    argumentDescription(e) {
      let t = [];
      if (e.argChoices && t.push(
        // use stringify to match the display of the default value
        `choices: ${e.argChoices.map((i) => JSON.stringify(i)).join(", ")}`
      ), e.defaultValue !== void 0 && t.push(
        `default: ${e.defaultValueDescription || JSON.stringify(e.defaultValue)}`
      ), t.length > 0) {
        let i = `(${t.join(", ")})`;
        return e.description ? `${e.description} ${i}` : i;
      }
      return e.description;
    }
    /**
     * Generate the built-in help text.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {string}
     */
    formatHelp(e, t) {
      let i = t.padWidth(e, t), n = t.helpWidth || 80, s = 2, o = 2;
      function u(_, w) {
        if (w) {
          let W = `${_.padEnd(i + o)}${w}`;
          return t.wrap(
            W,
            n - s,
            i + o
          );
        }
        return _;
      }
      a(u, "formatItem");
      function l(_) {
        return _.join(`
`).replace(/^/gm, " ".repeat(s));
      }
      a(l, "formatList");
      let c = [`Usage: ${t.commandUsage(e)}`, ""], h = t.commandDescription(e);
      h.length > 0 && (c = c.concat([
        t.wrap(h, n, 0),
        ""
      ]));
      let p = t.visibleArguments(e).map((_) => u(
        t.argumentTerm(_),
        t.argumentDescription(_)
      ));
      p.length > 0 && (c = c.concat(["Arguments:", l(p), ""]));
      let g = t.visibleOptions(e).map((_) => u(
        t.optionTerm(_),
        t.optionDescription(_)
      ));
      if (g.length > 0 && (c = c.concat(["Options:", l(g), ""])), this.showGlobalOptions) {
        let _ = t.visibleGlobalOptions(e).map((w) => u(
          t.optionTerm(w),
          t.optionDescription(w)
        ));
        _.length > 0 && (c = c.concat([
          "Global Options:",
          l(_),
          ""
        ]));
      }
      let y = t.visibleCommands(e).map((_) => u(
        t.subcommandTerm(_),
        t.subcommandDescription(_)
      ));
      return y.length > 0 && (c = c.concat(["Commands:", l(y), ""])), c.join(`
`);
    }
    /**
     * Calculate the pad width from the maximum term length.
     *
     * @param {Command} cmd
     * @param {Help} helper
     * @returns {number}
     */
    padWidth(e, t) {
      return Math.max(
        t.longestOptionTermLength(e, t),
        t.longestGlobalOptionTermLength(e, t),
        t.longestSubcommandTermLength(e, t),
        t.longestArgumentTermLength(e, t)
      );
    }
    /**
     * Wrap the given string to width characters per line, with lines after the first indented.
     * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
     *
     * @param {string} str
     * @param {number} width
     * @param {number} indent
     * @param {number} [minColumnWidth=40]
     * @return {string}
     *
     */
    wrap(e, t, i, n = 40) {
      let s = " \\f\\t\\v\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF", o = new RegExp(`[\\n][${s}]+`);
      if (e.match(o)) return e;
      let u = t - i;
      if (u < n) return e;
      let l = e.slice(0, i), c = e.slice(i).replace(`\r
`, `
`), h = " ".repeat(i), g = "\\s\u200B", y = new RegExp(
        `
|.{1,${u - 1}}([${g}]|$)|[^${g}]+?([${g}]|$)`,
        "g"
      ), _ = c.match(y) || [];
      return l + _.map((w, W) => w === `
` ? "" : (W > 0 ? h : "") + w.trimEnd()).join(`
`);
    }
  };
  ke.Help = te;
});

// ../node_modules/commander/lib/option.js
var oe = A((se) => {
  var { InvalidArgumentError: At } = P(), ne = class {
    static {
      a(this, "Option");
    }
    /**
     * Initialize a new `Option` with the given `flags` and `description`.
     *
     * @param {string} flags
     * @param {string} [description]
     */
    constructor(e, t) {
      this.flags = e, this.description = t || "", this.required = e.includes("<"), this.optional = e.includes("["), this.variadic = /\w\.\.\.[>\]]$/.
      test(e), this.mandatory = !1;
      let i = wt(e);
      this.short = i.shortFlag, this.long = i.longFlag, this.negate = !1, this.long && (this.negate = this.long.startsWith("--no-")), this.defaultValue =
      void 0, this.defaultValueDescription = void 0, this.presetArg = void 0, this.envVar = void 0, this.parseArg = void 0, this.hidden = !1,
      this.argChoices = void 0, this.conflictsWith = [], this.implied = void 0;
    }
    /**
     * Set the default value, and optionally supply the description to be displayed in the help.
     *
     * @param {*} value
     * @param {string} [description]
     * @return {Option}
     */
    default(e, t) {
      return this.defaultValue = e, this.defaultValueDescription = t, this;
    }
    /**
     * Preset to use when option used without option-argument, especially optional but also boolean and negated.
     * The custom processing (parseArg) is called.
     *
     * @example
     * new Option('--color').default('GREYSCALE').preset('RGB');
     * new Option('--donate [amount]').preset('20').argParser(parseFloat);
     *
     * @param {*} arg
     * @return {Option}
     */
    preset(e) {
      return this.presetArg = e, this;
    }
    /**
     * Add option name(s) that conflict with this option.
     * An error will be displayed if conflicting options are found during parsing.
     *
     * @example
     * new Option('--rgb').conflicts('cmyk');
     * new Option('--js').conflicts(['ts', 'jsx']);
     *
     * @param {(string | string[])} names
     * @return {Option}
     */
    conflicts(e) {
      return this.conflictsWith = this.conflictsWith.concat(e), this;
    }
    /**
     * Specify implied option values for when this option is set and the implied options are not.
     *
     * The custom processing (parseArg) is not called on the implied values.
     *
     * @example
     * program
     *   .addOption(new Option('--log', 'write logging information to file'))
     *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
     *
     * @param {object} impliedOptionValues
     * @return {Option}
     */
    implies(e) {
      let t = e;
      return typeof e == "string" && (t = { [e]: !0 }), this.implied = Object.assign(this.implied || {}, t), this;
    }
    /**
     * Set environment variable to check for option value.
     *
     * An environment variable is only used if when processed the current option value is
     * undefined, or the source of the current value is 'default' or 'config' or 'env'.
     *
     * @param {string} name
     * @return {Option}
     */
    env(e) {
      return this.envVar = e, this;
    }
    /**
     * Set the custom handler for processing CLI option arguments into option values.
     *
     * @param {Function} [fn]
     * @return {Option}
     */
    argParser(e) {
      return this.parseArg = e, this;
    }
    /**
     * Whether the option is mandatory and must have a value after parsing.
     *
     * @param {boolean} [mandatory=true]
     * @return {Option}
     */
    makeOptionMandatory(e = !0) {
      return this.mandatory = !!e, this;
    }
    /**
     * Hide option in help.
     *
     * @param {boolean} [hide=true]
     * @return {Option}
     */
    hideHelp(e = !0) {
      return this.hidden = !!e, this;
    }
    /**
     * @package
     */
    _concatValue(e, t) {
      return t === this.defaultValue || !Array.isArray(t) ? [e] : t.concat(e);
    }
    /**
     * Only allow option value to be one of choices.
     *
     * @param {string[]} values
     * @return {Option}
     */
    choices(e) {
      return this.argChoices = e.slice(), this.parseArg = (t, i) => {
        if (!this.argChoices.includes(t))
          throw new At(
            `Allowed choices are ${this.argChoices.join(", ")}.`
          );
        return this.variadic ? this._concatValue(t, i) : t;
      }, this;
    }
    /**
     * Return option name.
     *
     * @return {string}
     */
    name() {
      return this.long ? this.long.replace(/^--/, "") : this.short.replace(/^-/, "");
    }
    /**
     * Return option name, in a camelcase format that can be used
     * as a object attribute key.
     *
     * @return {string}
     */
    attributeName() {
      return vt(this.name().replace(/^no-/, ""));
    }
    /**
     * Check if `arg` matches the short or long flag.
     *
     * @param {string} arg
     * @return {boolean}
     * @package
     */
    is(e) {
      return this.short === e || this.long === e;
    }
    /**
     * Return whether a boolean option.
     *
     * Options are one of boolean, negated, required argument, or optional argument.
     *
     * @return {boolean}
     * @package
     */
    isBoolean() {
      return !this.required && !this.optional && !this.negate;
    }
  }, re = class {
    static {
      a(this, "DualOptions");
    }
    /**
     * @param {Option[]} options
     */
    constructor(e) {
      this.positiveOptions = /* @__PURE__ */ new Map(), this.negativeOptions = /* @__PURE__ */ new Map(), this.dualOptions = /* @__PURE__ */ new Set(),
      e.forEach((t) => {
        t.negate ? this.negativeOptions.set(t.attributeName(), t) : this.positiveOptions.set(t.attributeName(), t);
      }), this.negativeOptions.forEach((t, i) => {
        this.positiveOptions.has(i) && this.dualOptions.add(i);
      });
    }
    /**
     * Did the value come from the option, and not from possible matching dual option?
     *
     * @param {*} value
     * @param {Option} option
     * @returns {boolean}
     */
    valueFromOption(e, t) {
      let i = t.attributeName();
      if (!this.dualOptions.has(i)) return !0;
      let n = this.negativeOptions.get(i).presetArg, s = n !== void 0 ? n : !1;
      return t.negate === (s === e);
    }
  };
  function vt(r) {
    return r.split("-").reduce((e, t) => e + t[0].toUpperCase() + t.slice(1));
  }
  a(vt, "camelcase");
  function wt(r) {
    let e, t, i = r.split(/[ |,]+/);
    return i.length > 1 && !/^[[<]/.test(i[1]) && (e = i.shift()), t = i.shift(), !e && /^-[^-]$/.test(t) && (e = t, t = void 0), { shortFlag: e,
    longFlag: t };
  }
  a(wt, "splitOptionFlags");
  se.Option = ne;
  se.DualOptions = re;
});

// ../node_modules/commander/lib/suggestSimilar.js
var $e = A((Te) => {
  function Et(r, e) {
    if (Math.abs(r.length - e.length) > 3)
      return Math.max(r.length, e.length);
    let t = [];
    for (let i = 0; i <= r.length; i++)
      t[i] = [i];
    for (let i = 0; i <= e.length; i++)
      t[0][i] = i;
    for (let i = 1; i <= e.length; i++)
      for (let n = 1; n <= r.length; n++) {
        let s = 1;
        r[n - 1] === e[i - 1] ? s = 0 : s = 1, t[n][i] = Math.min(
          t[n - 1][i] + 1,
          // deletion
          t[n][i - 1] + 1,
          // insertion
          t[n - 1][i - 1] + s
          // substitution
        ), n > 1 && i > 1 && r[n - 1] === e[i - 2] && r[n - 2] === e[i - 1] && (t[n][i] = Math.min(t[n][i], t[n - 2][i - 2] + 1));
      }
    return t[r.length][e.length];
  }
  a(Et, "editDistance");
  function xt(r, e) {
    if (!e || e.length === 0) return "";
    e = Array.from(new Set(e));
    let t = r.startsWith("--");
    t && (r = r.slice(2), e = e.map((o) => o.slice(2)));
    let i = [], n = 3, s = 0.4;
    return e.forEach((o) => {
      if (o.length <= 1) return;
      let u = Et(r, o), l = Math.max(r.length, o.length);
      (l - u) / l > s && (u < n ? (n = u, i = [o]) : u === n && i.push(o));
    }), i.sort((o, u) => o.localeCompare(u)), t && (i = i.map((o) => `--${o}`)), i.length > 1 ? `
(Did you mean one of ${i.join(", ")}?)` : i.length === 1 ? `
(Did you mean ${i[0]}?)` : "";
  }
  a(xt, "suggestSimilar");
  Te.suggestSimilar = xt;
});

// ../node_modules/commander/lib/command.js
var He = A((Ie) => {
  var St = S("node:events").EventEmitter, ae = S("node:child_process"), v = S("node:path"), le = S("node:fs"), m = S("node:process"), { Argument: kt,
  humanReadableArgName: Tt } = B(), { CommanderError: ue } = P(), { Help: $t } = ie(), { Option: Ne, DualOptions: Nt } = oe(), { suggestSimilar: Ve } = $e(),
  ce = class r extends St {
    static {
      a(this, "Command");
    }
    /**
     * Initialize a new `Command`.
     *
     * @param {string} [name]
     */
    constructor(e) {
      super(), this.commands = [], this.options = [], this.parent = null, this._allowUnknownOption = !1, this._allowExcessArguments = !0, this.
      registeredArguments = [], this._args = this.registeredArguments, this.args = [], this.rawArgs = [], this.processedArgs = [], this._scriptPath =
      null, this._name = e || "", this._optionValues = {}, this._optionValueSources = {}, this._storeOptionsAsProperties = !1, this._actionHandler =
      null, this._executableHandler = !1, this._executableFile = null, this._executableDir = null, this._defaultCommandName = null, this._exitCallback =
      null, this._aliases = [], this._combineFlagAndOptionalValue = !0, this._description = "", this._summary = "", this._argsDescription = void 0,
      this._enablePositionalOptions = !1, this._passThroughOptions = !1, this._lifeCycleHooks = {}, this._showHelpAfterError = !1, this._showSuggestionAfterError =
      !0, this._outputConfiguration = {
        writeOut: /* @__PURE__ */ a((t) => m.stdout.write(t), "writeOut"),
        writeErr: /* @__PURE__ */ a((t) => m.stderr.write(t), "writeErr"),
        getOutHelpWidth: /* @__PURE__ */ a(() => m.stdout.isTTY ? m.stdout.columns : void 0, "getOutHelpWidth"),
        getErrHelpWidth: /* @__PURE__ */ a(() => m.stderr.isTTY ? m.stderr.columns : void 0, "getErrHelpWidth"),
        outputError: /* @__PURE__ */ a((t, i) => i(t), "outputError")
      }, this._hidden = !1, this._helpOption = void 0, this._addImplicitHelpCommand = void 0, this._helpCommand = void 0, this._helpConfiguration =
      {};
    }
    /**
     * Copy settings that are useful to have in common across root command and subcommands.
     *
     * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
     *
     * @param {Command} sourceCommand
     * @return {Command} `this` command for chaining
     */
    copyInheritedSettings(e) {
      return this._outputConfiguration = e._outputConfiguration, this._helpOption = e._helpOption, this._helpCommand = e._helpCommand, this.
      _helpConfiguration = e._helpConfiguration, this._exitCallback = e._exitCallback, this._storeOptionsAsProperties = e._storeOptionsAsProperties,
      this._combineFlagAndOptionalValue = e._combineFlagAndOptionalValue, this._allowExcessArguments = e._allowExcessArguments, this._enablePositionalOptions =
      e._enablePositionalOptions, this._showHelpAfterError = e._showHelpAfterError, this._showSuggestionAfterError = e._showSuggestionAfterError,
      this;
    }
    /**
     * @returns {Command[]}
     * @private
     */
    _getCommandAndAncestors() {
      let e = [];
      for (let t = this; t; t = t.parent)
        e.push(t);
      return e;
    }
    /**
     * Define a command.
     *
     * There are two styles of command: pay attention to where to put the description.
     *
     * @example
     * // Command implemented using action handler (description is supplied separately to `.command`)
     * program
     *   .command('clone <source> [destination]')
     *   .description('clone a repository into a newly created directory')
     *   .action((source, destination) => {
     *     console.log('clone command called');
     *   });
     *
     * // Command implemented using separate executable file (description is second parameter to `.command`)
     * program
     *   .command('start <service>', 'start named service')
     *   .command('stop [service]', 'stop named service, or all if no name supplied');
     *
     * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
     * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
     * @param {object} [execOpts] - configuration options (for executable)
     * @return {Command} returns new command for action handler, or `this` for executable command
     */
    command(e, t, i) {
      let n = t, s = i;
      typeof n == "object" && n !== null && (s = n, n = null), s = s || {};
      let [, o, u] = e.match(/([^ ]+) *(.*)/), l = this.createCommand(o);
      return n && (l.description(n), l._executableHandler = !0), s.isDefault && (this._defaultCommandName = l._name), l._hidden = !!(s.noHelp ||
      s.hidden), l._executableFile = s.executableFile || null, u && l.arguments(u), this._registerCommand(l), l.parent = this, l.copyInheritedSettings(
      this), n ? this : l;
    }
    /**
     * Factory routine to create a new unattached command.
     *
     * See .command() for creating an attached subcommand, which uses this routine to
     * create the command. You can override createCommand to customise subcommands.
     *
     * @param {string} [name]
     * @return {Command} new command
     */
    createCommand(e) {
      return new r(e);
    }
    /**
     * You can customise the help with a subclass of Help by overriding createHelp,
     * or by overriding Help properties using configureHelp().
     *
     * @return {Help}
     */
    createHelp() {
      return Object.assign(new $t(), this.configureHelp());
    }
    /**
     * You can customise the help by overriding Help properties using configureHelp(),
     * or with a subclass of Help by overriding createHelp().
     *
     * @param {object} [configuration] - configuration options
     * @return {(Command | object)} `this` command for chaining, or stored configuration
     */
    configureHelp(e) {
      return e === void 0 ? this._helpConfiguration : (this._helpConfiguration = e, this);
    }
    /**
     * The default output goes to stdout and stderr. You can customise this for special
     * applications. You can also customise the display of errors by overriding outputError.
     *
     * The configuration properties are all functions:
     *
     *     // functions to change where being written, stdout and stderr
     *     writeOut(str)
     *     writeErr(str)
     *     // matching functions to specify width for wrapping help
     *     getOutHelpWidth()
     *     getErrHelpWidth()
     *     // functions based on what is being written out
     *     outputError(str, write) // used for displaying errors, and not used for displaying help
     *
     * @param {object} [configuration] - configuration options
     * @return {(Command | object)} `this` command for chaining, or stored configuration
     */
    configureOutput(e) {
      return e === void 0 ? this._outputConfiguration : (Object.assign(this._outputConfiguration, e), this);
    }
    /**
     * Display the help or a custom message after an error occurs.
     *
     * @param {(boolean|string)} [displayHelp]
     * @return {Command} `this` command for chaining
     */
    showHelpAfterError(e = !0) {
      return typeof e != "string" && (e = !!e), this._showHelpAfterError = e, this;
    }
    /**
     * Display suggestion of similar commands for unknown commands, or options for unknown options.
     *
     * @param {boolean} [displaySuggestion]
     * @return {Command} `this` command for chaining
     */
    showSuggestionAfterError(e = !0) {
      return this._showSuggestionAfterError = !!e, this;
    }
    /**
     * Add a prepared subcommand.
     *
     * See .command() for creating an attached subcommand which inherits settings from its parent.
     *
     * @param {Command} cmd - new subcommand
     * @param {object} [opts] - configuration options
     * @return {Command} `this` command for chaining
     */
    addCommand(e, t) {
      if (!e._name)
        throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
      return t = t || {}, t.isDefault && (this._defaultCommandName = e._name), (t.noHelp || t.hidden) && (e._hidden = !0), this._registerCommand(
      e), e.parent = this, e._checkForBrokenPassThrough(), this;
    }
    /**
     * Factory routine to create a new unattached argument.
     *
     * See .argument() for creating an attached argument, which uses this routine to
     * create the argument. You can override createArgument to return a custom argument.
     *
     * @param {string} name
     * @param {string} [description]
     * @return {Argument} new argument
     */
    createArgument(e, t) {
      return new kt(e, t);
    }
    /**
     * Define argument syntax for command.
     *
     * The default is that the argument is required, and you can explicitly
     * indicate this with <> around the name. Put [] around the name for an optional argument.
     *
     * @example
     * program.argument('<input-file>');
     * program.argument('[output-file]');
     *
     * @param {string} name
     * @param {string} [description]
     * @param {(Function|*)} [fn] - custom argument processing function
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     */
    argument(e, t, i, n) {
      let s = this.createArgument(e, t);
      return typeof i == "function" ? s.default(n).argParser(i) : s.default(i), this.addArgument(s), this;
    }
    /**
     * Define argument syntax for command, adding multiple at once (without descriptions).
     *
     * See also .argument().
     *
     * @example
     * program.arguments('<cmd> [env]');
     *
     * @param {string} names
     * @return {Command} `this` command for chaining
     */
    arguments(e) {
      return e.trim().split(/ +/).forEach((t) => {
        this.argument(t);
      }), this;
    }
    /**
     * Define argument syntax for command, adding a prepared argument.
     *
     * @param {Argument} argument
     * @return {Command} `this` command for chaining
     */
    addArgument(e) {
      let t = this.registeredArguments.slice(-1)[0];
      if (t && t.variadic)
        throw new Error(
          `only the last argument can be variadic '${t.name()}'`
        );
      if (e.required && e.defaultValue !== void 0 && e.parseArg === void 0)
        throw new Error(
          `a default value for a required argument is never used: '${e.name()}'`
        );
      return this.registeredArguments.push(e), this;
    }
    /**
     * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
     *
     * @example
     *    program.helpCommand('help [cmd]');
     *    program.helpCommand('help [cmd]', 'show help');
     *    program.helpCommand(false); // suppress default help command
     *    program.helpCommand(true); // add help command even if no subcommands
     *
     * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
     * @param {string} [description] - custom description
     * @return {Command} `this` command for chaining
     */
    helpCommand(e, t) {
      if (typeof e == "boolean")
        return this._addImplicitHelpCommand = e, this;
      e = e ?? "help [command]";
      let [, i, n] = e.match(/([^ ]+) *(.*)/), s = t ?? "display help for command", o = this.createCommand(i);
      return o.helpOption(!1), n && o.arguments(n), s && o.description(s), this._addImplicitHelpCommand = !0, this._helpCommand = o, this;
    }
    /**
     * Add prepared custom help command.
     *
     * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
     * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
     * @return {Command} `this` command for chaining
     */
    addHelpCommand(e, t) {
      return typeof e != "object" ? (this.helpCommand(e, t), this) : (this._addImplicitHelpCommand = !0, this._helpCommand = e, this);
    }
    /**
     * Lazy create help command.
     *
     * @return {(Command|null)}
     * @package
     */
    _getHelpCommand() {
      return this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand("help")) ? (this._helpCommand ===
      void 0 && this.helpCommand(void 0, void 0), this._helpCommand) : null;
    }
    /**
     * Add hook for life cycle event.
     *
     * @param {string} event
     * @param {Function} listener
     * @return {Command} `this` command for chaining
     */
    hook(e, t) {
      let i = ["preSubcommand", "preAction", "postAction"];
      if (!i.includes(e))
        throw new Error(`Unexpected value for event passed to hook : '${e}'.
Expecting one of '${i.join("', '")}'`);
      return this._lifeCycleHooks[e] ? this._lifeCycleHooks[e].push(t) : this._lifeCycleHooks[e] = [t], this;
    }
    /**
     * Register callback to use as replacement for calling process.exit.
     *
     * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
     * @return {Command} `this` command for chaining
     */
    exitOverride(e) {
      return e ? this._exitCallback = e : this._exitCallback = (t) => {
        if (t.code !== "commander.executeSubCommandAsync")
          throw t;
      }, this;
    }
    /**
     * Call process.exit, and _exitCallback if defined.
     *
     * @param {number} exitCode exit code for using with process.exit
     * @param {string} code an id string representing the error
     * @param {string} message human-readable description of the error
     * @return never
     * @private
     */
    _exit(e, t, i) {
      this._exitCallback && this._exitCallback(new ue(e, t, i)), m.exit(e);
    }
    /**
     * Register callback `fn` for the command.
     *
     * @example
     * program
     *   .command('serve')
     *   .description('start service')
     *   .action(function() {
     *      // do work here
     *   });
     *
     * @param {Function} fn
     * @return {Command} `this` command for chaining
     */
    action(e) {
      let t = /* @__PURE__ */ a((i) => {
        let n = this.registeredArguments.length, s = i.slice(0, n);
        return this._storeOptionsAsProperties ? s[n] = this : s[n] = this.opts(), s.push(this), e.apply(this, s);
      }, "listener");
      return this._actionHandler = t, this;
    }
    /**
     * Factory routine to create a new unattached option.
     *
     * See .option() for creating an attached option, which uses this routine to
     * create the option. You can override createOption to return a custom option.
     *
     * @param {string} flags
     * @param {string} [description]
     * @return {Option} new option
     */
    createOption(e, t) {
      return new Ne(e, t);
    }
    /**
     * Wrap parseArgs to catch 'commander.invalidArgument'.
     *
     * @param {(Option | Argument)} target
     * @param {string} value
     * @param {*} previous
     * @param {string} invalidArgumentMessage
     * @private
     */
    _callParseArg(e, t, i, n) {
      try {
        return e.parseArg(t, i);
      } catch (s) {
        if (s.code === "commander.invalidArgument") {
          let o = `${n} ${s.message}`;
          this.error(o, { exitCode: s.exitCode, code: s.code });
        }
        throw s;
      }
    }
    /**
     * Check for option flag conflicts.
     * Register option if no conflicts found, or throw on conflict.
     *
     * @param {Option} option
     * @private
     */
    _registerOption(e) {
      let t = e.short && this._findOption(e.short) || e.long && this._findOption(e.long);
      if (t) {
        let i = e.long && this._findOption(e.long) ? e.long : e.short;
        throw new Error(`Cannot add option '${e.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${i}'
-  already used by option '${t.flags}'`);
      }
      this.options.push(e);
    }
    /**
     * Check for command name and alias conflicts with existing commands.
     * Register command if no conflicts found, or throw on conflict.
     *
     * @param {Command} command
     * @private
     */
    _registerCommand(e) {
      let t = /* @__PURE__ */ a((n) => [n.name()].concat(n.aliases()), "knownBy"), i = t(e).find(
        (n) => this._findCommand(n)
      );
      if (i) {
        let n = t(this._findCommand(i)).join("|"), s = t(e).join("|");
        throw new Error(
          `cannot add command '${s}' as already have command '${n}'`
        );
      }
      this.commands.push(e);
    }
    /**
     * Add an option.
     *
     * @param {Option} option
     * @return {Command} `this` command for chaining
     */
    addOption(e) {
      this._registerOption(e);
      let t = e.name(), i = e.attributeName();
      if (e.negate) {
        let s = e.long.replace(/^--no-/, "--");
        this._findOption(s) || this.setOptionValueWithSource(
          i,
          e.defaultValue === void 0 ? !0 : e.defaultValue,
          "default"
        );
      } else e.defaultValue !== void 0 && this.setOptionValueWithSource(i, e.defaultValue, "default");
      let n = /* @__PURE__ */ a((s, o, u) => {
        s == null && e.presetArg !== void 0 && (s = e.presetArg);
        let l = this.getOptionValue(i);
        s !== null && e.parseArg ? s = this._callParseArg(e, s, l, o) : s !== null && e.variadic && (s = e._concatValue(s, l)), s == null &&
        (e.negate ? s = !1 : e.isBoolean() || e.optional ? s = !0 : s = ""), this.setOptionValueWithSource(i, s, u);
      }, "handleOptionValue");
      return this.on("option:" + t, (s) => {
        let o = `error: option '${e.flags}' argument '${s}' is invalid.`;
        n(s, o, "cli");
      }), e.envVar && this.on("optionEnv:" + t, (s) => {
        let o = `error: option '${e.flags}' value '${s}' from env '${e.envVar}' is invalid.`;
        n(s, o, "env");
      }), this;
    }
    /**
     * Internal implementation shared by .option() and .requiredOption()
     *
     * @return {Command} `this` command for chaining
     * @private
     */
    _optionEx(e, t, i, n, s) {
      if (typeof t == "object" && t instanceof Ne)
        throw new Error(
          "To add an Option object use addOption() instead of option() or requiredOption()"
        );
      let o = this.createOption(t, i);
      if (o.makeOptionMandatory(!!e.mandatory), typeof n == "function")
        o.default(s).argParser(n);
      else if (n instanceof RegExp) {
        let u = n;
        n = /* @__PURE__ */ a((l, c) => {
          let h = u.exec(l);
          return h ? h[0] : c;
        }, "fn"), o.default(s).argParser(n);
      } else
        o.default(n);
      return this.addOption(o);
    }
    /**
     * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
     *
     * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
     * option-argument is indicated by `<>` and an optional option-argument by `[]`.
     *
     * See the README for more details, and see also addOption() and requiredOption().
     *
     * @example
     * program
     *     .option('-p, --pepper', 'add pepper')
     *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
     *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
     *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
     *
     * @param {string} flags
     * @param {string} [description]
     * @param {(Function|*)} [parseArg] - custom option processing function or default value
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     */
    option(e, t, i, n) {
      return this._optionEx({}, e, t, i, n);
    }
    /**
     * Add a required option which must have a value after parsing. This usually means
     * the option must be specified on the command line. (Otherwise the same as .option().)
     *
     * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
     *
     * @param {string} flags
     * @param {string} [description]
     * @param {(Function|*)} [parseArg] - custom option processing function or default value
     * @param {*} [defaultValue]
     * @return {Command} `this` command for chaining
     */
    requiredOption(e, t, i, n) {
      return this._optionEx(
        { mandatory: !0 },
        e,
        t,
        i,
        n
      );
    }
    /**
     * Alter parsing of short flags with optional values.
     *
     * @example
     * // for `.option('-f,--flag [value]'):
     * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
     * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
     *
     * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
     * @return {Command} `this` command for chaining
     */
    combineFlagAndOptionalValue(e = !0) {
      return this._combineFlagAndOptionalValue = !!e, this;
    }
    /**
     * Allow unknown options on the command line.
     *
     * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
     * @return {Command} `this` command for chaining
     */
    allowUnknownOption(e = !0) {
      return this._allowUnknownOption = !!e, this;
    }
    /**
     * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
     *
     * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
     * @return {Command} `this` command for chaining
     */
    allowExcessArguments(e = !0) {
      return this._allowExcessArguments = !!e, this;
    }
    /**
     * Enable positional options. Positional means global options are specified before subcommands which lets
     * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
     * The default behaviour is non-positional and global options may appear anywhere on the command line.
     *
     * @param {boolean} [positional]
     * @return {Command} `this` command for chaining
     */
    enablePositionalOptions(e = !0) {
      return this._enablePositionalOptions = !!e, this;
    }
    /**
     * Pass through options that come after command-arguments rather than treat them as command-options,
     * so actual command-options come before command-arguments. Turning this on for a subcommand requires
     * positional options to have been enabled on the program (parent commands).
     * The default behaviour is non-positional and options may appear before or after command-arguments.
     *
     * @param {boolean} [passThrough] for unknown options.
     * @return {Command} `this` command for chaining
     */
    passThroughOptions(e = !0) {
      return this._passThroughOptions = !!e, this._checkForBrokenPassThrough(), this;
    }
    /**
     * @private
     */
    _checkForBrokenPassThrough() {
      if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions)
        throw new Error(
          `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`
        );
    }
    /**
     * Whether to store option values as properties on command object,
     * or store separately (specify false). In both cases the option values can be accessed using .opts().
     *
     * @param {boolean} [storeAsProperties=true]
     * @return {Command} `this` command for chaining
     */
    storeOptionsAsProperties(e = !0) {
      if (this.options.length)
        throw new Error("call .storeOptionsAsProperties() before adding options");
      if (Object.keys(this._optionValues).length)
        throw new Error(
          "call .storeOptionsAsProperties() before setting option values"
        );
      return this._storeOptionsAsProperties = !!e, this;
    }
    /**
     * Retrieve option value.
     *
     * @param {string} key
     * @return {object} value
     */
    getOptionValue(e) {
      return this._storeOptionsAsProperties ? this[e] : this._optionValues[e];
    }
    /**
     * Store option value.
     *
     * @param {string} key
     * @param {object} value
     * @return {Command} `this` command for chaining
     */
    setOptionValue(e, t) {
      return this.setOptionValueWithSource(e, t, void 0);
    }
    /**
     * Store option value and where the value came from.
     *
     * @param {string} key
     * @param {object} value
     * @param {string} source - expected values are default/config/env/cli/implied
     * @return {Command} `this` command for chaining
     */
    setOptionValueWithSource(e, t, i) {
      return this._storeOptionsAsProperties ? this[e] = t : this._optionValues[e] = t, this._optionValueSources[e] = i, this;
    }
    /**
     * Get source of option value.
     * Expected values are default | config | env | cli | implied
     *
     * @param {string} key
     * @return {string}
     */
    getOptionValueSource(e) {
      return this._optionValueSources[e];
    }
    /**
     * Get source of option value. See also .optsWithGlobals().
     * Expected values are default | config | env | cli | implied
     *
     * @param {string} key
     * @return {string}
     */
    getOptionValueSourceWithGlobals(e) {
      let t;
      return this._getCommandAndAncestors().forEach((i) => {
        i.getOptionValueSource(e) !== void 0 && (t = i.getOptionValueSource(e));
      }), t;
    }
    /**
     * Get user arguments from implied or explicit arguments.
     * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
     *
     * @private
     */
    _prepareUserArgs(e, t) {
      if (e !== void 0 && !Array.isArray(e))
        throw new Error("first parameter to parse must be array or undefined");
      if (t = t || {}, e === void 0 && t.from === void 0) {
        m.versions?.electron && (t.from = "electron");
        let n = m.execArgv ?? [];
        (n.includes("-e") || n.includes("--eval") || n.includes("-p") || n.includes("--print")) && (t.from = "eval");
      }
      e === void 0 && (e = m.argv), this.rawArgs = e.slice();
      let i;
      switch (t.from) {
        case void 0:
        case "node":
          this._scriptPath = e[1], i = e.slice(2);
          break;
        case "electron":
          m.defaultApp ? (this._scriptPath = e[1], i = e.slice(2)) : i = e.slice(1);
          break;
        case "user":
          i = e.slice(0);
          break;
        case "eval":
          i = e.slice(1);
          break;
        default:
          throw new Error(
            `unexpected parse option { from: '${t.from}' }`
          );
      }
      return !this._name && this._scriptPath && this.nameFromFilename(this._scriptPath), this._name = this._name || "program", i;
    }
    /**
     * Parse `argv`, setting options and invoking commands when defined.
     *
     * Use parseAsync instead of parse if any of your action handlers are async.
     *
     * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
     *
     * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
     * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
     * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
     * - `'user'`: just user arguments
     *
     * @example
     * program.parse(); // parse process.argv and auto-detect electron and special node flags
     * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
     * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv] - optional, defaults to process.argv
     * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
     * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
     * @return {Command} `this` command for chaining
     */
    parse(e, t) {
      let i = this._prepareUserArgs(e, t);
      return this._parseCommand([], i), this;
    }
    /**
     * Parse `argv`, setting options and invoking commands when defined.
     *
     * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
     *
     * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
     * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
     * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
     * - `'user'`: just user arguments
     *
     * @example
     * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
     * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
     * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
     *
     * @param {string[]} [argv]
     * @param {object} [parseOptions]
     * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
     * @return {Promise}
     */
    async parseAsync(e, t) {
      let i = this._prepareUserArgs(e, t);
      return await this._parseCommand([], i), this;
    }
    /**
     * Execute a sub-command executable.
     *
     * @private
     */
    _executeSubCommand(e, t) {
      t = t.slice();
      let i = !1, n = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
      function s(h, p) {
        let g = v.resolve(h, p);
        if (le.existsSync(g)) return g;
        if (n.includes(v.extname(p))) return;
        let y = n.find(
          (_) => le.existsSync(`${g}${_}`)
        );
        if (y) return `${g}${y}`;
      }
      a(s, "findFile"), this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
      let o = e._executableFile || `${this._name}-${e._name}`, u = this._executableDir || "";
      if (this._scriptPath) {
        let h;
        try {
          h = le.realpathSync(this._scriptPath);
        } catch {
          h = this._scriptPath;
        }
        u = v.resolve(
          v.dirname(h),
          u
        );
      }
      if (u) {
        let h = s(u, o);
        if (!h && !e._executableFile && this._scriptPath) {
          let p = v.basename(
            this._scriptPath,
            v.extname(this._scriptPath)
          );
          p !== this._name && (h = s(
            u,
            `${p}-${e._name}`
          ));
        }
        o = h || o;
      }
      i = n.includes(v.extname(o));
      let l;
      m.platform !== "win32" ? i ? (t.unshift(o), t = Pe(m.execArgv).concat(t), l = ae.spawn(m.argv[0], t, { stdio: "inherit" })) : l = ae.spawn(
      o, t, { stdio: "inherit" }) : (t.unshift(o), t = Pe(m.execArgv).concat(t), l = ae.spawn(m.execPath, t, { stdio: "inherit" })), l.killed ||
      ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"].forEach((p) => {
        m.on(p, () => {
          l.killed === !1 && l.exitCode === null && l.kill(p);
        });
      });
      let c = this._exitCallback;
      l.on("close", (h) => {
        h = h ?? 1, c ? c(
          new ue(
            h,
            "commander.executeSubCommandAsync",
            "(close)"
          )
        ) : m.exit(h);
      }), l.on("error", (h) => {
        if (h.code === "ENOENT") {
          let p = u ? `searched for local subcommand relative to directory '${u}'` : "no directory for search for local subcommand, use .exe\
cutableDir() to supply a custom directory", g = `'${o}' does not exist
 - if '${e._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\

 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${p}`;
          throw new Error(g);
        } else if (h.code === "EACCES")
          throw new Error(`'${o}' not executable`);
        if (!c)
          m.exit(1);
        else {
          let p = new ue(
            1,
            "commander.executeSubCommandAsync",
            "(error)"
          );
          p.nestedError = h, c(p);
        }
      }), this.runningCommand = l;
    }
    /**
     * @private
     */
    _dispatchSubcommand(e, t, i) {
      let n = this._findCommand(e);
      n || this.help({ error: !0 });
      let s;
      return s = this._chainOrCallSubCommandHook(
        s,
        n,
        "preSubcommand"
      ), s = this._chainOrCall(s, () => {
        if (n._executableHandler)
          this._executeSubCommand(n, t.concat(i));
        else
          return n._parseCommand(t, i);
      }), s;
    }
    /**
     * Invoke help directly if possible, or dispatch if necessary.
     * e.g. help foo
     *
     * @private
     */
    _dispatchHelpCommand(e) {
      e || this.help();
      let t = this._findCommand(e);
      return t && !t._executableHandler && t.help(), this._dispatchSubcommand(
        e,
        [],
        [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? "--help"]
      );
    }
    /**
     * Check this.args against expected this.registeredArguments.
     *
     * @private
     */
    _checkNumberOfArguments() {
      this.registeredArguments.forEach((e, t) => {
        e.required && this.args[t] == null && this.missingArgument(e.name());
      }), !(this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) && this.args.length >
      this.registeredArguments.length && this._excessArguments(this.args);
    }
    /**
     * Process this.args using this.registeredArguments and save as this.processedArgs!
     *
     * @private
     */
    _processArguments() {
      let e = /* @__PURE__ */ a((i, n, s) => {
        let o = n;
        if (n !== null && i.parseArg) {
          let u = `error: command-argument value '${n}' is invalid for argument '${i.name()}'.`;
          o = this._callParseArg(
            i,
            n,
            s,
            u
          );
        }
        return o;
      }, "myParseArg");
      this._checkNumberOfArguments();
      let t = [];
      this.registeredArguments.forEach((i, n) => {
        let s = i.defaultValue;
        i.variadic ? n < this.args.length ? (s = this.args.slice(n), i.parseArg && (s = s.reduce((o, u) => e(i, u, o), i.defaultValue))) : s ===
        void 0 && (s = []) : n < this.args.length && (s = this.args[n], i.parseArg && (s = e(i, s, i.defaultValue))), t[n] = s;
      }), this.processedArgs = t;
    }
    /**
     * Once we have a promise we chain, but call synchronously until then.
     *
     * @param {(Promise|undefined)} promise
     * @param {Function} fn
     * @return {(Promise|undefined)}
     * @private
     */
    _chainOrCall(e, t) {
      return e && e.then && typeof e.then == "function" ? e.then(() => t()) : t();
    }
    /**
     *
     * @param {(Promise|undefined)} promise
     * @param {string} event
     * @return {(Promise|undefined)}
     * @private
     */
    _chainOrCallHooks(e, t) {
      let i = e, n = [];
      return this._getCommandAndAncestors().reverse().filter((s) => s._lifeCycleHooks[t] !== void 0).forEach((s) => {
        s._lifeCycleHooks[t].forEach((o) => {
          n.push({ hookedCommand: s, callback: o });
        });
      }), t === "postAction" && n.reverse(), n.forEach((s) => {
        i = this._chainOrCall(i, () => s.callback(s.hookedCommand, this));
      }), i;
    }
    /**
     *
     * @param {(Promise|undefined)} promise
     * @param {Command} subCommand
     * @param {string} event
     * @return {(Promise|undefined)}
     * @private
     */
    _chainOrCallSubCommandHook(e, t, i) {
      let n = e;
      return this._lifeCycleHooks[i] !== void 0 && this._lifeCycleHooks[i].forEach((s) => {
        n = this._chainOrCall(n, () => s(this, t));
      }), n;
    }
    /**
     * Process arguments in context of this command.
     * Returns action result, in case it is a promise.
     *
     * @private
     */
    _parseCommand(e, t) {
      let i = this.parseOptions(t);
      if (this._parseOptionsEnv(), this._parseOptionsImplied(), e = e.concat(i.operands), t = i.unknown, this.args = e.concat(t), e && this.
      _findCommand(e[0]))
        return this._dispatchSubcommand(e[0], e.slice(1), t);
      if (this._getHelpCommand() && e[0] === this._getHelpCommand().name())
        return this._dispatchHelpCommand(e[1]);
      if (this._defaultCommandName)
        return this._outputHelpIfRequested(t), this._dispatchSubcommand(
          this._defaultCommandName,
          e,
          t
        );
      this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName && this.help({ error: !0 }), this.
      _outputHelpIfRequested(i.unknown), this._checkForMissingMandatoryOptions(), this._checkForConflictingOptions();
      let n = /* @__PURE__ */ a(() => {
        i.unknown.length > 0 && this.unknownOption(i.unknown[0]);
      }, "checkForUnknownOptions"), s = `command:${this.name()}`;
      if (this._actionHandler) {
        n(), this._processArguments();
        let o;
        return o = this._chainOrCallHooks(o, "preAction"), o = this._chainOrCall(
          o,
          () => this._actionHandler(this.processedArgs)
        ), this.parent && (o = this._chainOrCall(o, () => {
          this.parent.emit(s, e, t);
        })), o = this._chainOrCallHooks(o, "postAction"), o;
      }
      if (this.parent && this.parent.listenerCount(s))
        n(), this._processArguments(), this.parent.emit(s, e, t);
      else if (e.length) {
        if (this._findCommand("*"))
          return this._dispatchSubcommand("*", e, t);
        this.listenerCount("command:*") ? this.emit("command:*", e, t) : this.commands.length ? this.unknownCommand() : (n(), this._processArguments());
      } else this.commands.length ? (n(), this.help({ error: !0 })) : (n(), this._processArguments());
    }
    /**
     * Find matching command.
     *
     * @private
     * @return {Command | undefined}
     */
    _findCommand(e) {
      if (e)
        return this.commands.find(
          (t) => t._name === e || t._aliases.includes(e)
        );
    }
    /**
     * Return an option matching `arg` if any.
     *
     * @param {string} arg
     * @return {Option}
     * @package
     */
    _findOption(e) {
      return this.options.find((t) => t.is(e));
    }
    /**
     * Display an error message if a mandatory option does not have a value.
     * Called after checking for help flags in leaf subcommand.
     *
     * @private
     */
    _checkForMissingMandatoryOptions() {
      this._getCommandAndAncestors().forEach((e) => {
        e.options.forEach((t) => {
          t.mandatory && e.getOptionValue(t.attributeName()) === void 0 && e.missingMandatoryOptionValue(t);
        });
      });
    }
    /**
     * Display an error message if conflicting options are used together in this.
     *
     * @private
     */
    _checkForConflictingLocalOptions() {
      let e = this.options.filter((i) => {
        let n = i.attributeName();
        return this.getOptionValue(n) === void 0 ? !1 : this.getOptionValueSource(n) !== "default";
      });
      e.filter(
        (i) => i.conflictsWith.length > 0
      ).forEach((i) => {
        let n = e.find(
          (s) => i.conflictsWith.includes(s.attributeName())
        );
        n && this._conflictingOption(i, n);
      });
    }
    /**
     * Display an error message if conflicting options are used together.
     * Called after checking for help flags in leaf subcommand.
     *
     * @private
     */
    _checkForConflictingOptions() {
      this._getCommandAndAncestors().forEach((e) => {
        e._checkForConflictingLocalOptions();
      });
    }
    /**
     * Parse options from `argv` removing known options,
     * and return argv split into operands and unknown arguments.
     *
     * Examples:
     *
     *     argv => operands, unknown
     *     --known kkk op => [op], []
     *     op --known kkk => [op], []
     *     sub --unknown uuu op => [sub], [--unknown uuu op]
     *     sub -- --unknown uuu op => [sub --unknown uuu op], []
     *
     * @param {string[]} argv
     * @return {{operands: string[], unknown: string[]}}
     */
    parseOptions(e) {
      let t = [], i = [], n = t, s = e.slice();
      function o(l) {
        return l.length > 1 && l[0] === "-";
      }
      a(o, "maybeOption");
      let u = null;
      for (; s.length; ) {
        let l = s.shift();
        if (l === "--") {
          n === i && n.push(l), n.push(...s);
          break;
        }
        if (u && !o(l)) {
          this.emit(`option:${u.name()}`, l);
          continue;
        }
        if (u = null, o(l)) {
          let c = this._findOption(l);
          if (c) {
            if (c.required) {
              let h = s.shift();
              h === void 0 && this.optionMissingArgument(c), this.emit(`option:${c.name()}`, h);
            } else if (c.optional) {
              let h = null;
              s.length > 0 && !o(s[0]) && (h = s.shift()), this.emit(`option:${c.name()}`, h);
            } else
              this.emit(`option:${c.name()}`);
            u = c.variadic ? c : null;
            continue;
          }
        }
        if (l.length > 2 && l[0] === "-" && l[1] !== "-") {
          let c = this._findOption(`-${l[1]}`);
          if (c) {
            c.required || c.optional && this._combineFlagAndOptionalValue ? this.emit(`option:${c.name()}`, l.slice(2)) : (this.emit(`option\
:${c.name()}`), s.unshift(`-${l.slice(2)}`));
            continue;
          }
        }
        if (/^--[^=]+=/.test(l)) {
          let c = l.indexOf("="), h = this._findOption(l.slice(0, c));
          if (h && (h.required || h.optional)) {
            this.emit(`option:${h.name()}`, l.slice(c + 1));
            continue;
          }
        }
        if (o(l) && (n = i), (this._enablePositionalOptions || this._passThroughOptions) && t.length === 0 && i.length === 0) {
          if (this._findCommand(l)) {
            t.push(l), s.length > 0 && i.push(...s);
            break;
          } else if (this._getHelpCommand() && l === this._getHelpCommand().name()) {
            t.push(l), s.length > 0 && t.push(...s);
            break;
          } else if (this._defaultCommandName) {
            i.push(l), s.length > 0 && i.push(...s);
            break;
          }
        }
        if (this._passThroughOptions) {
          n.push(l), s.length > 0 && n.push(...s);
          break;
        }
        n.push(l);
      }
      return { operands: t, unknown: i };
    }
    /**
     * Return an object containing local option values as key-value pairs.
     *
     * @return {object}
     */
    opts() {
      if (this._storeOptionsAsProperties) {
        let e = {}, t = this.options.length;
        for (let i = 0; i < t; i++) {
          let n = this.options[i].attributeName();
          e[n] = n === this._versionOptionName ? this._version : this[n];
        }
        return e;
      }
      return this._optionValues;
    }
    /**
     * Return an object containing merged local and global option values as key-value pairs.
     *
     * @return {object}
     */
    optsWithGlobals() {
      return this._getCommandAndAncestors().reduce(
        (e, t) => Object.assign(e, t.opts()),
        {}
      );
    }
    /**
     * Display error message and exit (or call exitOverride).
     *
     * @param {string} message
     * @param {object} [errorOptions]
     * @param {string} [errorOptions.code] - an id string representing the error
     * @param {number} [errorOptions.exitCode] - used with process.exit
     */
    error(e, t) {
      this._outputConfiguration.outputError(
        `${e}
`,
        this._outputConfiguration.writeErr
      ), typeof this._showHelpAfterError == "string" ? this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`) : this._showHelpAfterError && (this._outputConfiguration.writeErr(`
`), this.outputHelp({ error: !0 }));
      let i = t || {}, n = i.exitCode || 1, s = i.code || "commander.error";
      this._exit(n, s, e);
    }
    /**
     * Apply any option related environment variables, if option does
     * not have a value from cli or client code.
     *
     * @private
     */
    _parseOptionsEnv() {
      this.options.forEach((e) => {
        if (e.envVar && e.envVar in m.env) {
          let t = e.attributeName();
          (this.getOptionValue(t) === void 0 || ["default", "config", "env"].includes(
            this.getOptionValueSource(t)
          )) && (e.required || e.optional ? this.emit(`optionEnv:${e.name()}`, m.env[e.envVar]) : this.emit(`optionEnv:${e.name()}`));
        }
      });
    }
    /**
     * Apply any implied option values, if option is undefined or default value.
     *
     * @private
     */
    _parseOptionsImplied() {
      let e = new Nt(this.options), t = /* @__PURE__ */ a((i) => this.getOptionValue(i) !== void 0 && !["default", "implied"].includes(this.
      getOptionValueSource(i)), "hasCustomOptionValue");
      this.options.filter(
        (i) => i.implied !== void 0 && t(i.attributeName()) && e.valueFromOption(
          this.getOptionValue(i.attributeName()),
          i
        )
      ).forEach((i) => {
        Object.keys(i.implied).filter((n) => !t(n)).forEach((n) => {
          this.setOptionValueWithSource(
            n,
            i.implied[n],
            "implied"
          );
        });
      });
    }
    /**
     * Argument `name` is missing.
     *
     * @param {string} name
     * @private
     */
    missingArgument(e) {
      let t = `error: missing required argument '${e}'`;
      this.error(t, { code: "commander.missingArgument" });
    }
    /**
     * `Option` is missing an argument.
     *
     * @param {Option} option
     * @private
     */
    optionMissingArgument(e) {
      let t = `error: option '${e.flags}' argument missing`;
      this.error(t, { code: "commander.optionMissingArgument" });
    }
    /**
     * `Option` does not have a value, and is a mandatory option.
     *
     * @param {Option} option
     * @private
     */
    missingMandatoryOptionValue(e) {
      let t = `error: required option '${e.flags}' not specified`;
      this.error(t, { code: "commander.missingMandatoryOptionValue" });
    }
    /**
     * `Option` conflicts with another option.
     *
     * @param {Option} option
     * @param {Option} conflictingOption
     * @private
     */
    _conflictingOption(e, t) {
      let i = /* @__PURE__ */ a((o) => {
        let u = o.attributeName(), l = this.getOptionValue(u), c = this.options.find(
          (p) => p.negate && u === p.attributeName()
        ), h = this.options.find(
          (p) => !p.negate && u === p.attributeName()
        );
        return c && (c.presetArg === void 0 && l === !1 || c.presetArg !== void 0 && l === c.presetArg) ? c : h || o;
      }, "findBestOptionFromValue"), n = /* @__PURE__ */ a((o) => {
        let u = i(o), l = u.attributeName();
        return this.getOptionValueSource(l) === "env" ? `environment variable '${u.envVar}'` : `option '${u.flags}'`;
      }, "getErrorMessage"), s = `error: ${n(e)} cannot be used with ${n(t)}`;
      this.error(s, { code: "commander.conflictingOption" });
    }
    /**
     * Unknown option `flag`.
     *
     * @param {string} flag
     * @private
     */
    unknownOption(e) {
      if (this._allowUnknownOption) return;
      let t = "";
      if (e.startsWith("--") && this._showSuggestionAfterError) {
        let n = [], s = this;
        do {
          let o = s.createHelp().visibleOptions(s).filter((u) => u.long).map((u) => u.long);
          n = n.concat(o), s = s.parent;
        } while (s && !s._enablePositionalOptions);
        t = Ve(e, n);
      }
      let i = `error: unknown option '${e}'${t}`;
      this.error(i, { code: "commander.unknownOption" });
    }
    /**
     * Excess arguments, more than expected.
     *
     * @param {string[]} receivedArgs
     * @private
     */
    _excessArguments(e) {
      if (this._allowExcessArguments) return;
      let t = this.registeredArguments.length, i = t === 1 ? "" : "s", s = `error: too many arguments${this.parent ? ` for '${this.name()}'` :
      ""}. Expected ${t} argument${i} but got ${e.length}.`;
      this.error(s, { code: "commander.excessArguments" });
    }
    /**
     * Unknown command.
     *
     * @private
     */
    unknownCommand() {
      let e = this.args[0], t = "";
      if (this._showSuggestionAfterError) {
        let n = [];
        this.createHelp().visibleCommands(this).forEach((s) => {
          n.push(s.name()), s.alias() && n.push(s.alias());
        }), t = Ve(e, n);
      }
      let i = `error: unknown command '${e}'${t}`;
      this.error(i, { code: "commander.unknownCommand" });
    }
    /**
     * Get or set the program version.
     *
     * This method auto-registers the "-V, --version" option which will print the version number.
     *
     * You can optionally supply the flags and description to override the defaults.
     *
     * @param {string} [str]
     * @param {string} [flags]
     * @param {string} [description]
     * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
     */
    version(e, t, i) {
      if (e === void 0) return this._version;
      this._version = e, t = t || "-V, --version", i = i || "output the version number";
      let n = this.createOption(t, i);
      return this._versionOptionName = n.attributeName(), this._registerOption(n), this.on("option:" + n.name(), () => {
        this._outputConfiguration.writeOut(`${e}
`), this._exit(0, "commander.version", e);
      }), this;
    }
    /**
     * Set the description.
     *
     * @param {string} [str]
     * @param {object} [argsDescription]
     * @return {(string|Command)}
     */
    description(e, t) {
      return e === void 0 && t === void 0 ? this._description : (this._description = e, t && (this._argsDescription = t), this);
    }
    /**
     * Set the summary. Used when listed as subcommand of parent.
     *
     * @param {string} [str]
     * @return {(string|Command)}
     */
    summary(e) {
      return e === void 0 ? this._summary : (this._summary = e, this);
    }
    /**
     * Set an alias for the command.
     *
     * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
     *
     * @param {string} [alias]
     * @return {(string|Command)}
     */
    alias(e) {
      if (e === void 0) return this._aliases[0];
      let t = this;
      if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler && (t = this.commands[this.commands.length -
      1]), e === t._name)
        throw new Error("Command alias can't be the same as its name");
      let i = this.parent?._findCommand(e);
      if (i) {
        let n = [i.name()].concat(i.aliases()).join("|");
        throw new Error(
          `cannot add alias '${e}' to command '${this.name()}' as already have command '${n}'`
        );
      }
      return t._aliases.push(e), this;
    }
    /**
     * Set aliases for the command.
     *
     * Only the first alias is shown in the auto-generated help.
     *
     * @param {string[]} [aliases]
     * @return {(string[]|Command)}
     */
    aliases(e) {
      return e === void 0 ? this._aliases : (e.forEach((t) => this.alias(t)), this);
    }
    /**
     * Set / get the command usage `str`.
     *
     * @param {string} [str]
     * @return {(string|Command)}
     */
    usage(e) {
      if (e === void 0) {
        if (this._usage) return this._usage;
        let t = this.registeredArguments.map((i) => Tt(i));
        return [].concat(
          this.options.length || this._helpOption !== null ? "[options]" : [],
          this.commands.length ? "[command]" : [],
          this.registeredArguments.length ? t : []
        ).join(" ");
      }
      return this._usage = e, this;
    }
    /**
     * Get or set the name of the command.
     *
     * @param {string} [str]
     * @return {(string|Command)}
     */
    name(e) {
      return e === void 0 ? this._name : (this._name = e, this);
    }
    /**
     * Set the name of the command from script filename, such as process.argv[1],
     * or require.main.filename, or __filename.
     *
     * (Used internally and public although not documented in README.)
     *
     * @example
     * program.nameFromFilename(require.main.filename);
     *
     * @param {string} filename
     * @return {Command}
     */
    nameFromFilename(e) {
      return this._name = v.basename(e, v.extname(e)), this;
    }
    /**
     * Get or set the directory for searching for executable subcommands of this command.
     *
     * @example
     * program.executableDir(__dirname);
     * // or
     * program.executableDir('subcommands');
     *
     * @param {string} [path]
     * @return {(string|null|Command)}
     */
    executableDir(e) {
      return e === void 0 ? this._executableDir : (this._executableDir = e, this);
    }
    /**
     * Return program help documentation.
     *
     * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
     * @return {string}
     */
    helpInformation(e) {
      let t = this.createHelp();
      return t.helpWidth === void 0 && (t.helpWidth = e && e.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.
      getOutHelpWidth()), t.formatHelp(this, t);
    }
    /**
     * @private
     */
    _getHelpContext(e) {
      e = e || {};
      let t = { error: !!e.error }, i;
      return t.error ? i = /* @__PURE__ */ a((n) => this._outputConfiguration.writeErr(n), "write") : i = /* @__PURE__ */ a((n) => this._outputConfiguration.
      writeOut(n), "write"), t.write = e.write || i, t.command = this, t;
    }
    /**
     * Output help information for this command.
     *
     * Outputs built-in help, and custom text added using `.addHelpText()`.
     *
     * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
     */
    outputHelp(e) {
      let t;
      typeof e == "function" && (t = e, e = void 0);
      let i = this._getHelpContext(e);
      this._getCommandAndAncestors().reverse().forEach((s) => s.emit("beforeAllHelp", i)), this.emit("beforeHelp", i);
      let n = this.helpInformation(i);
      if (t && (n = t(n), typeof n != "string" && !Buffer.isBuffer(n)))
        throw new Error("outputHelp callback must return a string or a Buffer");
      i.write(n), this._getHelpOption()?.long && this.emit(this._getHelpOption().long), this.emit("afterHelp", i), this._getCommandAndAncestors().
      forEach(
        (s) => s.emit("afterAllHelp", i)
      );
    }
    /**
     * You can pass in flags and a description to customise the built-in help option.
     * Pass in false to disable the built-in help option.
     *
     * @example
     * program.helpOption('-?, --help' 'show help'); // customise
     * program.helpOption(false); // disable
     *
     * @param {(string | boolean)} flags
     * @param {string} [description]
     * @return {Command} `this` command for chaining
     */
    helpOption(e, t) {
      return typeof e == "boolean" ? (e ? this._helpOption = this._helpOption ?? void 0 : this._helpOption = null, this) : (e = e ?? "-h, --\
help", t = t ?? "display help for command", this._helpOption = this.createOption(e, t), this);
    }
    /**
     * Lazy create help option.
     * Returns null if has been disabled with .helpOption(false).
     *
     * @returns {(Option | null)} the help option
     * @package
     */
    _getHelpOption() {
      return this._helpOption === void 0 && this.helpOption(void 0, void 0), this._helpOption;
    }
    /**
     * Supply your own option to use for the built-in help option.
     * This is an alternative to using helpOption() to customise the flags and description etc.
     *
     * @param {Option} option
     * @return {Command} `this` command for chaining
     */
    addHelpOption(e) {
      return this._helpOption = e, this;
    }
    /**
     * Output help information and exit.
     *
     * Outputs built-in help, and custom text added using `.addHelpText()`.
     *
     * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
     */
    help(e) {
      this.outputHelp(e);
      let t = m.exitCode || 0;
      t === 0 && e && typeof e != "function" && e.error && (t = 1), this._exit(t, "commander.help", "(outputHelp)");
    }
    /**
     * Add additional text to be displayed with the built-in help.
     *
     * Position is 'before' or 'after' to affect just this command,
     * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
     *
     * @param {string} position - before or after built-in help
     * @param {(string | Function)} text - string to add, or a function returning a string
     * @return {Command} `this` command for chaining
     */
    addHelpText(e, t) {
      let i = ["beforeAll", "before", "after", "afterAll"];
      if (!i.includes(e))
        throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${i.join("', '")}'`);
      let n = `${e}Help`;
      return this.on(n, (s) => {
        let o;
        typeof t == "function" ? o = t({ error: s.error, command: s.command }) : o = t, o && s.write(`${o}
`);
      }), this;
    }
    /**
     * Output help information if help flags specified
     *
     * @param {Array} args - array of options to search for help flags
     * @private
     */
    _outputHelpIfRequested(e) {
      let t = this._getHelpOption();
      t && e.find((n) => t.is(n)) && (this.outputHelp(), this._exit(0, "commander.helpDisplayed", "(outputHelp)"));
    }
  };
  function Pe(r) {
    return r.map((e) => {
      if (!e.startsWith("--inspect"))
        return e;
      let t, i = "127.0.0.1", n = "9229", s;
      return (s = e.match(/^(--inspect(-brk)?)$/)) !== null ? t = s[1] : (s = e.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null ? (t =
      s[1], /^\d+$/.test(s[3]) ? n = s[3] : i = s[3]) : (s = e.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null && (t = s[1], i =
      s[3], n = s[4]), t && n !== "0" ? `${t}=${i}:${parseInt(n) + 1}` : e;
    });
  }
  a(Pe, "incrementNodeInspectorPort");
  Ie.Command = ce;
});

// ../node_modules/commander/index.js
var Me = A((O) => {
  var { Argument: Fe } = B(), { Command: he } = He(), { CommanderError: Vt, InvalidArgumentError: De } = P(), { Help: Pt } = ie(), { Option: Re } = oe();
  O.program = new he();
  O.createCommand = (r) => new he(r);
  O.createOption = (r, e) => new Re(r, e);
  O.createArgument = (r, e) => new Fe(r, e);
  O.Command = he;
  O.Option = Re;
  O.Argument = Fe;
  O.Help = Pt;
  O.CommanderError = Vt;
  O.InvalidArgumentError = De;
  O.InvalidOptionArgumentError = De;
});

// ../node_modules/walk-up-path/dist/cjs/index.js
var je = A((j) => {
  "use strict";
  Object.defineProperty(j, "__esModule", { value: !0 });
  j.walkUp = void 0;
  var Be = S("path"), It = /* @__PURE__ */ a(function* (r) {
    for (r = (0, Be.resolve)(r); r; ) {
      yield r;
      let e = (0, Be.dirname)(r);
      if (e === r)
        break;
      r = e;
    }
  }, "walkUp");
  j.walkUp = It;
});

// ../node_modules/ts-dedent/dist/index.js
var Ye = A((I) => {
  "use strict";
  Object.defineProperty(I, "__esModule", { value: !0 });
  I.dedent = void 0;
  function Ue(r) {
    for (var e = [], t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
    var i = Array.from(typeof r == "string" ? [r] : r);
    i[i.length - 1] = i[i.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var n = i.reduce(function(u, l) {
      var c = l.match(/\n([\t ]+|(?!\s).)/g);
      return c ? u.concat(c.map(function(h) {
        var p, g;
        return (g = (p = h.match(/[\t ]/g)) === null || p === void 0 ? void 0 : p.length) !== null && g !== void 0 ? g : 0;
      })) : u;
    }, []);
    if (n.length) {
      var s = new RegExp(`
[	 ]{` + Math.min.apply(Math, n) + "}", "g");
      i = i.map(function(u) {
        return u.replace(s, `
`);
      });
    }
    i[0] = i[0].replace(/^\r?\n/, "");
    var o = i[0];
    return e.forEach(function(u, l) {
      var c = o.match(/(?:^|\n)( *)$/), h = c ? c[1] : "", p = u;
      typeof u == "string" && u.includes(`
`) && (p = String(u).split(`
`).map(function(g, y) {
        return y === 0 ? g : "" + h + g;
      }).join(`
`)), o += p + i[l + 1];
    }), o;
  }
  a(Ue, "dedent");
  I.dedent = Ue;
  I.default = Ue;
});

// src/cli/bin/index.ts
import { getEnvConfig as Ke, parseList as Xt, versions as Zt } from "@storybook/core/common";
import { addToGlobalContext as ei } from "@storybook/core/telemetry";
import { logger as ze } from "@storybook/core/node-logger";

// node_modules/chalk/source/vendor/ansi-styles/index.js
var _e = /* @__PURE__ */ a((r = 0) => (e) => `\x1B[${e + r}m`, "wrapAnsi16"), be = /* @__PURE__ */ a((r = 0) => (e) => `\x1B[${38 + r};5;${e}\
m`, "wrapAnsi256"), Oe = /* @__PURE__ */ a((r = 0) => (e, t, i) => `\x1B[${38 + r};2;${e};${t};${i}m`, "wrapAnsi16m"), d = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, ii = Object.keys(d.modifier), rt = Object.keys(d.color), st = Object.keys(d.bgColor), ni = [...rt, ...st];
function ot() {
  let r = /* @__PURE__ */ new Map();
  for (let [e, t] of Object.entries(d)) {
    for (let [i, n] of Object.entries(t))
      d[i] = {
        open: `\x1B[${n[0]}m`,
        close: `\x1B[${n[1]}m`
      }, t[i] = d[i], r.set(n[0], n[1]);
    Object.defineProperty(d, e, {
      value: t,
      enumerable: !1
    });
  }
  return Object.defineProperty(d, "codes", {
    value: r,
    enumerable: !1
  }), d.color.close = "\x1B[39m", d.bgColor.close = "\x1B[49m", d.color.ansi = _e(), d.color.ansi256 = be(), d.color.ansi16m = Oe(), d.bgColor.
  ansi = _e(10), d.bgColor.ansi256 = be(10), d.bgColor.ansi16m = Oe(10), Object.defineProperties(d, {
    rgbToAnsi256: {
      value(e, t, i) {
        return e === t && t === i ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 *
        Math.round(t / 255 * 5) + Math.round(i / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(e) {
        let t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(e.toString(16));
        if (!t)
          return [0, 0, 0];
        let [i] = t;
        i.length === 3 && (i = [...i].map((s) => s + s).join(""));
        let n = Number.parseInt(i, 16);
        return [
          /* eslint-disable no-bitwise */
          n >> 16 & 255,
          n >> 8 & 255,
          n & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ a((e) => d.rgbToAnsi256(...d.hexToRgb(e)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(e) {
        if (e < 8)
          return 30 + e;
        if (e < 16)
          return 90 + (e - 8);
        let t, i, n;
        if (e >= 232)
          t = ((e - 232) * 10 + 8) / 255, i = t, n = t;
        else {
          e -= 16;
          let u = e % 36;
          t = Math.floor(e / 36) / 5, i = Math.floor(u / 6) / 5, n = u % 6 / 5;
        }
        let s = Math.max(t, i, n) * 2;
        if (s === 0)
          return 30;
        let o = 30 + (Math.round(n) << 2 | Math.round(i) << 1 | Math.round(t));
        return s === 2 && (o += 60), o;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ a((e, t, i) => d.ansi256ToAnsi(d.rgbToAnsi256(e, t, i)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ a((e) => d.ansi256ToAnsi(d.hexToAnsi256(e)), "value"),
      enumerable: !1
    }
  }), d;
}
a(ot, "assembleStyles");
var at = ot(), C = at;

// node_modules/chalk/source/vendor/supports-color/index.js
import Y from "node:process";
import lt from "node:os";
import Ce from "node:tty";
function b(r, e = globalThis.Deno ? globalThis.Deno.args : Y.argv) {
  let t = r.startsWith("-") ? "" : r.length === 1 ? "-" : "--", i = e.indexOf(t + r), n = e.indexOf("--");
  return i !== -1 && (n === -1 || i < n);
}
a(b, "hasFlag");
var { env: f } = Y, F;
b("no-color") || b("no-colors") || b("color=false") || b("color=never") ? F = 0 : (b("color") || b("colors") || b("color=true") || b("color=\
always")) && (F = 1);
function ut() {
  if ("FORCE_COLOR" in f)
    return f.FORCE_COLOR === "true" ? 1 : f.FORCE_COLOR === "false" ? 0 : f.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(f.FORCE_COLOR,
    10), 3);
}
a(ut, "envForceColor");
function ct(r) {
  return r === 0 ? !1 : {
    level: r,
    hasBasic: !0,
    has256: r >= 2,
    has16m: r >= 3
  };
}
a(ct, "translateLevel");
function ht(r, { streamIsTTY: e, sniffFlags: t = !0 } = {}) {
  let i = ut();
  i !== void 0 && (F = i);
  let n = t ? F : i;
  if (n === 0)
    return 0;
  if (t) {
    if (b("color=16m") || b("color=full") || b("color=truecolor"))
      return 3;
    if (b("color=256"))
      return 2;
  }
  if ("TF_BUILD" in f && "AGENT_NAME" in f)
    return 1;
  if (r && !e && n === void 0)
    return 0;
  let s = n || 0;
  if (f.TERM === "dumb")
    return s;
  if (Y.platform === "win32") {
    let o = lt.release().split(".");
    return Number(o[0]) >= 10 && Number(o[2]) >= 10586 ? Number(o[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in f)
    return "GITHUB_ACTIONS" in f || "GITEA_ACTIONS" in f ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((o) => o in
    f) || f.CI_NAME === "codeship" ? 1 : s;
  if ("TEAMCITY_VERSION" in f)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(f.TEAMCITY_VERSION) ? 1 : 0;
  if (f.COLORTERM === "truecolor" || f.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in f) {
    let o = Number.parseInt((f.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (f.TERM_PROGRAM) {
      case "iTerm.app":
        return o >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(f.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(f.TERM) || "COLORTERM" in f ?
  1 : s;
}
a(ht, "_supportsColor");
function ye(r, e = {}) {
  let t = ht(r, {
    streamIsTTY: r && r.isTTY,
    ...e
  });
  return ct(t);
}
a(ye, "createSupportsColor");
var pt = {
  stdout: ye({ isTTY: Ce.isatty(1) }),
  stderr: ye({ isTTY: Ce.isatty(2) })
}, Ae = pt;

// node_modules/chalk/source/utilities.js
function ve(r, e, t) {
  let i = r.indexOf(e);
  if (i === -1)
    return r;
  let n = e.length, s = 0, o = "";
  do
    o += r.slice(s, i) + e + t, s = i + n, i = r.indexOf(e, s);
  while (i !== -1);
  return o += r.slice(s), o;
}
a(ve, "stringReplaceAll");
function we(r, e, t, i) {
  let n = 0, s = "";
  do {
    let o = r[i - 1] === "\r";
    s += r.slice(n, o ? i - 1 : i) + e + (o ? `\r
` : `
`) + t, n = i + 1, i = r.indexOf(`
`, n);
  } while (i !== -1);
  return s += r.slice(n), s;
}
a(we, "stringEncaseCRLFWithFirstIndex");

// node_modules/chalk/source/index.js
var { stdout: Ee, stderr: xe } = Ae, J = Symbol("GENERATOR"), k = Symbol("STYLER"), N = Symbol("IS_EMPTY"), Se = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], T = /* @__PURE__ */ Object.create(null), dt = /* @__PURE__ */ a((r, e = {}) => {
  if (e.level && !(Number.isInteger(e.level) && e.level >= 0 && e.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let t = Ee ? Ee.level : 0;
  r.level = e.level === void 0 ? t : e.level;
}, "applyOptions");
var ft = /* @__PURE__ */ a((r) => {
  let e = /* @__PURE__ */ a((...t) => t.join(" "), "chalk");
  return dt(e, r), Object.setPrototypeOf(e, V.prototype), e;
}, "chalkFactory");
function V(r) {
  return ft(r);
}
a(V, "createChalk");
Object.setPrototypeOf(V.prototype, Function.prototype);
for (let [r, e] of Object.entries(C))
  T[r] = {
    get() {
      let t = D(this, z(e.open, e.close, this[k]), this[N]);
      return Object.defineProperty(this, r, { value: t }), t;
    }
  };
T.visible = {
  get() {
    let r = D(this, this[k], !0);
    return Object.defineProperty(this, "visible", { value: r }), r;
  }
};
var K = /* @__PURE__ */ a((r, e, t, ...i) => r === "rgb" ? e === "ansi16m" ? C[t].ansi16m(...i) : e === "ansi256" ? C[t].ansi256(C.rgbToAnsi256(
...i)) : C[t].ansi(C.rgbToAnsi(...i)) : r === "hex" ? K("rgb", e, t, ...C.hexToRgb(...i)) : C[t][r](...i), "getModelAnsi"), mt = ["rgb", "he\
x", "ansi256"];
for (let r of mt) {
  T[r] = {
    get() {
      let { level: t } = this;
      return function(...i) {
        let n = z(K(r, Se[t], "color", ...i), C.color.close, this[k]);
        return D(this, n, this[N]);
      };
    }
  };
  let e = "bg" + r[0].toUpperCase() + r.slice(1);
  T[e] = {
    get() {
      let { level: t } = this;
      return function(...i) {
        let n = z(K(r, Se[t], "bgColor", ...i), C.bgColor.close, this[k]);
        return D(this, n, this[N]);
      };
    }
  };
}
var gt = Object.defineProperties(() => {
}, {
  ...T,
  level: {
    enumerable: !0,
    get() {
      return this[J].level;
    },
    set(r) {
      this[J].level = r;
    }
  }
}), z = /* @__PURE__ */ a((r, e, t) => {
  let i, n;
  return t === void 0 ? (i = r, n = e) : (i = t.openAll + r, n = e + t.closeAll), {
    open: r,
    close: e,
    openAll: i,
    closeAll: n,
    parent: t
  };
}, "createStyler"), D = /* @__PURE__ */ a((r, e, t) => {
  let i = /* @__PURE__ */ a((...n) => _t(i, n.length === 1 ? "" + n[0] : n.join(" ")), "builder");
  return Object.setPrototypeOf(i, gt), i[J] = r, i[k] = e, i[N] = t, i;
}, "createBuilder"), _t = /* @__PURE__ */ a((r, e) => {
  if (r.level <= 0 || !e)
    return r[N] ? "" : e;
  let t = r[k];
  if (t === void 0)
    return e;
  let { openAll: i, closeAll: n } = t;
  if (e.includes("\x1B"))
    for (; t !== void 0; )
      e = ve(e, t.close, t.open), t = t.parent;
  let s = e.indexOf(`
`);
  return s !== -1 && (e = we(e, n, i, s)), i + e + n;
}, "applyStyle");
Object.defineProperties(V.prototype, T);
var bt = V(), gi = V({ level: xe ? xe.level : 0 });
var R = bt;

// src/cli/bin/index.ts
var H = U(Me(), 1);

// ../node_modules/fd-package-json/dist/esm/main.js
var pe = U(je(), 1);
import { resolve as Le } from "node:path";
import { stat as Ht, readFile as Ft } from "node:fs/promises";
import { statSync as Dt, readFileSync as Rt } from "node:fs";
async function Mt(r) {
  try {
    return (await Ht(r)).isFile();
  } catch {
    return !1;
  }
}
a(Mt, "fileExists");
function Bt(r) {
  try {
    return Dt(r).isFile();
  } catch {
    return !1;
  }
}
a(Bt, "fileExistsSync");
async function jt(r) {
  for (let e of (0, pe.walkUp)(r)) {
    let t = Le(e, "package.json");
    if (await Mt(t))
      return t;
  }
  return null;
}
a(jt, "findPackagePath");
async function L(r) {
  let e = await jt(r);
  if (!e)
    return null;
  try {
    let t = await Ft(e, { encoding: "utf8" });
    return JSON.parse(t);
  } catch {
    return null;
  }
}
a(L, "findPackage");
function Lt(r) {
  for (let e of (0, pe.walkUp)(r)) {
    let t = Le(e, "package.json");
    if (Bt(t))
      return t;
  }
  return null;
}
a(Lt, "findPackagePathSync");
function qe(r) {
  let e = Lt(r);
  if (!e)
    return null;
  try {
    let t = Rt(e, { encoding: "utf8" });
    return JSON.parse(t);
  } catch {
    return null;
  }
}
a(qe, "findPackageSync");

// node_modules/leven/index.js
var de = [], We = [];
function fe(r, e) {
  if (r === e)
    return 0;
  let t = r;
  r.length > e.length && (r = e, e = t);
  let i = r.length, n = e.length;
  for (; i > 0 && r.charCodeAt(~-i) === e.charCodeAt(~-n); )
    i--, n--;
  let s = 0;
  for (; s < i && r.charCodeAt(s) === e.charCodeAt(s); )
    s++;
  if (i -= s, n -= s, i === 0)
    return n;
  let o, u, l, c, h = 0, p = 0;
  for (; h < i; )
    We[h] = r.charCodeAt(s + h), de[h] = ++h;
  for (; p < n; )
    for (o = e.charCodeAt(s + p), l = p++, u = p, h = 0; h < i; h++)
      c = o === We[h] ? l : l + 1, l = de[h], u = de[h] = l > u ? c > u ? u + 1 : c : c > l ? l + 1 : c;
  return u;
}
a(fe, "leven");

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var qt = process.env.NODE_ENV === "production", me = "Invariant failed";
function $(r, e) {
  if (!r) {
    if (qt)
      throw new Error(me);
    var t = typeof e == "function" ? e() : e, i = t ? "".concat(me, ": ").concat(t) : me;
    throw new Error(i);
  }
}
a($, "invariant");

// src/cli/build.ts
import { cache as Wt } from "@storybook/core/common";
import { buildStaticStandalone as Gt, withTelemetry as Ut } from "@storybook/core/core-server";
var Ge = /* @__PURE__ */ a(async (r) => {
  let e = await L(__dirname);
  $(e, "Failed to find the closest package.json file.");
  let t = {
    ...r,
    configDir: r.configDir || "./.storybook",
    outputDir: r.outputDir || "./storybook-static",
    ignorePreview: !!r.previewUrl && !r.forceBuildPreview,
    configType: "PRODUCTION",
    cache: Wt,
    packageJson: e
  };
  await Ut(
    "build",
    { cliOptions: r, presetOptions: t },
    () => Gt(t)
  );
}, "build");

// src/cli/dev.ts
import { cache as Yt } from "@storybook/core/common";
import { buildDevStandalone as Jt, withTelemetry as Kt } from "@storybook/core/core-server";
import { logger as x, instance as zt } from "@storybook/core/node-logger";
var ge = U(Ye(), 1);
function Qt(r) {
  zt.heading = "", r instanceof Error ? r.error ? x.error(r.error) : r.stats && r.stats.compilation.errors ? r.stats.compilation.errors.forEach(
  (e) => x.plain(e)) : x.error(r) : r.compilation?.errors && r.compilation.errors.forEach((e) => x.plain(e)), x.line(), x.warn(
    r.close ? ge.dedent`
          FATAL broken build!, will close the process,
          Fix the error below and restart storybook.
        ` : ge.dedent`
          Broken build, fix the error above.
          You may need to refresh the browser.
        `
  ), x.line();
}
a(Qt, "printError");
var Je = /* @__PURE__ */ a(async (r) => {
  process.env.NODE_ENV = process.env.NODE_ENV || "development";
  let e = await L(__dirname);
  $(e, "Failed to find the closest package.json file.");
  let t = {
    ...r,
    configDir: r.configDir || "./.storybook",
    configType: "DEVELOPMENT",
    ignorePreview: !!r.previewUrl && !r.forceBuildPreview,
    cache: Yt,
    packageJson: e
  };
  await Kt(
    "dev",
    {
      cliOptions: r,
      presetOptions: t,
      printError: Qt
    },
    () => Jt(t)
  );
}, "dev");

// src/cli/bin/index.ts
ei("cliVersion", Zt.storybook);
var E = qe(__dirname);
$(E, "Failed to find the closest package.json file.");
var q = console, Qe = /* @__PURE__ */ a((r) => H.program.command(r).option(
  "--disable-telemetry",
  "Disable sending telemetry data",
  // default value is false, but if the user sets STORYBOOK_DISABLE_TELEMETRY, it can be true
  process.env.STORYBOOK_DISABLE_TELEMETRY && process.env.STORYBOOK_DISABLE_TELEMETRY !== "false"
).option("--debug", "Get more logs in debug mode", !1).option("--enable-crash-reports", "Enable sending crash reports to telemetry data"), "\
command");
Qe("dev").option("-p, --port <number>", "Port to run Storybook", (r) => parseInt(r, 10)).option("-h, --host <string>", "Host to run Storyboo\
k").option("-c, --config-dir <dir-name>", "Directory where to load Storybook configurations from").option(
  "--https",
  "Serve Storybook over HTTPS. Note: You must provide your own certificate information."
).option(
  "--ssl-ca <ca>",
  "Provide an SSL certificate authority. (Optional with --https, required if using a self-signed certificate)",
  Xt
).option("--ssl-cert <cert>", "Provide an SSL certificate. (Required with --https)").option("--ssl-key <key>", "Provide an SSL key. (Require\
d with --https)").option("--smoke-test", "Exit after successful start").option("--ci", "CI mode (skip interactive prompts, don't open browse\
r)").option("--no-open", "Do not open Storybook automatically in the browser").option("--loglevel <level>", "Control level of logging during\
 build").option("--quiet", "Suppress verbose build output").option("--no-version-updates", "Suppress update check", !0).option("--debug-webp\
ack", "Display final webpack configurations for debugging purposes").option(
  "--webpack-stats-json [directory]",
  "Write Webpack stats JSON to disk (synonym for `--stats-json`)"
).option("--stats-json [directory]", "Write stats JSON to disk").option(
  "--preview-url <string>",
  "Disables the default storybook preview and lets your use your own"
).option("--force-build-preview", "Build the preview iframe even if you are using --preview-url").option("--docs", "Build a documentation-on\
ly site using addon-docs").option("--exact-port", "Exit early if the desired port is not available").option(
  "--initial-path [path]",
  "URL path to be appended when visiting Storybook for the first time"
).action(async (r) => {
  ze.setLevel(r.loglevel), q.log(R.bold(`${E.name} v${E.version}`) + R.reset(`
`)), Ke(r, {
    port: "SBCONFIG_PORT",
    host: "SBCONFIG_HOSTNAME",
    staticDir: "SBCONFIG_STATIC_DIR",
    configDir: "SBCONFIG_CONFIG_DIR",
    ci: "CI"
  }), parseInt(`${r.port}`, 10) && (r.port = parseInt(`${r.port}`, 10)), await Je({ ...r, packageJson: E }).catch(() => process.exit(1));
});
Qe("build").option("-o, --output-dir <dir-name>", "Directory where to store built files").option("-c, --config-dir <dir-name>", "Directory w\
here to load Storybook configurations from").option("--quiet", "Suppress verbose build output").option("--loglevel <level>", "Control level \
of logging during build").option("--debug-webpack", "Display final webpack configurations for debugging purposes").option(
  "--webpack-stats-json [directory]",
  "Write Webpack stats JSON to disk (synonym for `--stats-json`)"
).option("--stats-json [directory]", "Write stats JSON to disk").option(
  "--preview-url <string>",
  "Disables the default storybook preview and lets your use your own"
).option("--force-build-preview", "Build the preview iframe even if you are using --preview-url").option("--docs", "Build a documentation-on\
ly site using addon-docs").option("--test", "Build stories optimized for testing purposes.").action(async (r) => {
  process.env.NODE_ENV = process.env.NODE_ENV || "production", ze.setLevel(r.loglevel), q.log(R.bold(`${E.name} v${E.version}
`)), Ke(r, {
    staticDir: "SBCONFIG_STATIC_DIR",
    outputDir: "SBCONFIG_OUTPUT_DIR",
    configDir: "SBCONFIG_CONFIG_DIR"
  }), await Ge({
    ...r,
    packageJson: E,
    test: !!r.test || process.env.SB_TESTBUILD === "true"
  }).catch(() => process.exit(1));
});
H.program.on("command:*", ([r]) => {
  q.error(
    ` Invalid command: %s.
 See --help for a list of available commands.`,
    r
  );
  let t = H.program.commands.map((i) => i.name()).find((i) => fe(i, r) < 3);
  t && q.info(`
 Did you mean ${t}?`), process.exit(1);
});
H.program.usage("<command> [options]").version(String(E.version)).parse(process.argv);
